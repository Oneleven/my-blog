<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[CSS动画基础]]></title>
      <url>%2F2017%2F05%2F28%2FCSS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[transformtransform指变换，使用过photoshop的人应该知道里面的Ctrl+T自由变换。transform就是指的这个东西，拉伸，压缩，旋转，偏移，且transform 属性 , 只对 block 级元素生效！（配合transition过渡） 平移： 123transform: translate(tx[, ty]) translateX(tx) x轴方向平移 translateY(ty) 角度旋转：transform: rotate(angle) 缩放： 123transform: scale(sx[, sy]) scaleX(sx); x轴方向缩放 scaleY(sy) 倾斜： 123transform: skew(ax[, ay]) skewX(angle) skewY(angle) 旋转中心：transform-origin:x-axis y-axis z-axis (值：left，right，center，length，%) transition transition提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。(即平滑地改变css的属性值) 语法： transition：property name | duration //过渡时间 ​ transition： property name | duration | delay //过渡时间、延长时间 ​ transition：property name | duration | timing function | delay //过渡时间、效果、延长时间 ​ transition: margin-left 4s, color 1s //两个属性用逗号隔开 ​ transition: all 0.5s ease-out //all transition-property :指定过渡的性质，比如transition-property:backgrond 就是指backgound参与这个过渡 transition-duration:指定这个过渡的持续时间 transition-timing-function:指定过渡类型，有ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier（贝塞尔曲线） transition-delay:延迟过渡时间 123456transition-timing-function: linear 匀速 ease 慢-快-慢 ease-in 先慢后快 ease-out 先快后慢 ease-in-out 先慢后快再慢 cubic-bezier(n,n,n,n); 自定义（http://cubic-bezier.com/） perspective perspective 属性指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。 默认情况下，透视消失点位于元素的中心，但是可以通过设置perspective-origin属性来改变其位置。在父容器上设置perspective（相当于远处的舞台），会让元素指向透视的消失点。 1perspective-origin: x-axis y-axis (值：left，right，center，length，%) 注：perspective在Z轴上，而perspective是设置Z轴的长度。在css3中只有设置了perspective的值元素才会有Z轴，perspective为none元素则没有Z轴(就是2D元素)。 animation &amp; keyframes 创建动画序列，需要使用animation属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 @keyframes规则实现。 语法：animation: name duration timing-function delay iteration-count direction; animation-name: 规定需要绑定到选择器的 keyframe 名称。 animation-duration: 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function: ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier（贝塞尔曲线） animation-delay:设置延时，规定在动画开始之前的延迟。 animation-iteration-count: infinite|小数定义循环（0.5将播放动画到一半）设置动画重复次数， 可以指定infinite无限次重复动画. animation-direction: normal|alternate（交替反向运动）|reverse|alternate-reverse 设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行。 animation-play-state: running|paused 暂停和恢复动画 一旦完成动画的时间设置， 接下来就需要定义动画的表现。通过使用@keyframes建立两个或两个以上关键帧来实现。每一个关键帧都描述了动画元素在给定的时间点上应该如何渲染。 要使用关键帧, 先创建一个带名称的@keyframes规则，以便后续使用 animation-name这个属性来调用指定的@keyframes 关键帧使用百分比来指定动画发生的时间点。0%表示动画的第一时刻，100%表示动画的最终时刻。因为这两个时间点十分重要，所以还有特殊的别名：from和to。 @keyframes 不存在层叠样式(cascade)的情况，如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 小结：animation定义动画的时间，keyframes定义动画的效果。 举例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中的this值]]></title>
      <url>%2F2017%2F05%2F21%2FJS%E4%B8%AD%E7%9A%84this%E5%80%BC%2F</url>
      <content type="text"><![CDATA[什么是Thisthis总是返回一个对象，即返回属性或者方法“当前”所在的对象。在JavaScript语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是这个对象（环境）。也可以近似地认为，this是所有函数运行时的一个隐藏参数，指向函数的运行环境。 如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。 123function fn()&#123; console.log(this) //window&#125; 函数的call任何函数都可以用function.prototype.call()的形式来调用，其中call的第一个参数会变为函数里的this，call的其他参数组成函数里面的arguments。 123456789101112function f()&#123; console.log(this) console.log(arguments)&#125;var a =&#123;name:&apos;tom&apos;&#125;f.call(a,1,2,3) *call第一个参数会当作this，后面的会当做arguments*每次进入函数之前，都会创造this和arguments这两件事情---------------f()等价于f.call（）object.f(1,2,3)等价于 obj.f.call(obj,1,2,3) //this为obj this 就是你 call 一个函数时，传入的第一个参数 12345678910111213141516var A = &#123; name: &apos;Tom&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var B = &#123; name: &apos;Jack&apos;&#125;;B.describe = A.describe;A.describe() //&quot;姓名：Tom&quot;B.describe() // &quot;姓名：Jack&quot;--------------A.describe() 转换为 A.describe.call(A)，this就是A，那么this.name即 Tom；同样的，B.describe() 可以转换为B.describe.call(B),this就是B，那么this.name即Jack 如何确定this的值1.看源码中对应的函数是怎么被call的 2.看文档 123btn.addEventListener(&apos;click&apos; ,function handler()&#123; console.log(this) // 请问这里的 this 是什么&#125;) EventTarget.addEventListener()处理过程中 this 的值的问题，在MDN文档中是这样说的： 通常来说this的值是触发事件的元素的引用，这种特性在多个相似的元素使用同一个通用事件监听器时非常让人满意。 当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 currentTarget 属性的值一样。 所以，上面this指的就是事件被监听的元素btn 3.打印出来console.log(this)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS调试]]></title>
      <url>%2F2017%2F04%2F25%2FJS%E8%B0%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[史上第一个bug1947年9月9日，葛丽丝·霍普（Grace Hopper）发现了第一个电脑上的bug。当在Mark II计算机上工作时，整个团队都搞不清楚为什么电脑不能正常运作了。经过大家的深度挖掘，发现原来是一只飞蛾意外飞入了一台电脑内部而引起的故障。这个团队把错误解除了，并在日记本中记录下了这一事件。也因此，人们逐渐开始用“Bug”（原意为“虫子”）来称呼计算机中的隐错。 debug 就是找出 bug 的过程。 打字会错123456iOS 写成 iosJavaScript 写成 Javascriptvertical 写成 verticelprops 写成 porps半角空格写成全角空格ls -la 写成 ls-la html的bug 用https://validator.w3.org/#validate_by_input这个网址来检查错误（validator验证器） 用WebStorm检查（语法错误以及拼写错误） CSS的bug用border以及开发者工具 没有样式，选择器没有选择到，(.tabsb li b 后面多了个逗号,) CSS错误的注释会毁掉下面一行 用border大法可以清楚地看到由于浮动而造成的符元素内容塌陷 当使用border会影响布局的时候，用outlne代替，它不会占用盒模型位置 VS. JavaScript的bug 确定你的代码运行了 上帝视角 拼写错误 拼写错误 拼写错误 其他错误（用 WebStorm 可以避免拼写错误） 用 console.log 或者 console.assert 验证 html文件映射到浏览器页面，直接在浏览器中修改调试 打开谷歌开发者工具 — setting — workspace — add folder 映射 Map to File System Resource 按下esc，出现控制台，就可以实时修改了，修改完按下保存再刷新，进行调试。 Uncaught ReferenceError:appel is not defined：用了一个未声明过的变量。（reference error 引用错误） 把它打印出来是什么类型 Uncaught TypeError: obj.fooo is not a function：不是一个函数 （type error类型错误） 打印出来，属性不报错，返回undefined （变量未声明直接用回报错，属性没声明直接用不报错） Uncaught SyntaxError: Unexpected token function ：未意料到的字符 function ，说明语法有错误（foo:function） （syntax error语法错误） Uncaught TypeError : Cannot read property ‘join’ of undefined：jion前面的出现错误]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM API获取元素的几种方法]]></title>
      <url>%2F2017%2F04%2F19%2FAPI%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%9D%2F</url>
      <content type="text"><![CDATA[DOM节点DOM的最小组成单位叫做节点（node）。文档的树形结构（DOM树），就是由各种不同类型的节点组成。节点有以下7种类型 Document：整个文档树的顶层节点（root node） DocumentType: doctype标签 Element：网页的各种HTML标签 Attribute：网页元素的属性（如calss=”aa”) Text：标签之间包含的文本内容 Comment：注释 DocumentFragment：文档片段 节点间的关系除了根节点&lt;html&gt;，它的下级节点与周围节点存在三种关系 父节点关系：parentNode 子节点关系：childNodes firstChild：第一个子节点 lastChild：最后一个子节点 同级节点关系：sibling nextSibling：紧邻在后的那个同级节点 previousSibling：紧邻在前的那个同级节点 document.querySelector()接受一个css选择器作为参数，返回匹配该选择器的第一个节点，如果没有匹配的节点返回null。 语法：element = document.querySelector(selectors) ，selectors是一个字符串，包含一个或者多个css选择器，多个以逗号分隔。 123var element1 = document.querySelector(&apos;.myclass&apos;)var element2 = document.querySelector(&apos;p&apos;) //返回第一个p元素var element3 = document.querySelector(&apos;p.myclass&apos;) //返回文档中class=&quot;myclass&quot;的第一个&lt;p&gt;元素 *document.querySelectorAll()：返回一个NodeList对象，包含所有匹配给定选择器的节点 document.getElementsByTagName()返回一个包括所有给定标签名称的元素集合，如果没有匹配的元素，返回一个空集。可以在任意一个元素上调用该方法。（从给定的父节点开始往下找，如果是div.getElementsByTagName()，则从div这个节点开始往下找） 语法：var elements = document.getElementsByTagName(name)，name是一个字符串。 12var a = document.getElementsByTagName(&apos;p&apos;)//返回当前文档的全部p元素节点 document.getElementsByClassName()返回一个包含所有指定class名称的元素集合，可以在任意元素上调用该方法。 语法：var elements = document.getElementsByClassName(names)，names是一个字符串，如果含有多个class名称，用空格分隔。 12document.getElementsByClassName(&apos;red test&apos;)//返回所有calss名为 red 和 test 的元素 document.getElementById()返回拥有指定id的第一个元素，如果不存在则返回null 语法：element = document.getElementById(id)，id为大小写敏感的字符串 12document.getElementById(&apos;myid&apos;)//返回一个id为myid的元素 Node.firstChild返回树中节点的第一个子节点，如果无子节点，则返回null。（注：空白符节点会充当一个文本节点，可以Node.firstChild.firstChild…的形式使用） 类似的还有：Node.lastChild \ Node.nextSibling \ Node.previousSibling \ Node.parentNode 12345678&lt;p id=&quot;para-01&quot;&gt; &lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var p01 = document.getElementById(&apos;para-01&apos;); alert(p01.firstChild.nodeName)&lt;/script&gt;//返回#text , 因为换行符和空格充当了一个文本节点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM事件委托]]></title>
      <url>%2F2017%2F04%2F19%2FDOM%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
      <content type="text"><![CDATA[事件的三个特点 TOM （代码）订阅/关注/监听了 XXX（用户） XXX （用户）发生了变化 TOM（代码）得到通知 捕获&amp;冒泡 操作系统最先知道用户点击了鼠标，浏览器次之 child 被点击了，意味着 parent 也被点击了 如果同时监听了child和parent，那么 捕获阶段：先通知parent，后通知child 123456child.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;child&apos;)&#125;,true)parent1.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;parent1&apos;)&#125;,ture) //添加ture参数，表示捕获阶段 冒泡阶段：先通知chlid，后通知parent 123456child.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;child&apos;)&#125;,flase)parent1.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;parent1&apos;)&#125;,flase) //默认为flase，冒泡阶段 W3C事件模型：支持两种阶段 12button.addEventListener(&apos;click&apos;,fn,true) //永远别用button.addEventListener(&apos;click&apos;,fn) 如何监听事件当同一个对象使用.onclick的写法触发多个方法的时候，后一个方法会把前一个方法覆盖掉，也就是说，在对象的onclick事件发生时，只会执行最后绑定的方法。而用事件监听则不会有覆盖的现象，每个绑定的事件都会被执行。 DOM level 0 事件： button.onclick = function(){} DOM level 2 事件： button.addEventListener(‘click’, function(){}) e／event1234child1.addEventListener(&apos;click&apos;,function(e)&#123; console.log(e)&#125;)//当出发事件的时候，e告诉你相关事件的任何信息 e.target&amp;e.currentTarget target：触发事件的元素，即点击的元素 currentEvent：被监听的元素 以下图片先点击绿色边框（parent），然后再点击红色区域（child） 阻止默认事件 e.preventDefault()如果加在父元素上，对其子元素也有阻止事件的作用，所以尽量用在要阻止事件的具体子元素上，以免让其他事件失效（图中阻止了a链接的跳转作用，点击百度不会发生跳转） 停止冒泡e.stopPropagation()propagation:传播的意思。 用户点击了子元素，不要向父元素通知。 事件委托 事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。简而言之就是委托它们的父级代为执行事件。 没有时间委托，逐个监听事件 监听是占用内存的，既然4个li做了相同的事情，那么直接监听父元素，同样点击li元素可以实现。（但是有一个问题就是父元素里面的所有内容都会触发事件，包括点击父元素的padding。） 那么添加一个if条件e.target.nodeName === &#39;LI&#39;，让触发事件的目标在元素LI 上，此时解决了上面li元素外和父容器之间也会触发事件的问题。（但是又引申出了一个新的问题，就是点击LI的后代元素无法触发事件。这和初衷不相符。） 再修改一下if条件，e.target.nodeName ===&#39;LI&#39;||e.target.parentNode.nodeName === &#39;LI&#39; , 让LI的span元素也能触发事件，此时的委托事件正好满足这个例子。（但是如果li有多个后代元素，又无法满足条件了。） 再完善一下，我要点击后代元素触发事件，要判断其父元素是不是LI ，如果不是，继续网上找，直到找到li 。（但这样会出现找不到LI的情况，一直网上找到document，再网上就返回null了。） 继续完善，网上找的过程中，如果一直到监听的哪一层元素还没找到，那就停止，返回null。 123456789101112131415161718//较为完整的事件委托代码var ul = document.querySelector(&apos;ul&apos;)function f(e)&#123; let el = e.target while(el.nodeName !== &apos;LI&apos;)&#123; if(el === ul)&#123; el = null break; &#125; el = el.parentNode &#125; if(el)&#123; console.log(&apos;ok&apos;) &#125;else &#123; console.log(&apos;no&apos;) &#125;&#125;ul.addEventListener(&apos;click&apos;,f)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js内存图]]></title>
      <url>%2F2017%2F04%2F03%2Fjs%E5%86%85%E5%AD%98%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[栈（stack） 基本类型是保存在栈内存中的简单的数据段，数据大小确定并且占有固定大小的空间，它们是按值存放的，所以可以直接访问。基本类型有Number , String , Null , Undefined , Boolean , symbol。 基本类型的拷贝是传值 123456var a = 1var b = 2b = aa = 8// 此时b的值为1*基础类型的变量发生复制行为时，直接把a对应的值copy给b，b=1。它们两个变量的值是相互独立不影响的，所以当改变a的值为8时，b的值不会跟着改变仍然为1 堆（heap） 引用类型（复杂类型），即Object（数组，对象，函数等），它们的值是不固定的，存储方式是在堆内存中存储对象，在栈内存中存储该对象的地址（该地址指向对应的对象） 复杂类型的拷贝是传址 123456var a = &#123;m:10&#125;var b = &#123;n:20&#125;b = aa.k = 30b = &#123;m:10 , k:30&#125;*复杂类型的变量发生复制时，复制的是栈内存中的地址，然后指向堆内存中的同一个对象，所以当对象内容发生变化时，两者都会相应地发生改变。 浅拷贝（把栈里面的东西拷贝一遍）如上面举的例子，b拷贝了a后，它们同时指向同一个内存，此时只要改变a或b其中任何一个变量的值，另外一个值就会跟着改变，这种就是浅拷贝。 深拷贝（把堆里面的东西拷贝一遍）b拷贝了a后，在堆内存中重新开辟一个内存来存储b的值，此时指向不同的地址，相互独立。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见的几种排序算法简介]]></title>
      <url>%2F2017%2F03%2F25%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[冒泡排序（bubble sort） 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 比较每一对相邻的两个元素，大的元素放后面，那么比较完一轮后，最后的元素应该是确定的最大的数。 针对所有的元素重复以上的步骤，除了最后一个数（上一轮确定下来的最大的数），直到没有任何一对数字需要比较，排序完成。 选择排序（selection sort） 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 插入排序（insertion sort） 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 从第一个元素开始（该元素可以认为已经被排序），然后取出下一个元素，在已经排序的元素序列中从后向前扫描 依次比较大小，如果前面一个元素比自己大，就继续向前比较，知道找到比自己小的元素，并排在这个元素后面。 重复以上步骤，直到最后一个元素比较完，排序完成。 归并排序（merge sort）通常用递归实现，先把待排序区间[s,t]以中点二分，分成左右区间，接着左右区间继续中点二分，分成更小的左右区间，一层层直到分到单个元素的左右区间，然后一个个小的左右区间比较大小排序并且一层层往上归并，最后把左区间和右区间合并成有序的区间[s,t]。 快速排序（quick sort） 把要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 从数列中挑出一个元素，称为”基准”（pivot） 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作。 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 #### 动手玩一下算法动态演示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS定位position]]></title>
      <url>%2F2017%2F03%2F22%2FCSS%E5%AE%9A%E4%BD%8Dposition%2F</url>
      <content type="text"><![CDATA[position属性指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型。 relative相对定位position:relative ：元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。通过“left”,”top”,”right”,”bottom”来规定位置。 *相对定位的元素并未脱离文档流 注：图二chlid1相对自己原来的位置向右移动了50px，但是child2作为一个行内元素并没有向前移动，去占据child1留下来的空白位置（说明child1原来的位置仍然被它占据着） absolute绝对定位position:absolute ：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置(如果没有祖先元素，则用它所在的包含块来定位）。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。通过“left”,”top”,”right”,”bottom”来规定位置。 *绝对定位的元素脱离了文档流 有非 static 定位的祖先元素 当最近的祖先元素添加position:relative 后，child1根据它来定位。 child1设置了absolute绝对定位后，它的宽度变成了30px，变成了块状元素，即使后面再次声明display:inline; ，它还是以块状元素来显示。 没有非 static 定位的祖先元素 可以看到child1并非根据body以及html来定位。经查css spec（如下图），在没有非static定位的祖先元素的时候，absolute定位是根据根元素的包含块（containing block）来定位的，根元素的包含块也叫初始包含块（initial containing block）, 而初始包含块取自视口的尺寸，并且被固定在画布开始的位置。 fixed绝对定位position:fixed ：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。通过“left”,”top”,”right”,”bottom”来规定位置。 *绝对定位的元素脱离了文档流，比浮动元素更高一层。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css浮动]]></title>
      <url>%2F2017%2F03%2F20%2Fcss%E6%B5%AE%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[浮动float CSS的 float 属性可以使一个元素脱离正常的文档流，然后被安放到它所在容器的的左端或者右端，并且其他的文本和行内元素环绕它。 元素只能左右浮动，不能上下移动 一个浮动会尽量向左/右 移动，直到它的外边缘碰到包含框或者另一个浮动框的边框为止 浮动元素之后的元素会围绕它，之前的元素不受影响 语法 说明 float: left 表明元素必须浮动在其所在的块容器左侧 float: right 表明元素必须浮动在其所在的块容器右侧 清除浮动clear clear属性规定了元素的哪一侧不允许浮动元素 语法 说明 clear : left 在左侧不允许浮动元素 clear : right 在右侧不允许浮动元素 clear : both 在左右两侧均不允许浮动元素 清除浮动的几种方法 从上面两张图可以看到，当内层元素加了浮动之后，div的高度塌缩了，因为内层元素此时已经脱离了文档流，父元素不再包含它。为了避免这种情况，可以清除浮动来使父元素撑开。 使用一个空标签：空标签位置不同效果也不同。 通过 ::after 伪元素 设置clear属性:.parent::after这中间没有空格！！ 123456/* new clearfix */.clearfix::after &#123; #css3为了更好地区分伪类和伪元素，用两个冒号:表示 content: &quot;&quot;; #通过content属性来添加样式（显示生效）使用一个空标签 display: block; #::after表示在当前元素的内容后插入一个子元素（行内元素） clear: both;&#125; 给父元素设置display: inline-block属性: 由块状元素转为行内元素，而行内元素可以根据里面的内容自适应高宽（为了显示出相同的效果，这里加了width：100%）。 给父元素设置overflow:auto或hidden属性：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局（display:flex）]]></title>
      <url>%2F2017%2F03%2F19%2Fflex%E5%B8%83%E5%B1%80%EF%BC%88display-flex%EF%BC%89%2F</url>
      <content type="text"><![CDATA[基本概念flex布局适用于简单的线性布局，可以实现空间自动分配和自动对齐。（flexible：弹性，灵活的） flex container的属性 属性 描述 1、flex-direction 方向 2、flex-wrap 换行 3、flex-flow 上面两个的简写 4、justify-content 主轴方向对齐方式 5、align-items 侧轴对齐方式 6、align-content 多行/列内容对齐方式（用的较少） flex-direction：row（从左往右排列，默认）、row-reverse（右往左）、column（上往下）、column-reverse 注：这个属性的排序默认不换行，flex item再多也会自适应调节比例排成一行/列（且此时会无视flex item自身设置的宽/高）。 flex-wrap：wrap flex-flow：row nowarp justify-content： space-between：空间均衡地放在flex item中间，两边的flex item会顶到两侧 space-around：空间均衡地放在flex item周围，最两侧的flex item也有空间包围 flex-start：flex item都往起点靠 flex-end：flex item都往终点靠 center：flex item都放在中间 align-items： stretch：与flex item最长的那一个对齐，是个默认值 flex-start：所有的flex item都往上靠 flex-end：所有的flex item都往下靠 center：居中 baseline：文字基线对齐 align-content：space-around、space-between、flex-start、flex-end flex item的属性 属性 描述 1、flex-grow 增长比例（空间过多时） 2、flex-shrink 收缩比例（空间不够时） 3、flex-basis 默认大小（一般不用） 4、flex 上面三个的缩写 5、order 顺序（代替双飞翼） 6、align-self 自身的对齐方式 flex-grow：数值（1、2、3等），flex item按这个数值的比例分配多余的空间（1表示全部占有） flex-shrink：数值（1、2、3等），flex item按收缩比例分配 flex-basis：200px ， 一开始默认占200px大小的固定空间 order：数值（1、2、3等），改变flex item的空间顺序 align-self： flex-end，flex-start ， center ， 每个独立flex-item对齐。 使用flex布局实例 手机页面布局（topbar+main+tabs) 产品列表（ul&gt;li*9 pc页面布局 完美居中 一个熟练flex属性的网页小游戏http://flexboxfroggy.com/#zh-cn *最后一关： 1234567#pond &#123; display: flex; flex-flow:column-reverse wrap-reverse; align-items:flex-end; justify-content:center; align-content:space-between&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[post和get请求]]></title>
      <url>%2F2017%2F03%2F12%2Fpost%E5%92%8Cget%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[get和post的区别GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同（唯一的区别是语义区别：get是获取数据，post是提交数据） 表象的区别： get post 一般没有请求消息体 有请求消息体 请求的参数包含在请求行的URL中 参数放在请求的消息体里 url中传送的参数长度有限制（浏览器一般设置2k个字节） post消息体的数据可以非常大（一般几兆） 安全性相对较低（get提交数据后账号和密码明文出现在url上） 相对较高 注 #HTTP协议中，HTTP的请求头和消息体都没有长度的要求。对url长度上的限制，是由于浏览器和服务器两方面造成的（出于安全考虑 [避免被过大的url不停攻击] 和 稳定的考虑，会给url长度加一个限制。 这个限制是针对所有http请求的。 ​ #post和get的安全性只是相对这两者比较而言的，事实上两种方式都不安全。 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[请求和响应]]></title>
      <url>%2F2017%2F03%2F12%2Fhttp%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
      <content type="text"><![CDATA[HTTPhttp（HyperText Transfer Protocol），超文本传输协议，它是一种网络协议，所有的www文件都必须遵守这个标准。可以说，web是建立在http协议上通信的。 DNSdns（DomainName System），域名系统（域名解析系统），主要让用户在互联网上通过域名找到对应的ip地址，而不用去记住能够被机器直接读取的IP数串。 输入：域名 ， 输出：IP 一个域名对应的ip可以有很多（eg：ping baidu.com) 一个域名对应的ip是由域名所有者指定的 改 hosts 可以手动指定域名对应的 IP DNS 可能有缓存，浏览器或者运营商 端口 TCP 或 UDP 协议的规则，一个端口对应一个服务 0 到 1023 号端口是保留端口（只有管理员才能用） 常用端口 21 端口 - FTP 80 端口 - HTTP 53 端口 - DNS 443 端口 - HTTPS 1080 端口 - SOCKS 代理 请求和响应我们在浏览器中输入Google网址到Google网页跳转出来，就经历了一次完整的请求和响应。请求由客户端（即浏览器）发出，响应由服务器端发出。 请求分析123456请求行:（请求方法 路径 协议／版本号） #eg: GET /index.html HTTP/1.1请求头: 请求首部字段 通用首部字段 实体首部字段空格消息体:（aaa=bbbb&amp;ccc=ddd） 注：一般的请求方法有：POST \DELETE \PUT \PATCH \GET \HEAD \OPTIONS \CONNECT \TRACK 响应分析123456状态行 （协议／版本号 状态码 状态描述）#eg:TTP/1.1 200 OK响应头：响应首部字段 通用首部字段 实体首部字段空格消息体 状态码状态码的类别： 类别 原因 1XX Informational（信息状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常，200 3XX Redirection（重定向状态码） 301、302(move temporarily ) 4XX Client Error（客户端错误状态码） 403、404、414 5XX Sever Error（服务器端错误状态码） 500（internal sever error) 一些常见的状态码 状态码 状态描述 200：OK 请求成功 301:moved permanently 请求的资源重定向了，永久移动到新位置（并且浏览器缓存这个结果） 302：move temporarily 请求的资源临时从不同的 URI响应请求。 （浏览器不缓存这个结果） 403:forbidden 服务器拒绝访问。 404:not found 请求失败，请求的资源未在服务器上发现。 405:method not allowed 请求行中指定的请求方法不能被用于请求相应的资源。 414:request-url too long 请求的uri长度超过了服务器能够理解的长度，因此拒绝提供服务。 500:internet server error 服务器遇到了一个未曾预料的状况，导致它无法完成对请求的处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH验证]]></title>
      <url>%2F2017%2F03%2F11%2FSSH%E9%AA%8C%E8%AF%81%2F</url>
      <content type="text"><![CDATA[SSH（ Secure Shell ）是一种网络安全协议，用于计算机之间的加密登入。 两种验证方式： 基于口令的安全验证：输入账号和密码来登入到远程主机，虽然传输的数据都会被加密，但是如果有 ‘中间人’ 冒充我们要访问的服务器，那我们的账号密码就会被 ‘中间人’ 盗取 基于密钥（yuè）的安全验证：用户有两把密钥，一把公钥（对外公开），一把私钥（自己保管）。用ssh公钥登入远程主机，可以免去每次输入密码。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的用户公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。 1命令行操作：ssh-copy-id + url ，把自己的公钥传送存储在远程主机上。 公钥和私钥间的关系： 公钥和私钥是成对的，他们相互解密 公钥加密，只有私钥才能解密，保证数据安全传输 私钥加密签章（数字签名），公钥解密验章用来验证确认对方的身份，用hash函数解密摘要对比来确定信息是否被篡改 数字证书：由CA机构（certificate authority，证书中心）颁发，为公钥做认证，在网上用来识别他人身份的真实性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[input 标签详解]]></title>
      <url>%2F2017%2F03%2F11%2Finput%20%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[input标签用于搜集用户信息，一般放在标签下，根据不同的type属性值，输入字段拥有很多种形式，可以是文本、复选框、按钮等。 一般跟随method属性和action属性，表示如何发送表单数据到action属性所规定的页面 type属性规定input元素的类型，type属性不是必需的，但是应该始终使用它1eg: &lt;input type=&quot;value&quot;&gt; ####type属性及其他常见属性 type=”text” ：默认，定义单行输入字段，用户可在其中输入文本。超出输入字符会继续往后输入，不会换行，也不会调整文本框大小。 type=”password” ：定义密码字段，字段中的字符会被遮蔽。（但是提交上去后密码是可见的，需要其他手段进行加密 其他属性：value \ placeholder \ maxlength \ size \ readonly 123456&lt;form&gt; &lt;input type=&quot;text&quot; value=&quot;hhh&quot;&gt; #value表示显示在文本框中的值，用户输入的时候需要删除 &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; maxlength=&quot;4&quot;&gt; #placeholder作用为提示，文本框中呈灰色字体，输入的时候自动消失，maxlength表示最大能输入的字符（即只能输入4个字符的密码） &lt;input type=&quot;text&quot; size=&quot;30&quot;&gt; # size会生成一个可见30个字符大小的文本框 &lt;input type=&quot;text&quot; value=&quot;hhh&quot; readonly&gt; # readonly是没有值的属性，表示只读，无法修改输入。&lt;/form&gt; type=”button”：定义可点击的按钮（大多与 JavaScript 使用来启动脚本） type=”submit”：定义提交按钮，向服务器发送数据 1234&lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; type=”range” ：定义带有 slider 控件的数字字段。 type=”number” ：定义带有 spinner 控件的数字字段 type=”checkbox” ：定义复选框。 type=”radio”：定义单选按钮。 其他属性：min \ max \ step 12345678910&lt;form&gt; &lt;input type=&quot;range&quot; min=&quot;-10&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;8&quot;&gt; # min和max规定输入的最小和最大值，创建合法值的范围，step表示间隔，value表示初始值 &lt;input type=&quot;number&quot; min=&quot;-100&quot; max=&quot;200&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;小狗 &lt;input type=&quot;checkbox&quot; checked&gt;小猫 #checked表示预先选择该input元素，长与radio和checkbox配合使用） &lt;input type=&quot;radio&quot; name=&quot;a&quot; checked&gt;西瓜 #相同的name值表示3个选项只能选择其一 &lt;input type=&quot;radio&quot; name=&quot;a&quot;&gt;黄瓜 &lt;input type=&quot;radio&quot; name=&quot;a&quot;&gt;苦瓜&lt;/form&gt; type=”color” ; type=”time” ; type=”week” ; type=”month” ; type=”date” ; type=”datetime-local” 123456789&lt;form&gt; &lt;input type=&quot;email&quot;&gt; #定义用于 e-mail 地址的文本字段 &lt;input type=&quot;color&quot;&gt;&lt;br&gt; #定义拾色器 &lt;input type=&quot;time&quot;&gt;&lt;br&gt; #定义时、分、秒（带有 time 控件） &lt;input type=&quot;week&quot;&gt;&lt;br&gt; #定义周（带有 calendar 控件） &lt;input type=&quot;month&quot;&gt;&lt;br&gt; #定义月（带有 calendar 控件） &lt;input type=&quot;date&quot;&gt;&lt;br&gt; #定义日期（带有 calendar 控件） &lt;input type=&quot;datetime-local&quot;&gt; #定义日期及时间（带有 calendar 和 time 控件） &lt;/form&gt; ​ type=”hidden” : 隐藏输入字段，但是提交表单会一起被提交上去 type=”image” : 定义图像作为提交按钮 ; width \ height \ ale 属性 123&lt;form&gt; &lt;input type=&quot;image&quot; src=&quot;image url&quot; width=&quot;30px&quot; alt=&quot;红色按钮&quot;&gt; #width属性调节图片大小(height类似），alt属性表示图片的替代文本 &lt;/form&gt; type=“file” ：提供供文件上传 ；required \ multiple 属性 1234&lt;form&gt; &lt;input type=&quot;file&quot; required&gt; #required 指示输入的字段值是必需的，一次只能上传一个文件，默认也是上传一个 &lt;input type=&quot;file&quot; mulitple&gt; #multiple 允许一个以上的值，可以一下子上传多个文件&lt;/form&gt; 其他属性：list：引用包含输入字段的预定义选项 datalist ，datalist下面接option属性用来提供选择项目，datalist需要type=”text” , 并指定一个id 12345678&lt;form&gt; &lt;input type=&quot;text&quot; list=&quot;datalist1&quot;&gt; #可以预选项里选择，也可以自定义输入其他 &lt;datalist id=&quot;datalist1&quot;&gt; &lt;option&gt;西瓜&lt;/option&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option&gt;香蕉&lt;/option&gt; &lt;/datalist&gt;&lt;/form&gt; select元素（包含在标签里），下面也是接option属性来提供选择项目 1234567&lt;form&gt; &lt;select&gt; &lt;option&gt;西瓜&lt;/option&gt; #只能预选项里选择 &lt;option&gt;苹果&lt;/option&gt; &lt;option&gt;香蕉&lt;/option&gt; &lt;/select&gt; &lt;/form&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符集和字符编码]]></title>
      <url>%2F2017%2F03%2F11%2F%E5%AD%97%E7%AC%A6%E9%9B%86%26%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[字符集和字符编码计算机中存储的信息都是用二进制数表示的（即0和1，逢二进一，这和计算机逻辑电路中的接通和断开两个物理状态对应），而我们在屏幕上看到的英文汉字是二进制数转换的结果。 字符集（Charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 字符编码（Character Encoding）：规定把字符集中的字符编码成计算机可以接受的存储对象，以便文本在计算机中存储和传递。 常用的字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等 字符集 字符编码 ASCII(american standard code for information interchange)美国信息交换标准代码 主要显示现代英语 7位（bits）表示一个字符，共2^7，128个字符 EASCII 追加扩展了一些欧洲常用字符 8位（bits）表示一个字符，共2^8，256个字符 GB2312 国标，用于汉字 小于127的字符意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。 在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GB18030 对gb2312追加扩展，支持国内少数名族文字 采用多字节编码，与utf-8相同 GBK 微软利用GB 2312未使用的编码空间，收录GB 13000.1-93全部字符制定了GBK编码 字符有一字节和双字节编码 BIG5 繁体字 Unicode 万国码 uft-32（每个字符都使用4个字节，造成存储浪费） / utf-16 / utf-8]]></content>
    </entry>

    
  
  
</search>
