<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS中字符串的方法小结]]></title>
      <url>%2F2017%2F07%2F29%2Fstring%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[concat() [类似于数组的concat()方法] 连接两个字符串，返回一个新字符串，不改变原来字符串 语法：str.concat(string2, string3[, …, stringN]) 返回值：新的字符串，（原字符串不变） 12&apos;&apos;.concat(1,2,&apos;3&apos;) //&apos;123&apos; 会先转换为字符串再连接1+2+&apos;3&apos; //&apos;33&apos; 数字+字符串 == 字符串 slice() [类似于数组的slice()方法] 提取一个字符串的一部分，并返回一个新的字符串 语法：str.slice(start[, end]) 参数start从index=0开始 , 到end前一个数为止 返回值：新的字符串 （原字符串不变） 12&apos;tom tom&apos;.slice(2,6)//&apos;m t&apos; substring() substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。 语法：str.substring(indexStart[, indexEnd]) 参数：一个 0 到字符串长度之间的整数 ，这两个参数会自动调整到 第一个参数比第二个参数小 ​ (原字符串不变) 12&apos;JavaScript&apos;.substring(9,4) === &apos;JavaScript&apos;.substring(4,9) /ture//&apos;Scrip&apos; 注：slice()可以接受负数，substring()不行。substring()会自动调整，而slice()会变成空字符串。 substr() substr()方法返回一个字符串中从指定位置开始到指定字符数的字符。 语法：str.substr(start[, length]) 第二个参数是长度，区分substring()的第二个参数是index ​ (原字符串不变) 12&apos;JavaScript&apos;.substr(4,5)//&apos;Scrip&apos; ####确定字符是否包含在字符串中 indexOf() &amp; lastIndexOf() [类似于数组的indexIOf()方法] 这两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回-1，就表示不匹配。 12&apos;Tom is a gay&apos;.indexOf(&apos;a&apos;)//7 string.includes(string,startIndex)：返回布尔值，表示是否找到了参数字符串。 12345&apos;tom is a gay&apos;.includes(&apos;d&apos;)//flase-----------第二个参数表示开始搜索的位置&apos;tom is a gay&apos;.includes(&apos;o&apos;,1) //ture&apos;tom is a gay&apos;.includes(&apos;o&apos;,2) //flase str.startsWidth(str,startIndex):返回布尔值，表示参数字符串是否在源字符串的头部。 1&apos;tom is a gay&apos;.startsWith(&apos;gay&apos;,9) //ture str.endsWidth(str,lastIndex):返回布尔值，表示参数字符串是否在源字符串的尾部。 1&apos;tom is a gay&apos;.endsWith(&apos;is&apos;,6) //true repeat()语法：str.repeat(num) repeat()方法返回一个新字符串，表示将原字符串重复n次。 12345如果是小数，会被取整&apos;tom&apos;.repeat(2.9) //&apos;tomtom&apos;如果是-1到0之间，视为0 ；NaN也视为0&apos;tom&apos;.repeat(-0.7) //&apos;&apos;&apos;tom&apos;.repeat(NaN) //&apos;&apos; 补全字符串，类似数组push()添加语法：str.padStart(targetLength [, padString]) / padEnd() 返回值：一个新的字符串（不改变原字符串） 1234&apos;x&apos;.padStart(3) //&apos; x&apos; 没有第二个参数默认用空格代替&apos;xx&apos;.padEnd(2,&apos;sdfsd&apos;) //&apos;xx&apos; 长度如果是原来字符串本身，那么返回原字符串&apos;xx&apos;.padStart(4,&apos;kkkkkkk&apos;) //&apos;kkxx&apos; 多余的会舍去&apos;xx&apos;.padEnd(5,&apos;sk&apos;) //&apos;xxsks&apos; 不够长度的话会重复、 trim(),trimRight(),trimLeft() trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (包括换行符\n、回车符\r、制表符\t、\v) 返回值：新字符串 （不改变原字符串） 参数：不接受参数 语法：str.trim() 12&apos; hello world \n&apos;.trim() // &apos;hello world&apos; chatAt()方法从一个字符串中返回指定的字符。 语法：str.charAt(index) ；超出index范围，就返回空字符串 12&apos;tom is a gay&apos;.chatAt(2) //&apos;m&apos;&apos;tom is a gay&apos;.chatAt(99) //&apos;&apos; toLowerCase() &amp; toUpperCase() toLowerCase()方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。 语法：str.toLowerCase() 返回值：新的字符串 （不改变原字符串） 12&apos;JavaScript&apos;.toUpperCase()&quot;JAVASCRIPT&quot; match() match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 语法：str.match(regexp); 返回值：满足匹配条件的数组 参数： 未使用参数，返回空字符串的数组[‘’] 1&apos;hello world&apos;.match() //[&quot;&quot;] 正则表达式不带有g标志，会返回 RegExp.exec() 相同的结果，返回的数组有index（匹配在原字符串中的索引）和input（原字符串）属性。而且返回的是第一个匹配到的元素的数组 参数带有g的正则表达式，返回全部匹配到的数组，而且没有index和input属性 12&apos;tom is a toy&apos;.match(/to./g)//[&apos;tom&apos;,&apos;toy&apos;] 遍历字符串：for…of123456for(let key of &apos;tom&apos;)&#123; console.log(key)&#125;//t//o//m]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[属性描述对象]]></title>
      <url>%2F2017%2F07%2F20%2F%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[概述属性描述对象，是用来描述一个对象的属性的行为，控制它的行为。 123456789描述对象实例&#123; value: 123, //存放属性值，默认undefined writable: false, //存放布尔值，默认true，表示属性值是否可变 enumerable: true, //存放布尔值，表示属性是否可枚举，默认为true，如果为false，for...in和Object.keys()会跳过改属性 configurable: false, //存放布尔值，表示可配置性，默认为true。控制描述对象的可写性（value属性可改变） get: undefined, //存放一个函数，表示该属性的取值函数（getter），默认undefined set: undefined //存放一个函数，表示该属性的存值函数（setter），默认undefined&#125; 12345678configurable属性为false，将无法删除该属性var o =Object.defineProperty(&#123;&#125;,&apos;p&apos;,&#123; value:123&#125;)delete o.p //false 无法删除，delete方法返回布尔值Object.defineProperty(o,&apos;p&apos;,&#123; value:243&#125;) //报错，不能重新定义p属性 Object.getOwnPropertyDescriptior读出对象自身属性的属性描述对象 1234读取o对象的name属性的属性描述对象var o =&#123;name:&apos;tom&apos;&#125;Object.getOwnPropertyDescriptor(o,&apos;name&apos;) //这里name是字符串//&#123;value: &quot;tom&quot;, writable: true, enumerable: true, configurable: true&#125; #####Object.defineProperty(),Object.defineProperties() 该方法允许通过定义属性描述对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下。这两个方法有性能损耗，不能大量使用。 1234567891011Object.defineProperty(object,propertyName,attributesObject)----------var o =Object.defineProperty(&#123;&#125;,&apos;p&apos;,&#123; value:123, writable:false, enumerable:false, configurable:false,&#125;)o.p //123o.p=345o.p=123 //因为writable为false，所以无法改变属性值 12345678910111213141516##设置了get或着set，就不能设置writable属性和value属性var o =Object.defineProperties(&#123;&#125;,&#123; //写法不同 p1:&#123;value:1,enmuerable:true&#125;, p2:&#123;value:2&#125;, p3:&#123;writable:true&#125;, p4:&#123; get:function()&#123;return this.p1+this.p2&#125;, configurable:true &#125;&#125;)o.p1 //1o.p2 //2o.p3 //3Object.getOwnPropertyDescriptor(o,&apos;p3&apos;)//&#123;value: undefined, writable: true, enumerable: false, configurable: false&#125;Object.defineProperty()方法它的writable、configurable、enumerable这三个属性的默认值都为false 可枚举性只有可枚举属性，才会被for…in循环遍历，同时还规定原生继承的属性都是不可枚举的。 可枚举性（enumerable）用来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。 123for...in 循环Object.keys() 方法JSON.stringify() 方法 12345678910111213141516#可以用enumerable:flase 来设置秘密属性var o =&#123;a:1,b:2&#125;Object.defineProperty(o,&apos;c&apos;,&#123; value:3, enumerable:false //默认就是false&#125;)o.c //3-------for(let x in o)&#123; console.log(o[x])&#125;//1 2-------Object.keys(o) //[&apos;a&apos;,&apos;b&apos;]------JSON.stringify(o) //&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot; 可配置性configurable当configurable为false时，value，writable，enumerable，configurable都不能修改了 writable从true改为false时是允许的，反过来就报错 12345var o = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; writable: true, configurable: false&#125;);Object.defineProperty(o,&apos;p&apos;, &#123;writable: false&#125;) 至于value，只要writable和configurable有一个为true，就允许改动。 1234567var o2 = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 1, writable: false, configurable: true&#125;);Object.defineProperty(o2,&apos;p&apos;, &#123;value: 2&#125;)o2.p //2 用var声明变量时，configurable默认为flase，说明用var声明的变量不能用delete删除，而var声明对象就默认为true，可以用delete删除（delete只能删除对象的属性） 1234567var a =2Object.getOwnPropertyDescriptor(this,&apos;a&apos;)//&#123;value: 2, writable: true, enumerable: true, configurable: false&#125;--------var o=&#123;a:1&#125;Object.getOwnPropertyDescriptor(o,&apos;a&apos;)//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125; Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回直接定义在某个对象上面的全部属性的名称，而不管该属性是否可枚举。 123456789101112var o =Object.defineProperties(&#123;&#125;,&#123; p1:&#123;value:1,enumerable:true&#125;, p2:&#123;value:2,enumerable:false&#125;&#125;)Object.getOwnPropertyNames(o)//[&quot;p1&quot;, &quot;p2&quot;]-------Object.keys(o)//[&apos;p1&apos;]------------Object.keys([]) // []Object.getOwnPropertyNames([]) // [ &apos;length&apos; ] //系统原生属性都是不可枚举的（即非用户自定义） Object.prototype.propertyIsEnumerable()来判断一个属性是否可枚举 123456var o=&#123;p:123&#125;o.propertyIsEnumerable(&apos;p&apos;)//ture-------o.propertyIsEnumerable(&apos;toString&apos;)//false 存取器存取器提供的是虚拟属性，即该属性的值不是实际存在的，而是每次读取时计算生成的。 注：取值函数getter不接受参数（对象也不能有与取值函数同名的属性），存值函数只接受一个参数（即属性的值）。 1234567891011#对p属性取值时，取值函数会自动调用；对p属性赋值时，存值函数会自动调用。var o =&#123; get p()&#123; return &apos;getter&apos; //取值函数一般都是return &#125;, set p(value)&#123; console.log(&apos;setter:&apos;+ value) &#125;&#125;o.p //getter 取值时调用o.p = 123 //setter:123 赋值时调用 12345678910#数据对象和DOM对象的双向绑定Object.defineProperty(user,&apos;name&apos;,&#123; get:function()&#123; return document.getElementById(&apos;foo&apos;).value &#125;, set:function(newValue)&#123; document.getElementById(&apos;foo&apos;).value=newValue &#125;, configurable:ture&#125;) 上面就是mvvm框架的ViewModel业务逻辑。MVVM是Model-View-ViewModel的简写，视图（用户界面）和模型（数据）的双向映射。（缺点，用户频繁改动，cpu消耗很大） Object.preventExtensions() &amp; Object.isExtensible()extension扩展，阻止扩展。使一个对象无法再添加新的属性(不能增加可删除) extensible 可扩展的。检查是否可以为一个对象添加属性 1234567891011121314151617var o =&#123;&#125;Object.preventExtensions(o)Object.defineProperty(o,&apos;p&apos;,&#123; value:2&#125;)//TypeError: Cannot define property p, object is not extensible-----Object.isExtensible(o) //false------o.p =1o.p //undefined-----------#可以用delete删除一个现有属性var o =&#123;p:1&#125;Object.preventExtensions(o)delete o.p //trueo.p //undefined Object.seal() &amp; Object.isSealedseal:密封 ，既不能添加也不能删除旧属性，（本质就是把configurable改为false，所以writable可以从true改为false，但是反过来不行） 属性对象的value是由writable决定的 123456var o =&#123;p:1&#125;Object.seal(o)o.p =2o.p //2------Object.isSealed(o) //true Object.freeze() &amp; Object.isFrozen()不能添加，不能删除，不能更改。相当于固定住一个对象，变成常量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON数据格式]]></title>
      <url>%2F2017%2F07%2F15%2FJson%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[#####基本格式要求 每个JSON对象，就是一个值，每个JSON文档职能包含一个值 复合类型的值只能是数组或着对象。不能是函数，正则对象或者日期对象 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined） 字符串必须使用双引号，不能使用单引号 对象的键名也必须带有双引号 数组或着对象的最后一个成员，不能加逗号。 #####JSON.stringify() JSON.stringify方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。 123456789JSON.stringify([1, &quot;false&quot;, false])// &apos;[1,&quot;false&quot;,false]&apos;--------JSON.stringify(&#123; name: &quot;张三&quot; &#125;)// &apos;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&apos;--------原始类型的字符串，转换结果会带有双引号，这是因为将来还原的时候，双引号可以让 JavaScript 引擎知道，foo是一个字符串，而不是一个变量名。JSON.stringify(&apos;foo&apos;) //&quot;&quot;foo&quot;&quot;JSON.stringify(&apos;foo&apos;)===&quot;\&quot;foo\&quot;&quot; JSON.stringify()还可以接受第二个参数（第二个参数是一个数组[]，否则无效）指定需要转成字符串的属性。（只对对象有效，对数组无效） 12345678910var obj = &#123; &apos;prop1&apos;: &apos;value1&apos;, &apos;prop2&apos;: &apos;value2&apos;, &apos;prop3&apos;: &apos;value3&apos;&#125;;var selectedProperties = [&apos;prop1&apos;, &apos;prop2&apos;];JSON.stringify(obj, selectedProperties) // &quot;&#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;&quot; 转换规则： 如果对象中含有不合规定的值，如undefined 或着函数对象等，会忽略 123456789101112var obj = &#123; a:1, b:2&#125;JSON.stringify(obj)&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot; //会自动在键名上添加括号---------var obj = &#123; a: undefined, b: function () &#123;&#125;&#125;JSON.stringify(obj) // &quot;&#123;&#125;&quot; 如果是数组中包含有不合规定的值，那么会转为null 12var arr = [undefined, function () &#123;&#125;]JSON.stringify(arr) // &quot;[null,null]&quot; JSON.stringify()会忽略对象的不可遍历属性 123456789101112131415var obj=&#123;&#125;Object.defineProperties(obj,&#123; &apos;foo&apos;:&#123; value:1, enumerable:true enumerable是可枚举属性的开关 &#125;, &apos;bar&apos;:&#123; value:2, enumerable:false &#125;&#125;)JSON.stringify(obj) //&#123;&quot;foo&quot;:1&#125;obj.propertyIsEnumerable(&apos;foo&apos;) //trueobj.propertyIsEnumerable(&apos;bar&apos;) //false###关于obj.propertyIsEnumerable(prop)返回一个布尔值，来检测这个属性是否可枚举 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每次都会忘记的正则！]]></title>
      <url>%2F2017%2F07%2F01%2F%E6%AD%A3%E5%88%99%2F</url>
      <content type="text"><![CDATA[正则表达式 Regular expressions：用来匹配字符串中字符组合的模式. 两种表达方式 字面量(在编译时新建正则表达式，即在代码在如是生成) 1var regex = /xyz/ 构造函数，可以接受第二个参数，表示修饰符 (在运行时新建正则表达式，即在代码运行时生成) 12var regex = new RegExp(&apos;xyz&apos;，&apos;i&apos;)=== var regex = /xyz/i 两种语法 正则对象的方法：regex.test(string) 返回布尔值/ regex.exec(string)返回数组 字符串对象的方法：string.match(regex) 正则对象属性和方法属性： 3个只读属性，都返回布尔值ignoreCase \ global （全局模式，和lastIndex挂钩）\ mulitline 1234567var r = /&apos;abc&apos;/igmr.ignoreCase //true 表示是否设置了该属性r.global //truer.multiline //true--------r.source //&quot;abc&quot;r.lastIndex //0 source：只读属性，返回正则表达式的字符串形式（不包括反斜杠） lastIndex: （在设置g的前提下）可读写属性，返回下一次开始搜索的位置 方法： 12345可以指定搜索位置var regex = /x/gvar str = &apos;yxyx&apos;regex.lastIndex = 4regex.test(str) //false test()：返回布尔值，用来查看正则表达式与指定的字符串是否匹配regexObj.test(str) 1234var str = &apos;hello world&apos;var regex = /^h.+o/let result = regex.test(str) console.log(result) //true exec()：返回一个结果数组或者null (与match()方法类似），regexObj.exec(&#39;string&#39;) 返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。(第一项只返回第一个匹配的字符串) 当正则表达式使用 “g“ 标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的 lastIndex属性指定的位置开始(lastIndex属性是在regex正则表达式上的）。（test() 也会更新 lastIndex 属性） match()：返回一个array（数组），包含了整个匹配结果以及任何括号捕获的匹配结果 ；如果没有匹配项，则返回null。str.match(regexObject) 有g修饰：返回一个Array ，它包含所有匹配的子字符串。捕获组不会被返回(即不返回index属性和input属性)。如果没有匹配到，则返回 null 。 无g修饰：返回的 Array拥有一个额外的 input 属性，该属性包含被解析的原始字符串。另外，还拥有一个 index 属性，该属性表示匹配结果在原字符串中的索引（以0开始）。 1234567891011121314151617var str = &apos;For more information, see Chapter 3.4.5.1&apos;;var re = /see (chapter \d+(\.\d)*)/i;var found = str.match(re);console.log(found);// logs [ &apos;see Chapter 3.4.5.1&apos;,// &apos;Chapter 3.4.5.1&apos;,// &apos;.1&apos;,// index: 22,// input: &apos;For more information, see Chapter 3.4.5.1&apos; ]// &apos;see Chapter 3.4.5.1&apos; 是整个匹配。// &apos;Chapter 3.4.5.1&apos; 被&apos;(chapter \d+(\.\d)*)&apos;捕获。// &apos;.1&apos; 是被&apos;(\.\d)&apos;捕获的最后一个值。// &apos;index&apos; 属性(22) 是整个匹配从零开始的索引。// &apos;input&apos; 属性是被解析的原始字符串。 字符串对象方法（match(),search(),replace(),split()） , String.indexOf(2) 字符串里是否包含2 string.match(regex) ，类似regex.exec(srting)，返回数组；没有匹配到返回null。 如果设置g修饰，那么返回所有匹配结果所组成的数组。对macth()设置lastIndex无效，对exec()方法设置有效 string.search(regex): 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。 该方法忽略g修饰。 12&apos;yxyx&apos;.search(/x/)//1 string.replace(regex) //一般用于敏感词过滤 字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。 语法：string.replace(regex|string , newString|function) 返回值：替换后的新的字符串（不改变原字符串） 注：不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。 123&apos;aaa&apos;.replace(&apos;a&apos;,&apos;b&apos;) //&apos;baa&apos;&apos;aaa&apos;.replace(/a/,&apos;b&apos;) //&apos;baa&apos;&apos;aaa&apos;.replace(/a/g,&apos;b&apos;) //&apos;bbb&apos; 第二个参数可以是函数，其返回值为替换的字符串，这个函数接受4个参数 匹配的字符串 p1,p2…正则表达式括号里的匹配内容（捕获） 匹配到的字符串的起始位置index 原来的字符串 string.split(regex) split()方法将一个字符串分割成 字符串数组 语法：str.split([separator[, limit]]) 参数：第一个表示分割规则，第二个是返回的成员最大数 1234&apos;a,b,c,d&apos;.split(&apos;,&apos;,2)//[&apos;a&apos;,&apos;b&apos;]&apos;a,b,c,d&apos;.split()//[&apos;a,b,c,d&apos;] 正则匹配规则#####字面量字符和元字符 字面量字符：如/a/匹配a，/b/匹配b 1/dog/.test(&apos;dog and cat&apos;) //true 元字符： . ：匹配除换行符以外的任意字符 位置字符： ^ 表示字符串的开始位置，只能放在开始第一个位置 $ 表示字符串的结束位置，只能放在最后一个位置 1/^dog$/.test(&apos;dogdog&apos;) //false 选择符：| 表示或的意思 1/11|22/.test(&apos;91122&apos;) //ture 12个转义符：\. ,\^ ,\$ , \| , + , * , \? , \( , \) ,{ , [ , \\（查找\本身） 用RegExp方法生成的正则对象要用两个\\来转义 特殊字符：\n 换行键 ， \r 回车键 ， \0 匹配null字符 字符类：[] 在方括号中的表示只要匹配其中一个就可以了 1/[abc]/.test(&apos;fuck&apos;) //true 脱字符^ ：必须写在方括号第一个位置才有用，表示出了字符类中的字符的其他字符 1/[^abc]/.test(&apos;fuck&apos;) //false 套路：[^] 表示匹配一切字符，区别于包含换行符的. 连字符- ：表示连续范围 1234[a-z] [A-Z] [0-9] [1-31]这个表示 1到3，而非表示1到31-----------不要出现[A-z],其中会出现其他字符比如\\ 注：字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，[-9]就表示匹配连字符和9，而不是匹配0到9。 预定义模式： | 简写 | 原型 | 介绍 || :–: | :———–: | :——————- || \d | [0-9] | 匹配0-9之间的任一数字 || \D | [^0-9] | || \w | [A-Za-z0-9] | 匹配任意的字母、数字和下划线 || \W | [^A-Za-z0-9] | || \s | [\t\r\n\v\f] | 匹配空格（包括制表符、空格符、断行符等） || \S | [^\t\r\n\v\f] | || \b | | 匹配词的边界。 || \B | | | 重复：{} : {n} 表示重复n次 ​ {n,} 表示重复&gt;=n次 ​ {n,m} 表示重复&gt;=n次且&lt;=m次 量词符：? 问号表示某个模式出现0次或1次，等同于{0, 1}。 ​ * 星号表示某个模式出现0次或多次，等同于{0,}。 ​ + 加号表示某个模式出现1次或多次，等同于{1,}。 非贪婪模式：一旦条件满足，就不再往下匹配。 *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。 +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。 ?? , {n,m}? , {n,}? 123/tom+/.exec(&apos;tommm&apos;) //[tommm]/tom+?/.exec(&apos;tommm&apos;) //[tom]/tom*?/.exec(&apos;tommm&apos;) //[to] ​ 修饰符：g（全局），i（忽略大小写），m（修改^和$de行为，可以识别换行符） 1234/world$/.test(&apos;hello world\n&apos;) // false/world$/m.test(&apos;hello world\nasdsf&apos;) // true/^b/m.test(&apos;a\nb&apos;) // true 匹配组：()捕获 123/tom+/.exec(&apos;tommm&apos;) //[&apos;tommm&apos;]/(tom)+/.exec(&apos;tommm&apos;) //[&apos;tom&apos;,&apos;tom&apos;]/(tom)+/.exec(&apos;tomtom&apos;) //[&apos;tomtom&apos;,&apos;tom&apos;] 这里表示tom这个词出现1次或多次 在正则表达式内部，可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。 12345/(.)b(.)\1\2/.exec(&apos;abcac&apos;)//[&apos;abcac&apos;,&apos;a&apos;,&apos;c&apos;]----------------/y(..)(.)\2\1/.exec(&apos;yabccab&apos;) //[&quot;yabccab&quot;, &quot;ab&quot;, &quot;c&quot;] 非捕获组：(?:x)，表示不返回改组匹配的内容，即匹配的结果中不计入这个括号。 12var m = &apos;abc&apos;.match(/(?:.)b(.)/);m // [&quot;abc&quot;, &quot;c&quot;] 先行断言（括号里的内容不返回）：x(?=y)称为先行断言，x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。先行断言中，括号里的部分是不返回的。 12var m = &apos;abc&apos;.match(/b(?=c)/);m // [&quot;b&quot;] 现行否定断言：x(?!y)``x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。 12/\d+(?!\.)/.exec(3.14)//14 补充 str.substring(start , end) 截取字符串 、 str.substr(start,length) 与str.search() 相对的是 str.charAt(index) :根据索引返回字符串中对应的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面局部刷新的里程碑：AJAX]]></title>
      <url>%2F2017%2F06%2F25%2FAJAX%2F</url>
      <content type="text"><![CDATA[AJAXAsync JavaScript And XML：异步的JS+XML 请求回顾12345678请求行：GET ／ index.html HTTP/1.1请求头：Host:1.2.3.4 Accept: html, xhtml, xml User-Agent: Chrome / Mac 回车消息体：username=xxxx&amp;password=yyyyy&amp;c=zzzzz---------常用的请求方法：POST\DELETE\PUT、PATCH\GET\HEAD\TRACK\CONNCET\OPTIONS 发请求的方法 地址栏回车 发起特定类型的请求： 图片发起请求：&lt;img src=/xxx&gt; 请求头里：Accept: image/webp,image/,/* 期待接收图片 js发请求：&lt;script src=/xxx 请求头里：Accept:test/javascript, */* css发请求：&lt;link rel=stylesheet href=/xxx&gt; 请求头里：Accept:test/css,*/* form表单发起请求：&lt;form action=&#39;/xxx&#39; method=GET (Accept:*/*) 缺点：1、3请求方法会刷新页面并替换当前页面内容，2请求方法只能请求特定类型资源 局部更新要求：发一个请求，这个请求去更新页面里的局部内容，而不刷新整个页面。 js改变地址栏（更新了整个页面，不符合要求） 123456789前端：&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div&gt;空的&lt;/div&gt;&lt;script&gt; button.onclick=function()&#123; location.href = &apos;/xxx&apos; &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233服务器端：var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;)//console.log(Object.keys(http))var port = process.env.PORT || 8888;var server = http.createServer(function(request, response)&#123; var temp = url.parse(request.url, true) var path = temp.pathname var query = temp.query var method = request.method //从这里开始看，上面不要看 if(path === &apos;/&apos;)&#123; // 如果用户请求的是 / 路径 var string = fs.readFileSync(&apos;./index.html&apos;) response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) response.end(string) &#125;else&#123; response.statusCode = 404 response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) response.end(&apos;找不到对应的路径，你需要自行修改 index.js&apos;) &#125; // 代码结束，下面不要看 console.log(method + &apos; &apos; + request.url)&#125;)server.listen(port)console.log(&apos;监听 &apos; + port + &apos; 成功，请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port) ​ 发一个图片请求(可以局部发请求，但是无法获取响应的数据内容，不符合要求) 12345678910前端：&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div&gt;空的&lt;/div&gt;&lt;script&gt; button.onclick=function()&#123; var img = new Image() img.src = &apos;/xxx&apos; &#125;&lt;/script&gt; 1234567服务器端：...... if(path === &apos;/xxx&apos;)&#123; response.end(&apos;这是xxx的内容&apos;) &#125;else&#123; response.end(&apos;404&apos;) &#125; CSS发请求（同样的，无法拿到响应中的内容） 123456789101112131415161718前端：&lt;body&gt;&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div&gt;空的&lt;/div&gt;&lt;script&gt; button.onclick=function()&#123; var link = document.createElement(&apos;link&apos;) link.rel=&apos;stylesheet&apos; link.href=&apos;/xxx&apos; link.onload = ()=&gt;&#123; console.log(&apos;link.innerHTML&apos;) console.log(link.innerHTML) //无法打印出里面的响应内容 &#125; document.head.appendChild(link) &#125;&lt;/script&gt;&lt;/body&gt; JS发请求 1234567891011&lt;body&gt;&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div id=&quot;output&quot;&gt;空的&lt;/div&gt;&lt;script&gt; button.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.src = &apos;/xxx&apos; document.head.appendChild(script) &#125;&lt;/script&gt; 报错：js请求的路径是’/xxx’,那么路径对应的内容因该是合法的js字符串；而我们返回的是’here is xxx’字符串，所以报错。（但是浏览器把它当成js解析了，这是转机） 修改路径内容，使之能被js那样被解析 1234if(path === &apos;/xxx&apos;)&#123; response.setHeader(&apos;Content-Type&apos;,&apos;text/plain;charset=utf-8&apos;) response.end(&apos;output.innerText=&quot;here is xxx&quot;&apos;) //或者一个随机数response.end(`output.innerText=$&#123;Math.random()&#125;`) 1234567891011前端：&lt;script&gt; window.callback = function()&#123; console.log(arguments[0]) //打出第一个参数 &#125; button.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.src = &apos;/xxx&apos; document.head.appendChild(script) &#125;&lt;/script&gt; 12345服务器端：if(path === &apos;/xxx&apos;)&#123; response.setHeader(&apos;Content-Type&apos;,&apos;text/plain;charset=utf-8&apos;) var user = &apos;name:tom,age:18&apos; response.end(`window.callback.call(null,&quot;$&#123;user&#125;&quot;)`) 变换 1234567891011121314151617181920212223242526前端：&lt;body&gt;&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div id=&quot;output&quot;&gt;空的&lt;/div&gt;&lt;script&gt; window.callback = function(data)&#123; var array = data.split(&apos;,&apos;) //[&quot;name: tom &quot;,&quot; age: 18&quot;&quot;] //字符串转成数组 for(var i=0;i&lt;array.length;i++)&#123; //遍历数组 var parts = array[i].split(&quot;:&quot;) //[&quot;name&quot;,&quot; tom &quot;] var dl = document.createElement(&quot;dl&quot;) var dt = document.createElement(&apos;dt&apos;) dt.textContent = parts[0] var dd = document.createElement(&apos;dd&apos;) dd.textContent = parts[1] dl.appendChild(dt) dt.appendChild(dd) output.appendChild(dl) &#125; &#125; button.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.src = &apos;/xxx&apos; document.head.appendChild(script) &#125;&lt;/script&gt; 12345服务器端：else if(path === &apos;/xxx&apos;)&#123; response.setHeader(&apos;Content-Type&apos;,&apos;text/plain;charset=utf-8&apos;) var user = &apos;name: tom , age: 18&apos; response.end(`window.callback(&quot;$&#123;user&#125;&quot;)`) 总结： 发起请求：创造一个script放入页面，script请求一个路径 服务器响应：回调一个函数，这个函数对参数（数据）进行处理分解，构造成有结构的html页面 检测请求是否正确 前端：onerror和onload 123456789//前端出错：可以用onerror来提示：status只要不是2xx就触发onerror button.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.onerror = ()=&gt;&#123; alert(&apos;不好意思，出错了&apos;) &#125; script.src = &apos;/xxxx&apos; //请求路径出错 document.head.appendChild(script) &#125; 123456789后端出错：可以用onload来提示前端请求没问题；只要status是2xx，就触发onloadbutton.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.onload = ()=&gt;&#123; alert(&apos;请求没问题，后端出错了&apos;) &#125; script.src = &apos;/xxxx&apos; //请求路径出错 document.head.appendChild(script) &#125; 局限性：不知道具体哪里错误，不知道错误码。 XHMHttpRequest XMLHttpRequest 是一个API, 它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。 在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据 在页面已加载后从服务器接收数据 在后台向服务器发送数据 前身：微软的ActiveX对象，提供给ie的接口（帮你发请求，并且把请求的响应用字符串的形式响应 给你） 火狐跟进：XMLHttpRequest ，用这个对象发请求，并得到响应，并且不会对整个页面刷新。 实例化：var request = new XMLHttpRequest() 方法： abort()：如果请求已经被发送，则立刻终止请求 getAllResponseHeaders()：返回所有响应头信息(响应头名和值) getResponseHeader()：返回指定的响应头的值 请求： 请求行 - open(method,ulr,async)：request.open(&#39;GET&#39; , &#39;/xxx?wd=s&#39;,true)（查询字符串写在url里） 请求头 - setRequestHeader(header,value)：setRequestHeader(&#39;tom&#39;,&#39;18&#39;) 消息体 - send()：发送请求send(&#39;44444&#39;) 12345678&lt;script&gt; button.onclick = ()=&gt;&#123; var request = new XMLHttpRequest() request.open(&apos;POST&apos;,&apos;/xxx?aa=b&apos;) request.setRequestHeader(&apos;tom&apos;,&apos;18&apos;) request.send(&apos;sfsdf&apos;) &#125;&lt;/script&gt; 响应： 获取响应头：request.getAllResponseHeaders() 1234567891011121314&lt;script&gt; button.onclick = ()=&gt;&#123; var request = new XMLHttpRequest() request.open(&apos;POST&apos;,&apos;/xx x?aa=b&apos;) request.setRequestHeader(&apos;tom&apos;,&apos;18&apos;) request.send(&apos;sfsdf&apos;) request.onload = ()=&gt;&#123; console.log(request.getAllResponseHeaders()) &#125; request.onerror = ()=&gt;&#123; console.log(request.getAllResponseHeaders()) &#125; &#125;&lt;/script&gt; 获取响应消息体（第四部分）：request.responseText ／ window.eval(request.responseText) 12345678910111213&lt;script&gt; button.onclick = ()=&gt;&#123; var request = new XMLHttpRequest() request.open(&apos;POST&apos;,&apos;/xxx?aa=b&apos;) request.setRequestHeader(&apos;tom&apos;,&apos;18&apos;) request.send(&apos;sfsdf&apos;) request.onload = ()=&gt;&#123; console.log(request.responseText) //打印出来文本 window.eval(request.responseText) //eval可以执行字符串，即执行了响应的第四部分 &#125; &#125;&lt;/script&gt; 获取响应第一部分：状态行 12状态码 request.status //200状态码描述 request.statusText //OK 精确检查响应的状态：onreadystatechange ，只要readyState变化，这个函数就会被调用 123456789101112request.onreadystatechange = function()&#123; console.log(request.readyState) //01234个值 if(request.readyStatus === 4)&#123; //响应下载完毕 if(request.status &gt;=200 &amp;&amp; request.status &lt;300)&#123; console.log(&apos;成功&apos;) &#125;else&#123; console.log(&apos;失败&apos;) &#125; &#125;&#125;//request.onload //响应下载完毕，而且status是2XX//request.onerror //1.响应出错（未发出、 网络等），2.下载完毕但是status是4xx 5xxx ​ 小结ajax总共有4个过程 , 创建ajax对象：const ajax = new XMLHttpRequest() 连接到服务器： ajax.open(method,url,async) 发送请求： ajax.send() 接收返回的信息： 12345678ajax.onreadystatechange=function()&#123; ajax.readyState //0 未初始化，还没调用open方法 //1 载入，已经调用send()方法，正在发送请求 //2 载入完成，send()方法完成，已经收到全部相应内容 //3 解析，正在解析响应内容 //4(普遍是4) 完成，响应内容完成解析（可能成功，可能失败，用ajax.status来判断。成功时候可以用ajax.responseText来获取响应的内容&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css小结]]></title>
      <url>%2F2017%2F06%2F18%2Fcss%E6%80%BB%E7%BB%93%E7%AF%87%2F</url>
      <content type="text"><![CDATA[字体，文本基础 font-size，font-family，font-weight（regular或者bold加粗），line-height text-align：文本对齐方向 left，right，center text-indent：文本第一行缩进距离 text-decoration：文本下划线none，overline，line-through，underline text-transform：改变大小写none，uppercase，lowercase，capitalize（首字母大写） direction：文本方向 ltr，rtl word-spacing：单词间隔 letter-spacing：字母间隔 white-space： normal（多个空格变为一个，换行变空格） pre（正常） nowrap（在normal的基础上阻止换行） pre-wrap：保留空格，会自动换行 pre-line：合并空白符，保留换行符 文本 text-overflow： clip(修剪)，隐藏超出文本 12overflow:hiddentext-oveflow:clip ellipsis(省略)，需要其他属性配合 123overflow:hiddentext-overflow:ellipsiswhite-space:nowrap word-wrap：允许长单词换行 normal：只在允许的断字点换行，单词过长不会换行会超出文本 break-word：在长单词或 URL 地址内部进行换行。 word-break： normal：浏览器默认规则换行 break-all：允许拆单词换行 keep-all：只能在半角空格或者连字符换行 背景background background-attachment：背景图像是否跟着滚动scroll，fixed background-color background-image：url(‘URL’) background-position：x y（中间没有逗号），top/center/bottom left/center/right background-repeat：no-repeat， repeat-x， repeat-y ， repeat 简写：background: #fff url(test.jpg) no-repeat fixed 0 0 background-size：background-size: length|percentage|cover|contain background-origin：如果background-attachment为fixed则无效 ​ padding-box（相对padding边） ​ border-box（相对border边） ​ content-box（相对于内容框） background-clip：规定背景的绘制区域：padding-box ; border-box ; content-box 边框border简写：border：1px solid（dashed虚线）red； 用border画三角形 12345678p&#123; height:0; width:0; border-top:30px solid rgba(0,0,0,0); border-left:30px solid rgba(0,0,0,0); border-right:30px solid rgba(0,0,0,0); border-bottom:30px solid blue;&#125; padding和margin margin可以是负数 外边距合并，当两个垂直外边距相遇时，会重叠形成一个外边距（以较大的为准） 盒模型box-sizing box-sizing: content-box , 标准盒模型，宽高只包含content的宽高 box-sizing: border-box , ie盒模型，宽高包括了content，padding和border CSS选择器 组合选择 E,F: 多元素选择器 E F: 后代选择器 E&gt;F: 直接子元素选择器 E+F: 直接相邻选择器 E~F: 普通相邻选择器（无论直接相邻与否） 属性选择 E[attr] :匹配所有具有attr属性的元素 ，div[id] ,取到所有具有id属性的div E[attr=value] : 匹配属性值为value的元素，div[id=”haha”] E[attr=value]: 匹配包含value值的元素，` div[class =aaa]可以选到` 伪类选择器 E:first-child: 匹配元素E的第一个子元素 / E:last-child E:link：所有未被电击的链接 E:visited: 已被点击的链接 E:hover: 鼠标悬停 （必须在前两个之前） E:active: 鼠标点击未释放 （必须在hover之前) E:nth-child(n) :匹配第n个子元素，n从1开始(也可取odd，even，2n+1) / E:nth-last-child(n) E:not(selector) 伪元素选择器 E::fefore E::after ：在E元素之后插入生成的内容 定位 static: 正常文档流 relative: 相对于元素本身进行定位，移动的距离会占据文档流空间。 absolute: 绝对定位，脱离文档流 ，相对于static定位以外的第一个祖先元素进行定位。 fixed: 相对于浏览器窗口进行定位 粘性定位sticky: 必须指定top，bottom，left，right中的其中一个值，如top:30px，这个值表示当元素距离页面视口顶部距离大于 30px 时，元素以 relative 定位表现，而当元素距离页面视口小于 30px 时，元素表现为 fixed 定位，会固定在目标位。 可以用于导航栏固定 浮动清楚浮动，在父元素后添加一个伪元素 12345.parent:after&#123; content:&quot;&quot;; display:block; clear:both&#125; 负边距margin当 margin-top 、 margin-left 为负值的时候，会把元素上移、左移，同时⽂档流中的位置也发生相应变化,这点与 position:relative 的元素设置top、left后元素还占据原来位置不同。 垂直居中:利用绝对定位元素的复边距实现 12345position:absolute;top:50%;left:50%;margin-top:-？px; //根据实际元素计算出其自身高度和长度一半的负间距margin-left:-？px; 负边距对float元素：可以覆盖往负边距方向移动 多列布局：固定右边列、 display display: inline（行内元素） ， block（块元素） ， inline-block（表现和行内元素一致，但是支持宽高设定） display:none: 把元素从文档中删除，不会渲染 visibility:hidden: 隐藏，还在文档中，而且占据文档流 text-shadowtext-shadow: x轴 y轴 模糊半径 颜色 text-shdow: 2px 2px 3px #333; box-shadowbox-shadow:inset(内阴影) x-offset y-offset blur-radius(阴影模糊半径) spread-radius(阴影扩展半径) color 渐变 线性渐变：linear-gradient(direction, color-stop1, color-stop2, ...) direction：to top \ to right \ to bottom \ to left 1background:linear-gradient(to top,#ddd,red) //用逗号分隔！ 径向渐变：background: radial-gradient(shape size at position, start-color, ..., last-color); shape：ellipse（默认），椭圆径向渐变 / circle：圆形 at position：at center / at top / at bottom / at 10px 20px / at x% y% 1background:radial-gradient(circle at top,red,yellow) //注意逗号位置 过渡和动画 transition: property duration timing-function delay; property：属性，height，width等 duration：需要多少时间完成 timing-function：linear（匀速），ease-in（加速），ease-out（减速），cubic-bezier(n,n,n,n) delay：多少秒后开始 1transition: width 1s ease-out 2s animation: name duration timing-function delay iteration-count direction fill-mode play-state; iteration-count：播放次数 direction ：reverse（倒放） direction fill-mode：forwards（停在最后的状态） / backwords 123456789div:hover&#123; animation: rainbow 1s&#125;@keyframes rainbow&#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 另外一点需要注意的是，浏览器从一个状态向另一个状态过渡，是平滑过渡。steps函数可以实现分步过渡（一卡一卡的感觉） 123div:hover &#123;animation: 1s rainbow infinite steps(10);&#125; 变形transform-origin：定位变形的点 transform： translate：translateX(x) / translateY(y) 水平移动 rotate：rotateX(deg) / rotateY(deg)/ rotateZ(deg) 沿X,Y,Z轴旋转 perspective:number：透视，一般和旋转配合使用，数字越小，透视效果越明显 skew：skew(deg , deg) / skewX(deg) /skewY(deg) scale：scale(x,y) / scaleX(x) / scaleY(y) 缩放]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>%2F2017%2F06%2F13%2F%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[模块化 各种全局变量 12345678var $topbar = $(&apos;#topbar&apos;)$topbar.on(&apos;click&apos;,functuion()&#123; console.log(&apos;topbar&apos;)&#125;)var $banners = $(&apos;#banners&apos;)$banners.on(&apos;click&apos;,function()&#123; console.log(&apos;banners&apos;)&#125;) 用立即执行函数消除全局变量（或者用{}块级作用域+let） 12345678910111213141516171819!function()&#123; var $topbar = $(&apos;#topbar&apos;) $topbar.on(&apos;click&apos;,functuion()&#123; console.log(&apos;topbar&apos;) &#125;)&#125;() //让这些变量变成局部变量，放进一个函数里并且调用，但是函数前要加上一个符号（+,-,!等）!function()&#123; var $banners = $(&apos;#banners&apos;) $banners.on(&apos;click&apos;,functuion()&#123; console.log(&apos;banners&apos;) &#125;)&#125;()------------------&#123; let $topbar = $(&apos;#topbar&apos;) $topbar.on(&apos;click&apos;,functuion()&#123; console.log(&apos;topbar&apos;) &#125;)&#125; //或者用es6语法:块级作用域，局部变量 按照上述方法，作用域与作用域之间是隔开的，如果作用域B想使用作用域A的变量，怎么办？可以使用两个作用域都能访问到的全局变量window，作为桥梁，赋值给window属性并访问 123456789101112!function()&#123; var $topbar = $(&apos;#topbar&apos;) var user = &#123; name:&apos;yom&apos;, age:20 &#125; window.user = user //全局变量&#125;() !function()&#123; console.log(window.user)&#125;() 如果不能让别的作用域改user，只能读（暴露一个函数，不要暴露整个变量） 123456789101112131415!function()&#123; var $topbar = $(&apos;#topbar&apos;) var user = &#123; name:&apos;yom&apos;, age:20 &#125; window.user = &#123; nameGetter:function()&#123;return user.name&#125;, ageGetter:fucntion()&#123;return user.age&#125; &#125;&#125;() !function()&#123; console.log(window.user.nameGetter) //yom&#125;() 什么时候闭包：只要一个函数使用了它外面的变量，这个函数就是闭包，闭包是指这个函数以及它能访问到的这个变量。闭包是作用域的一种特殊的使用方式。 举例：年龄增长器 1234567891011function olderMaker()&#123; var user = &#123; name:&apos;jack&apos;, age:18 &#125; return function()&#123; user.age += 1 &#125;&#125;var older = olderMaker() //函数older.call() 每call一下，年龄增加一岁 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工厂模式&new]]></title>
      <url>%2F2017%2F06%2F05%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-new%2F</url>
      <content type="text"><![CDATA[工厂模式用函数构造一个对象，并且返回这个对象，叫做工厂模式（可以批量生产）。 工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型) 123456789function Dog(name,age)&#123; var dogs=&#123;&#125; dogs.name=name dogs.age=age dogs.leg=4 dogs.type=&apos;短腿&apos; return dogs&#125;Dog(&apos;tom&apos;,6) // Object &#123;name: &quot;tom&quot;, age: 6, leg: 4, type: &quot;短腿&quot;&#125; 构造函数模式（即new）12345678910111213141516171819202122function Dog(name,age)&#123; var dogs=&#123;&#125; ----1.new帮忙创建临时对象 dogs.name=name dogs.age=age dogs.__proto__=Rdogs -----2.new帮忙绑定原型，并同意叫做prototype return dogs -----3.帮忙return&#125;Rdogs=&#123; leg:4, type:&apos;短腿&apos;&#125;Dog(&apos;tom&apos;,18) -----------------------------使用new,把共有的特性放在原型链上，私有的属性放在构造函数上function Dog(name,age)&#123; -----构造函数一般函数名首字母大写 this.name=name ------构造函数依赖 new、this this.age=age -----构造函数什么都不返回，只有new才能帮它return对象&#125;Dog.prototype=&#123; leg:4, type:&apos;短腿&apos;&#125;new Dog(&apos;tom&apos;,18) debugger一下，可以看到this已经有共有属性了，这是因为下面定义对象的时候内存里马上就赋值了，上面的是函数，等着调用才会去执行。 new会帮你return，但是如果自己写上return的话，会怎么样？（new会帮你return this，在new之前的构造函数里加了自己的return，那么new执行不到，所以构造函数不要瞎return） 如果构造函数里自己写了return this，而调用的时候不写new，会出现什么呢？（直接调用一个函数，this就是window） 生成对象并且改变this（帮你生成一个对象，this指向这个对象） 如果我不想加 new，但是又想实现跟 new 一样的功能（加条件判断，帮忙加new） jQuery是一个构造函数，返回一个对象，返回的对象有原型，所以它有new，做了以上类似的处理，所以我们调用的时候不需要些new new会帮忙添加constructor属性 如果像上面那样写Dog.prototype={}，这样就引向了另外一块地址，把原来的constructor属性覆盖了，所以推荐把constructor属性加上去constructor:Dog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS动画基础]]></title>
      <url>%2F2017%2F05%2F28%2FCSS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[transformtransform指变换，使用过photoshop的人应该知道里面的Ctrl+T自由变换。transform就是指的这个东西，拉伸，压缩，旋转，偏移，且transform 属性 , 只对 block 级元素生效！（配合transition过渡） 平移： 123transform: translate(tx[, ty]) translateX(tx) x轴方向平移 translateY(ty) 角度旋转：transform: rotate(angle) 缩放： 123transform: scale(sx[, sy]) scaleX(sx); x轴方向缩放 scaleY(sy) 倾斜： 123transform: skew(ax[, ay]) skewX(angle) skewY(angle) 旋转中心：transform-origin:x-axis y-axis z-axis (值：left，right，center，length，%) transition transition提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。(即平滑地改变css的属性值) 语法： transition：property name | duration //过渡时间 ​ transition： property name | duration | delay //过渡时间、延长时间 ​ transition：property name | duration | timing function | delay //过渡时间、效果、延长时间 ​ transition: margin-left 4s, color 1s //两个属性用逗号隔开 ​ transition: all 0.5s ease-out //all transition-property :指定过渡的性质，比如transition-property:backgrond 就是指backgound参与这个过渡 transition-duration:指定这个过渡的持续时间 transition-timing-function:指定过渡类型，有ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier（贝塞尔曲线） transition-delay:延迟过渡时间 123456transition-timing-function: linear 匀速 ease 慢-快-慢 ease-in 先慢后快 ease-out 先快后慢 ease-in-out 先慢后快再慢 cubic-bezier(n,n,n,n); 自定义（http://cubic-bezier.com/） perspective perspective 属性指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。 默认情况下，透视消失点位于元素的中心，但是可以通过设置perspective-origin属性来改变其位置。在父容器上设置perspective（相当于远处的舞台），会让元素指向透视的消失点。 1perspective-origin: x-axis y-axis (值：left，right，center，length，%) 注：perspective在Z轴上，而perspective是设置Z轴的长度。在css3中只有设置了perspective的值元素才会有Z轴，perspective为none元素则没有Z轴(就是2D元素)。 animation &amp; keyframes 创建动画序列，需要使用animation属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 @keyframes规则实现。 语法：animation: name duration timing-function delay iteration-count direction; animation-name: 规定需要绑定到选择器的 keyframe 名称。 animation-duration: 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function: ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier（贝塞尔曲线） animation-delay:设置延时，规定在动画开始之前的延迟。 animation-iteration-count: infinite|小数定义循环（0.5将播放动画到一半）设置动画重复次数， 可以指定infinite无限次重复动画. animation-direction: normal|alternate（交替反向运动）|reverse|alternate-reverse 设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行。 animation-play-state: running|paused 暂停和恢复动画 一旦完成动画的时间设置， 接下来就需要定义动画的表现。通过使用@keyframes建立两个或两个以上关键帧来实现。每一个关键帧都描述了动画元素在给定的时间点上应该如何渲染。 要使用关键帧, 先创建一个带名称的@keyframes规则，以便后续使用 animation-name这个属性来调用指定的@keyframes 关键帧使用百分比来指定动画发生的时间点。0%表示动画的第一时刻，100%表示动画的最终时刻。因为这两个时间点十分重要，所以还有特殊的别名：from和to。 @keyframes 不存在层叠样式(cascade)的情况，如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 小结：animation定义动画的时间，keyframes定义动画的效果。 举例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中的this值]]></title>
      <url>%2F2017%2F05%2F21%2FJS%E4%B8%AD%E7%9A%84this%E5%80%BC%2F</url>
      <content type="text"><![CDATA[什么是Thisthis总是返回一个对象，即返回属性或者方法“当前”所在的对象。在JavaScript语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是这个对象（环境）。也可以近似地认为，this是所有函数运行时的一个隐藏参数，指向函数的运行环境。 如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。 123function fn()&#123; console.log(this) //window&#125; 函数的call任何函数都可以用function.prototype.call()的形式来调用，其中call的第一个参数会变为函数里的this，call的其他参数组成函数里面的arguments。 123456789101112function f()&#123; console.log(this) console.log(arguments)&#125;var a =&#123;name:&apos;tom&apos;&#125;f.call(a,1,2,3) *call第一个参数会当作this，后面的会当做arguments*每次进入函数之前，都会创造this和arguments这两件事情---------------f()等价于f.call（）object.f(1,2,3)等价于 obj.f.call(obj,1,2,3) //this为obj this 就是你 call 一个函数时，传入的第一个参数 12345678910111213141516var A = &#123; name: &apos;Tom&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var B = &#123; name: &apos;Jack&apos;&#125;;B.describe = A.describe;A.describe() //&quot;姓名：Tom&quot;B.describe() // &quot;姓名：Jack&quot;--------------A.describe() 转换为 A.describe.call(A)，this就是A，那么this.name即 Tom；同样的，B.describe() 可以转换为B.describe.call(B),this就是B，那么this.name即Jack 如何确定this的值1.看源码中对应的函数是怎么被call的 2.看文档 123btn.addEventListener(&apos;click&apos; ,function handler()&#123; console.log(this) // 请问这里的 this 是什么&#125;) EventTarget.addEventListener()处理过程中 this 的值的问题，在MDN文档中是这样说的： 通常来说this的值是触发事件的元素的引用，这种特性在多个相似的元素使用同一个通用事件监听器时非常让人满意。 当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 currentTarget 属性的值一样。 所以，上面this指的就是事件被监听的元素btn 3.打印出来console.log(this)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS调试]]></title>
      <url>%2F2017%2F04%2F25%2FJS%E8%B0%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[史上第一个bug1947年9月9日，葛丽丝·霍普（Grace Hopper）发现了第一个电脑上的bug。当在Mark II计算机上工作时，整个团队都搞不清楚为什么电脑不能正常运作了。经过大家的深度挖掘，发现原来是一只飞蛾意外飞入了一台电脑内部而引起的故障。这个团队把错误解除了，并在日记本中记录下了这一事件。也因此，人们逐渐开始用“Bug”（原意为“虫子”）来称呼计算机中的隐错。 debug 就是找出 bug 的过程。 打字会错123456iOS 写成 iosJavaScript 写成 Javascriptvertical 写成 verticelprops 写成 porps半角空格写成全角空格ls -la 写成 ls-la html的bug 用https://validator.w3.org/#validate_by_input这个网址来检查错误（validator验证器） 用WebStorm检查（语法错误以及拼写错误） CSS的bug用border以及开发者工具 没有样式，选择器没有选择到，(.tabsb li b 后面多了个逗号,) CSS错误的注释会毁掉下面一行 用border大法可以清楚地看到由于浮动而造成的符元素内容塌陷 当使用border会影响布局的时候，用outlne代替，它不会占用盒模型位置 VS. JavaScript的bug 确定你的代码运行了 上帝视角 拼写错误 拼写错误 拼写错误 其他错误（用 WebStorm 可以避免拼写错误） 用 console.log 或者 console.assert 验证 html文件映射到浏览器页面，直接在浏览器中修改调试 打开谷歌开发者工具 — setting — workspace — add folder 映射 Map to File System Resource 按下esc，出现控制台，就可以实时修改了，修改完按下保存再刷新，进行调试。 Uncaught ReferenceError:appel is not defined：用了一个未声明过的变量。（reference error 引用错误） 把它打印出来是什么类型 Uncaught TypeError: obj.fooo is not a function：不是一个函数 （type error类型错误） 打印出来，属性不报错，返回undefined （变量未声明直接用回报错，属性没声明直接用不报错） Uncaught SyntaxError: Unexpected token function ：未意料到的字符 function ，说明语法有错误（foo:function） （syntax error语法错误） Uncaught TypeError : Cannot read property ‘join’ of undefined：jion前面的出现错误]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM API获取元素的几种方法]]></title>
      <url>%2F2017%2F04%2F19%2FAPI%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%9D%2F</url>
      <content type="text"><![CDATA[DOM节点DOM的最小组成单位叫做节点（node）。文档的树形结构（DOM树），就是由各种不同类型的节点组成。节点有以下7种类型 Document：整个文档树的顶层节点（root node） DocumentType: doctype标签 Element：网页的各种HTML标签 Attribute：网页元素的属性（如calss=”aa”) Text：标签之间包含的文本内容 Comment：注释 DocumentFragment：文档片段 节点间的关系除了根节点&lt;html&gt;，它的下级节点与周围节点存在三种关系 父节点关系：parentNode 子节点关系：childNodes firstChild：第一个子节点 lastChild：最后一个子节点 同级节点关系：sibling nextSibling：紧邻在后的那个同级节点 previousSibling：紧邻在前的那个同级节点 document.querySelector()接受一个css选择器作为参数，返回匹配该选择器的第一个节点，如果没有匹配的节点返回null。 语法：element = document.querySelector(selectors) ，selectors是一个字符串，包含一个或者多个css选择器，多个以逗号分隔。 123var element1 = document.querySelector(&apos;.myclass&apos;)var element2 = document.querySelector(&apos;p&apos;) //返回第一个p元素var element3 = document.querySelector(&apos;p.myclass&apos;) //返回文档中class=&quot;myclass&quot;的第一个&lt;p&gt;元素 *document.querySelectorAll()：返回一个NodeList对象，包含所有匹配给定选择器的节点 document.getElementsByTagName()返回一个包括所有给定标签名称的元素集合，如果没有匹配的元素，返回一个空集。可以在任意一个元素上调用该方法。（从给定的父节点开始往下找，如果是div.getElementsByTagName()，则从div这个节点开始往下找） 语法：var elements = document.getElementsByTagName(name)，name是一个字符串。 12var a = document.getElementsByTagName(&apos;p&apos;)//返回当前文档的全部p元素节点 document.getElementsByClassName()返回一个包含所有指定class名称的元素集合，可以在任意元素上调用该方法。 语法：var elements = document.getElementsByClassName(names)，names是一个字符串，如果含有多个class名称，用空格分隔。 12document.getElementsByClassName(&apos;red test&apos;)//返回所有calss名为 red 和 test 的元素 document.getElementById()返回拥有指定id的第一个元素，如果不存在则返回null 语法：element = document.getElementById(id)，id为大小写敏感的字符串 12document.getElementById(&apos;myid&apos;)//返回一个id为myid的元素 Node.firstChild返回树中节点的第一个子节点，如果无子节点，则返回null。（注：空白符节点会充当一个文本节点，可以Node.firstChild.firstChild…的形式使用） 类似的还有：Node.lastChild \ Node.nextSibling \ Node.previousSibling \ Node.parentNode 12345678&lt;p id=&quot;para-01&quot;&gt; &lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var p01 = document.getElementById(&apos;para-01&apos;); alert(p01.firstChild.nodeName)&lt;/script&gt;//返回#text , 因为换行符和空格充当了一个文本节点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM事件委托]]></title>
      <url>%2F2017%2F04%2F19%2FDOM%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
      <content type="text"><![CDATA[事件的三个特点 TOM （代码）订阅/关注/监听了 XXX（用户） XXX （用户）发生了变化 TOM（代码）得到通知 捕获&amp;冒泡 操作系统最先知道用户点击了鼠标，浏览器次之 child 被点击了，意味着 parent 也被点击了 如果同时监听了child和parent，那么 捕获阶段：先通知parent，后通知child 123456child.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;child&apos;)&#125;,true)parent1.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;parent1&apos;)&#125;,ture) //添加ture参数，表示捕获阶段 冒泡阶段：先通知chlid，后通知parent 123456child.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;child&apos;)&#125;,flase)parent1.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;parent1&apos;)&#125;,flase) //默认为flase，冒泡阶段 W3C事件模型：支持两种阶段 12button.addEventListener(&apos;click&apos;,fn,true) //永远别用button.addEventListener(&apos;click&apos;,fn) 如何监听事件当同一个对象使用.onclick的写法触发多个方法的时候，后一个方法会把前一个方法覆盖掉，也就是说，在对象的onclick事件发生时，只会执行最后绑定的方法。而用事件监听则不会有覆盖的现象，每个绑定的事件都会被执行。 DOM level 0 事件： button.onclick = function(){} DOM level 2 事件： button.addEventListener(‘click’, function(){}) e／event1234child1.addEventListener(&apos;click&apos;,function(e)&#123; console.log(e)&#125;)//当出发事件的时候，e告诉你相关事件的任何信息 e.target&amp;e.currentTarget target：触发事件的元素，即点击的元素 currentEvent：被监听的元素 以下图片先点击绿色边框（parent），然后再点击红色区域（child） 阻止默认事件 e.preventDefault()如果加在父元素上，对其子元素也有阻止事件的作用，所以尽量用在要阻止事件的具体子元素上，以免让其他事件失效（图中阻止了a链接的跳转作用，点击百度不会发生跳转） 停止冒泡e.stopPropagation()propagation:传播的意思。 用户点击了子元素，不要向父元素通知。 事件委托 事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。简而言之就是委托它们的父级代为执行事件。 没有时间委托，逐个监听事件 监听是占用内存的，既然4个li做了相同的事情，那么直接监听父元素，同样点击li元素可以实现。（但是有一个问题就是父元素里面的所有内容都会触发事件，包括点击父元素的padding。） 那么添加一个if条件e.target.nodeName === &#39;LI&#39;，让触发事件的目标在元素LI 上，此时解决了上面li元素外和父容器之间也会触发事件的问题。（但是又引申出了一个新的问题，就是点击LI的后代元素无法触发事件。这和初衷不相符。） 再修改一下if条件，e.target.nodeName ===&#39;LI&#39;||e.target.parentNode.nodeName === &#39;LI&#39; , 让LI的span元素也能触发事件，此时的委托事件正好满足这个例子。（但是如果li有多个后代元素，又无法满足条件了。） 再完善一下，我要点击后代元素触发事件，要判断其父元素是不是LI ，如果不是，继续网上找，直到找到li 。（但这样会出现找不到LI的情况，一直网上找到document，再网上就返回null了。） 继续完善，网上找的过程中，如果一直到监听的哪一层元素还没找到，那就停止，返回null。 123456789101112131415161718//较为完整的事件委托代码var ul = document.querySelector(&apos;ul&apos;)function f(e)&#123; let el = e.target while(el.nodeName !== &apos;LI&apos;)&#123; if(el === ul)&#123; el = null break; &#125; el = el.parentNode &#125; if(el)&#123; console.log(&apos;ok&apos;) &#125;else &#123; console.log(&apos;no&apos;) &#125;&#125;ul.addEventListener(&apos;click&apos;,f)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js内存图]]></title>
      <url>%2F2017%2F04%2F03%2Fjs%E5%86%85%E5%AD%98%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[栈（stack） 基本类型是保存在栈内存中的简单的数据段，数据大小确定并且占有固定大小的空间，它们是按值存放的，所以可以直接访问。基本类型有Number , String , Null , Undefined , Boolean , symbol。 基本类型的拷贝是传值 123456var a = 1var b = 2b = aa = 8// 此时b的值为1*基础类型的变量发生复制行为时，直接把a对应的值copy给b，b=1。它们两个变量的值是相互独立不影响的，所以当改变a的值为8时，b的值不会跟着改变仍然为1 堆（heap） 引用类型（复杂类型），即Object（数组，对象，函数等），它们的值是不固定的，存储方式是在堆内存中存储对象，在栈内存中存储该对象的地址（该地址指向对应的对象） 复杂类型的拷贝是传址 123456var a = &#123;m:10&#125;var b = &#123;n:20&#125;b = aa.k = 30b = &#123;m:10 , k:30&#125;*复杂类型的变量发生复制时，复制的是栈内存中的地址，然后指向堆内存中的同一个对象，所以当对象内容发生变化时，两者都会相应地发生改变。 浅拷贝（把栈里面的东西拷贝一遍）如上面举的例子，b拷贝了a后，它们同时指向同一个内存，此时只要改变a或b其中任何一个变量的值，另外一个值就会跟着改变，这种就是浅拷贝。 深拷贝（把堆里面的东西拷贝一遍）b拷贝了a后，在堆内存中重新开辟一个内存来存储b的值，此时指向不同的地址，相互独立。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见的几种排序算法简介]]></title>
      <url>%2F2017%2F03%2F25%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[冒泡排序（bubble sort） 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 比较每一对相邻的两个元素，大的元素放后面，那么比较完一轮后，最后的元素应该是确定的最大的数。 针对所有的元素重复以上的步骤，除了最后一个数（上一轮确定下来的最大的数），直到没有任何一对数字需要比较，排序完成。 选择排序（selection sort） 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 插入排序（insertion sort） 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 从第一个元素开始（该元素可以认为已经被排序），然后取出下一个元素，在已经排序的元素序列中从后向前扫描 依次比较大小，如果前面一个元素比自己大，就继续向前比较，知道找到比自己小的元素，并排在这个元素后面。 重复以上步骤，直到最后一个元素比较完，排序完成。 归并排序（merge sort）通常用递归实现，先把待排序区间[s,t]以中点二分，分成左右区间，接着左右区间继续中点二分，分成更小的左右区间，一层层直到分到单个元素的左右区间，然后一个个小的左右区间比较大小排序并且一层层往上归并，最后把左区间和右区间合并成有序的区间[s,t]。 快速排序（quick sort） 把要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 从数列中挑出一个元素，称为”基准”（pivot） 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作。 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 #### 动手玩一下算法动态演示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS定位position]]></title>
      <url>%2F2017%2F03%2F22%2FCSS%E5%AE%9A%E4%BD%8Dposition%2F</url>
      <content type="text"><![CDATA[position属性指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型。 relative相对定位position:relative ：元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。通过“left”,”top”,”right”,”bottom”来规定位置。 *相对定位的元素并未脱离文档流 注：图二chlid1相对自己原来的位置向右移动了50px，但是child2作为一个行内元素并没有向前移动，去占据child1留下来的空白位置（说明child1原来的位置仍然被它占据着） absolute绝对定位position:absolute ：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置(如果没有祖先元素，则用它所在的包含块来定位）。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。通过“left”,”top”,”right”,”bottom”来规定位置。 *绝对定位的元素脱离了文档流 有非 static 定位的祖先元素 当最近的祖先元素添加position:relative 后，child1根据它来定位。 child1设置了absolute绝对定位后，它的宽度变成了30px，变成了块状元素，即使后面再次声明display:inline; ，它还是以块状元素来显示。 没有非 static 定位的祖先元素 可以看到child1并非根据body以及html来定位。经查css spec（如下图），在没有非static定位的祖先元素的时候，absolute定位是根据根元素的包含块（containing block）来定位的，根元素的包含块也叫初始包含块（initial containing block）, 而初始包含块取自视口的尺寸，并且被固定在画布开始的位置。 fixed绝对定位position:fixed ：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。通过“left”,”top”,”right”,”bottom”来规定位置。 *绝对定位的元素脱离了文档流，比浮动元素更高一层。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css浮动]]></title>
      <url>%2F2017%2F03%2F20%2Fcss%E6%B5%AE%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[浮动float CSS的 float 属性可以使一个元素脱离正常的文档流，然后被安放到它所在容器的的左端或者右端，并且其他的文本和行内元素环绕它。 元素只能左右浮动，不能上下移动 一个浮动会尽量向左/右 移动，直到它的外边缘碰到包含框或者另一个浮动框的边框为止 浮动元素之后的元素会围绕它，之前的元素不受影响 语法 说明 float: left 表明元素必须浮动在其所在的块容器左侧 float: right 表明元素必须浮动在其所在的块容器右侧 清除浮动clear clear属性规定了元素的哪一侧不允许浮动元素 语法 说明 clear : left 在左侧不允许浮动元素 clear : right 在右侧不允许浮动元素 clear : both 在左右两侧均不允许浮动元素 清除浮动的几种方法 从上面两张图可以看到，当内层元素加了浮动之后，div的高度塌缩了，因为内层元素此时已经脱离了文档流，父元素不再包含它。为了避免这种情况，可以清除浮动来使父元素撑开。 使用一个空标签：空标签位置不同效果也不同。 通过 ::after 伪元素 设置clear属性:.parent::after这中间没有空格！！ 123456/* new clearfix */.clearfix::after &#123; #css3为了更好地区分伪类和伪元素，用两个冒号:表示 content: &quot;&quot;; #通过content属性来添加样式（显示生效）使用一个空标签 display: block; #::after表示在当前元素的内容后插入一个子元素（行内元素） clear: both;&#125; 给父元素设置display: inline-block属性: 由块状元素转为行内元素，而行内元素可以根据里面的内容自适应高宽（为了显示出相同的效果，这里加了width：100%）。 给父元素设置overflow:auto或hidden属性：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局（display:flex）]]></title>
      <url>%2F2017%2F03%2F19%2Fflex%E5%B8%83%E5%B1%80%EF%BC%88display-flex%EF%BC%89%2F</url>
      <content type="text"><![CDATA[基本概念flex布局适用于简单的线性布局，可以实现空间自动分配和自动对齐。（flexible：弹性，灵活的） flex container的属性 属性 描述 1、flex-direction 方向 2、flex-wrap 换行 3、flex-flow 上面两个的简写 4、justify-content 主轴方向对齐方式 5、align-items 侧轴对齐方式 6、align-content 多行/列内容对齐方式（用的较少） flex-direction：row（从左往右排列，默认）、row-reverse（右往左）、column（上往下）、column-reverse 注：这个属性的排序默认不换行，flex item再多也会自适应调节比例排成一行/列（且此时会无视flex item自身设置的宽/高）。 flex-wrap：wrap flex-flow：row nowarp justify-content： space-between：空间均衡地放在flex item中间，两边的flex item会顶到两侧 space-around：空间均衡地放在flex item周围，最两侧的flex item也有空间包围 flex-start：flex item都往起点靠 flex-end：flex item都往终点靠 center：flex item都放在中间 align-items： stretch：与flex item最长的那一个对齐，是个默认值 flex-start：所有的flex item都往上靠 flex-end：所有的flex item都往下靠 center：居中 baseline：文字基线对齐 align-content：space-around、space-between、flex-start、flex-end flex item的属性 属性 描述 1、flex-grow 增长比例（空间过多时） 2、flex-shrink 收缩比例（空间不够时） 3、flex-basis 默认大小（一般不用） 4、flex 上面三个的缩写 5、order 顺序（代替双飞翼） 6、align-self 自身的对齐方式 flex-grow：数值（1、2、3等），flex item按这个数值的比例分配多余的空间（1表示全部占有） flex-shrink：数值（1、2、3等），flex item按收缩比例分配 flex-basis：200px ， 一开始默认占200px大小的固定空间 order：数值（1、2、3等），改变flex item的空间顺序 align-self： flex-end，flex-start ， center ， 每个独立flex-item对齐。 使用flex布局实例 手机页面布局（topbar+main+tabs) 产品列表（ul&gt;li*9 pc页面布局 完美居中 一个熟练flex属性的网页小游戏http://flexboxfroggy.com/#zh-cn *最后一关： 1234567#pond &#123; display: flex; flex-flow:column-reverse wrap-reverse; align-items:flex-end; justify-content:center; align-content:space-between&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[post和get请求]]></title>
      <url>%2F2017%2F03%2F12%2Fpost%E5%92%8Cget%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[get和post的区别GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同（唯一的区别是语义区别：get是获取数据，post是提交数据） 表象的区别： get post 一般没有请求消息体 有请求消息体 请求的参数包含在请求行的URL中 参数放在请求的消息体里 url中传送的参数长度有限制（浏览器一般设置2k个字节） post消息体的数据可以非常大（一般几兆） 安全性相对较低（get提交数据后账号和密码明文出现在url上） 相对较高 注 #HTTP协议中，HTTP的请求头和消息体都没有长度的要求。对url长度上的限制，是由于浏览器和服务器两方面造成的（出于安全考虑 [避免被过大的url不停攻击] 和 稳定的考虑，会给url长度加一个限制。 这个限制是针对所有http请求的。 ​ #post和get的安全性只是相对这两者比较而言的，事实上两种方式都不安全。 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[请求和响应]]></title>
      <url>%2F2017%2F03%2F12%2Fhttp%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
      <content type="text"><![CDATA[HTTPhttp（HyperText Transfer Protocol），超文本传输协议，它是一种网络协议，所有的www文件都必须遵守这个标准。可以说，web是建立在http协议上通信的。 DNSdns（DomainName System），域名系统（域名解析系统），主要让用户在互联网上通过域名找到对应的ip地址，而不用去记住能够被机器直接读取的IP数串。 输入：域名 ， 输出：IP 一个域名对应的ip可以有很多（eg：ping baidu.com) 一个域名对应的ip是由域名所有者指定的 改 hosts 可以手动指定域名对应的 IP DNS 可能有缓存，浏览器或者运营商 端口 TCP 或 UDP 协议的规则，一个端口对应一个服务 0 到 1023 号端口是保留端口（只有管理员才能用） 常用端口 21 端口 - FTP 80 端口 - HTTP 53 端口 - DNS 443 端口 - HTTPS 1080 端口 - SOCKS 代理 请求和响应我们在浏览器中输入Google网址到Google网页跳转出来，就经历了一次完整的请求和响应。请求由客户端（即浏览器）发出，响应由服务器端发出。 请求分析123456请求行:（请求方法 路径 协议／版本号） #eg: GET /index.html HTTP/1.1请求头: 请求首部字段 通用首部字段 实体首部字段空格消息体:（aaa=bbbb&amp;ccc=ddd） 注：一般的请求方法有：POST \DELETE \PUT \PATCH \GET \HEAD \OPTIONS \CONNECT \TRACK 响应分析123456状态行 （协议／版本号 状态码 状态描述）#eg:TTP/1.1 200 OK响应头：响应首部字段 通用首部字段 实体首部字段空格消息体 状态码状态码的类别： 类别 原因 1XX Informational（信息状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常，200 3XX Redirection（重定向状态码） 301、302(move temporarily ) 4XX Client Error（客户端错误状态码） 403、404、414 5XX Sever Error（服务器端错误状态码） 500（internal sever error) 一些常见的状态码 状态码 状态描述 200：OK 请求成功 301:moved permanently 请求的资源重定向了，永久移动到新位置（并且浏览器缓存这个结果） 302：move temporarily 请求的资源临时从不同的 URI响应请求。 （浏览器不缓存这个结果） 403:forbidden 服务器拒绝访问。 404:not found 请求失败，请求的资源未在服务器上发现。 405:method not allowed 请求行中指定的请求方法不能被用于请求相应的资源。 414:request-url too long 请求的uri长度超过了服务器能够理解的长度，因此拒绝提供服务。 500:internet server error 服务器遇到了一个未曾预料的状况，导致它无法完成对请求的处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH验证]]></title>
      <url>%2F2017%2F03%2F11%2FSSH%E9%AA%8C%E8%AF%81%2F</url>
      <content type="text"><![CDATA[SSH（ Secure Shell ）是一种网络安全协议，用于计算机之间的加密登入。 两种验证方式： 基于口令的安全验证：输入账号和密码来登入到远程主机，虽然传输的数据都会被加密，但是如果有 ‘中间人’ 冒充我们要访问的服务器，那我们的账号密码就会被 ‘中间人’ 盗取 基于密钥（yuè）的安全验证：用户有两把密钥，一把公钥（对外公开），一把私钥（自己保管）。用ssh公钥登入远程主机，可以免去每次输入密码。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的用户公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。 1命令行操作：ssh-copy-id + url ，把自己的公钥传送存储在远程主机上。 公钥和私钥间的关系： 公钥和私钥是成对的，他们相互解密 公钥加密，只有私钥才能解密，保证数据安全传输 私钥加密签章（数字签名），公钥解密验章用来验证确认对方的身份，用hash函数解密摘要对比来确定信息是否被篡改 数字证书：由CA机构（certificate authority，证书中心）颁发，为公钥做认证，在网上用来识别他人身份的真实性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[input 标签详解]]></title>
      <url>%2F2017%2F03%2F11%2Finput%20%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[input标签用于搜集用户信息，一般放在标签下，根据不同的type属性值，输入字段拥有很多种形式，可以是文本、复选框、按钮等。 一般跟随method属性和action属性，表示如何发送表单数据到action属性所规定的页面 type属性规定input元素的类型，type属性不是必需的，但是应该始终使用它1eg: &lt;input type=&quot;value&quot;&gt; ####type属性及其他常见属性 type=”text” ：默认，定义单行输入字段，用户可在其中输入文本。超出输入字符会继续往后输入，不会换行，也不会调整文本框大小。 type=”password” ：定义密码字段，字段中的字符会被遮蔽。（但是提交上去后密码是可见的，需要其他手段进行加密 其他属性：value \ placeholder \ maxlength \ size \ readonly 123456&lt;form&gt; &lt;input type=&quot;text&quot; value=&quot;hhh&quot;&gt; #value表示显示在文本框中的值，用户输入的时候需要删除 &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; maxlength=&quot;4&quot;&gt; #placeholder作用为提示，文本框中呈灰色字体，输入的时候自动消失，maxlength表示最大能输入的字符（即只能输入4个字符的密码） &lt;input type=&quot;text&quot; size=&quot;30&quot;&gt; # size会生成一个可见30个字符大小的文本框 &lt;input type=&quot;text&quot; value=&quot;hhh&quot; readonly&gt; # readonly是没有值的属性，表示只读，无法修改输入。&lt;/form&gt; type=”button”：定义可点击的按钮（大多与 JavaScript 使用来启动脚本） type=”submit”：定义提交按钮，向服务器发送数据 1234&lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; type=”range” ：定义带有 slider 控件的数字字段。 type=”number” ：定义带有 spinner 控件的数字字段 type=”checkbox” ：定义复选框。 type=”radio”：定义单选按钮。 其他属性：min \ max \ step 12345678910&lt;form&gt; &lt;input type=&quot;range&quot; min=&quot;-10&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;8&quot;&gt; # min和max规定输入的最小和最大值，创建合法值的范围，step表示间隔，value表示初始值 &lt;input type=&quot;number&quot; min=&quot;-100&quot; max=&quot;200&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;小狗 &lt;input type=&quot;checkbox&quot; checked&gt;小猫 #checked表示预先选择该input元素，长与radio和checkbox配合使用） &lt;input type=&quot;radio&quot; name=&quot;a&quot; checked&gt;西瓜 #相同的name值表示3个选项只能选择其一 &lt;input type=&quot;radio&quot; name=&quot;a&quot;&gt;黄瓜 &lt;input type=&quot;radio&quot; name=&quot;a&quot;&gt;苦瓜&lt;/form&gt; type=”color” ; type=”time” ; type=”week” ; type=”month” ; type=”date” ; type=”datetime-local” 123456789&lt;form&gt; &lt;input type=&quot;email&quot;&gt; #定义用于 e-mail 地址的文本字段 &lt;input type=&quot;color&quot;&gt;&lt;br&gt; #定义拾色器 &lt;input type=&quot;time&quot;&gt;&lt;br&gt; #定义时、分、秒（带有 time 控件） &lt;input type=&quot;week&quot;&gt;&lt;br&gt; #定义周（带有 calendar 控件） &lt;input type=&quot;month&quot;&gt;&lt;br&gt; #定义月（带有 calendar 控件） &lt;input type=&quot;date&quot;&gt;&lt;br&gt; #定义日期（带有 calendar 控件） &lt;input type=&quot;datetime-local&quot;&gt; #定义日期及时间（带有 calendar 和 time 控件） &lt;/form&gt; ​ type=”hidden” : 隐藏输入字段，但是提交表单会一起被提交上去 type=”image” : 定义图像作为提交按钮 ; width \ height \ ale 属性 123&lt;form&gt; &lt;input type=&quot;image&quot; src=&quot;image url&quot; width=&quot;30px&quot; alt=&quot;红色按钮&quot;&gt; #width属性调节图片大小(height类似），alt属性表示图片的替代文本 &lt;/form&gt; type=“file” ：提供供文件上传 ；required \ multiple 属性 1234&lt;form&gt; &lt;input type=&quot;file&quot; required&gt; #required 指示输入的字段值是必需的，一次只能上传一个文件，默认也是上传一个 &lt;input type=&quot;file&quot; mulitple&gt; #multiple 允许一个以上的值，可以一下子上传多个文件&lt;/form&gt; 其他属性：list：引用包含输入字段的预定义选项 datalist ，datalist下面接option属性用来提供选择项目，datalist需要type=”text” , 并指定一个id 12345678&lt;form&gt; &lt;input type=&quot;text&quot; list=&quot;datalist1&quot;&gt; #可以预选项里选择，也可以自定义输入其他 &lt;datalist id=&quot;datalist1&quot;&gt; &lt;option&gt;西瓜&lt;/option&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option&gt;香蕉&lt;/option&gt; &lt;/datalist&gt;&lt;/form&gt; select元素（包含在标签里），下面也是接option属性来提供选择项目 1234567&lt;form&gt; &lt;select&gt; &lt;option&gt;西瓜&lt;/option&gt; #只能预选项里选择 &lt;option&gt;苹果&lt;/option&gt; &lt;option&gt;香蕉&lt;/option&gt; &lt;/select&gt; &lt;/form&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符集和字符编码]]></title>
      <url>%2F2017%2F03%2F11%2F%E5%AD%97%E7%AC%A6%E9%9B%86%26%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[字符集和字符编码计算机中存储的信息都是用二进制数表示的（即0和1，逢二进一，这和计算机逻辑电路中的接通和断开两个物理状态对应），而我们在屏幕上看到的英文汉字是二进制数转换的结果。 字符集（Charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 字符编码（Character Encoding）：规定把字符集中的字符编码成计算机可以接受的存储对象，以便文本在计算机中存储和传递。 常用的字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等 字符集 字符编码 ASCII(american standard code for information interchange)美国信息交换标准代码 主要显示现代英语 7位（bits）表示一个字符，共2^7，128个字符 EASCII 追加扩展了一些欧洲常用字符 8位（bits）表示一个字符，共2^8，256个字符 GB2312 国标，用于汉字 小于127的字符意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。 在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GB18030 对gb2312追加扩展，支持国内少数名族文字 采用多字节编码，与utf-8相同 GBK 微软利用GB 2312未使用的编码空间，收录GB 13000.1-93全部字符制定了GBK编码 字符有一字节和双字节编码 BIG5 繁体字 Unicode 万国码 uft-32（每个字符都使用4个字节，造成存储浪费） / utf-16 / utf-8]]></content>
    </entry>

    
  
  
</search>
