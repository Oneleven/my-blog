<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[常见的集中排序算法简介]]></title>
      <url>%2F2017%2F03%2F25%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[冒泡排序（bubble sort） 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 比较每一对相邻的两个元素，大的元素放后面，那么比较完一轮后，最后的元素应该是确定的最大的数。 针对所有的元素重复以上的步骤，除了最后一个数（上一轮确定下来的最大的数），直到没有任何一对数字需要比较，排序完成。 选择排序（selection sort） 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 插入排序（insertion sort） 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 从第一个元素开始（该元素可以认为已经被排序），然后取出下一个元素，在已经排序的元素序列中从后向前扫描 依次比较大小，如果前面一个元素比自己大，就继续向前比较，知道找到比自己小的元素，并排在这个元素后面。 重复以上步骤，直到最后一个元素比较完，排序完成。 归并排序（merge sort）通常用递归实现，先把待排序区间[s,t]以中点二分，分成左右区间，接着左右区间继续中点二分，分成更小的左右区间，一层层直到分到单个元素的左右区间，然后一个个小的左右区间比较大小排序并且一层层往上归并，最后把左区间和右区间合并成有序的区间[s,t]。 快速排序（quick sort） 把要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 从数列中挑出一个元素，称为”基准”（pivot） 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作。 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 #### 动手玩一下算法动态演示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS定位position]]></title>
      <url>%2F2017%2F03%2F22%2FCSS%E5%AE%9A%E4%BD%8Dposition%2F</url>
      <content type="text"><![CDATA[position属性指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型。 relative相对定位position:relative ：元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。通过“left”,”top”,”right”,”bottom”来规定位置。 *相对定位的元素并未脱离文档流 注：图二chlid1相对自己原来的位置向右移动了50px，但是child2作为一个行内元素并没有向前移动，去占据child1留下来的空白位置（说明child1原来的位置仍然被它占据着） absolute绝对定位position:absolute ：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置(如果没有祖先元素，则用它所在的包含块来定位）。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。通过“left”,”top”,”right”,”bottom”来规定位置。 *绝对定位的元素脱离了文档流 有非 static 定位的祖先元素 当最近的祖先元素添加position:relative 后，child1根据它来定位。 child1设置了absolute绝对定位后，它的宽度变成了30px，变成了块状元素，即使后面再次声明display:inline; ，它还是以块状元素来显示。 没有非 static 定位的祖先元素 可以看到child1并非根据body以及html来定位。经查css spec（如下图），在没有非static定位的祖先元素的时候，absolute定位是根据根元素的包含块（containing block）来定位的，根元素的包含块也叫初始包含块（initial containing block）, 而初始包含块取自视口的尺寸，并且被固定在画布开始的位置。 fixed绝对定位position:fixed ：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。通过“left”,”top”,”right”,”bottom”来规定位置。 *绝对定位的元素脱离了文档流，比浮动元素更高一层。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css浮动]]></title>
      <url>%2F2017%2F03%2F20%2Fcss%E6%B5%AE%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[浮动float CSS的 float 属性可以使一个元素脱离正常的文档流，然后被安放到它所在容器的的左端或者右端，并且其他的文本和行内元素环绕它。 元素只能左右浮动，不能上下移动 一个浮动会尽量向左/右 移动，直到它的外边缘碰到包含框或者另一个浮动框的边框为止 浮动元素之后的元素会围绕它，之前的元素不受影响 语法 说明 float: left 表明元素必须浮动在其所在的块容器左侧 float: right 表明元素必须浮动在其所在的块容器右侧 清除浮动clear clear属性规定了元素的哪一侧不允许浮动元素 语法 说明 clear : left 在左侧不允许浮动元素 clear : right 在右侧不允许浮动元素 clear : both 在左右两侧均不允许浮动元素 清除浮动的几种方法 从上面两张图可以看到，当内层元素加了浮动之后，div的高度塌缩了，因为内层元素此时已经脱离了文档流，父元素不再包含它。为了避免这种情况，可以清除浮动来使父元素撑开。 使用一个空标签：空标签位置不同效果也不同。 通过 ::after 伪元素 设置clear属性:.parent::after这中间没有空格！！ 123456/* new clearfix */.clearfix::after &#123; #css3为了更好地区分伪类和伪元素，用两个冒号:表示 content: &quot;&quot;; #通过content属性来添加样式（显示生效）使用一个空标签 display: block; #::after表示在当前元素的内容后插入一个子元素（行内元素） clear: both;&#125; 给父元素设置display: inline-block属性: 由块状元素转为行内元素，而行内元素可以根据里面的内容自适应高宽（为了显示出相同的效果，这里加了width：100%）。 给父元素设置overflow:auto或hidden属性：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局（display:flex）]]></title>
      <url>%2F2017%2F03%2F19%2Fflex%E5%B8%83%E5%B1%80%EF%BC%88display-flex%EF%BC%89%2F</url>
      <content type="text"><![CDATA[基本概念flex布局适用于简单的线性布局，可以实现空间自动分配和自动对齐。（flexible：弹性，灵活的） flex container的属性 属性 描述 1、flex-direction 方向 2、flex-wrap 换行 3、flex-flow 上面两个的简写 4、justify-content 主轴方向对齐方式 5、align-items 侧轴对齐方式 6、align-content 多行/列内容对齐方式（用的较少） flex-direction：row（从左往右排列，默认）、row-reverse（右往左）、column（上往下）、column-reverse 注：这个属性的排序默认不换行，flex item再多也会自适应调节比例排成一行/列（且此时会无视flex item自身设置的宽/高）。 flex-wrap：wrap flex-flow：row nowarp justify-content： space-between：空间均衡地放在flex item中间，两边的flex item会顶到两侧 space-around：空间均衡地放在flex item周围，最两侧的flex item也有空间包围 flex-start：flex item都往起点靠 flex-end：flex item都往终点靠 center：flex item都放在中间 align-items： stretch：与flex item最长的那一个对齐，是个默认值 flex-start：所有的flex item都往上靠 flex-end：所有的flex item都往下靠 center：居中 baseline：文字基线对齐 align-content：space-around、space-between、flex-start、flex-end flex item的属性 属性 描述 1、flex-grow 增长比例（空间过多时） 2、flex-shrink 收缩比例（空间不够时） 3、flex-basis 默认大小（一般不用） 4、flex 上面三个的缩写 5、order 顺序（代替双飞翼） 6、align-self 自身的对齐方式 flex-grow：数值（1、2、3等），flex item按这个数值的比例分配多余的空间（1表示全部占有） flex-shrink：数值（1、2、3等），flex item按收缩比例分配 flex-basis：200px ， 一开始默认占200px大小的固定空间 order：数值（1、2、3等），改变flex item的空间顺序 align-self： flex-end，flex-start ， center ， 每个独立flex-item对齐。 使用flex布局实例 手机页面布局（topbar+main+tabs) 产品列表（ul&gt;li*9 pc页面布局 完美居中 一个熟练flex属性的网页小游戏http://flexboxfroggy.com/#zh-cn *最后一关： 1234567#pond &#123; display: flex; flex-flow:column-reverse wrap-reverse; align-items:flex-end; justify-content:center; align-content:space-between&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[post和get请求]]></title>
      <url>%2F2017%2F03%2F12%2Fpost%E5%92%8Cget%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[get和post的区别GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同（唯一的区别是语义区别：get是获取数据，post是提交数据） 表象的区别： get post 一般没有请求消息体 有请求消息体 请求的参数包含在请求行的URL中 参数放在请求的消息体里 url中传送的参数长度有限制（浏览器一般设置2k个字节，超出部分返回414错误） post消息体大小没有限制【事实上也有限制，根据服务器的设定（一般几兆）】 安全性相对较低（get提交数据后账号和密码明文出现在url上） 相对较高 注：*get和post参数的大小都是有限制的，是人为对浏览器或服务器设置的限制。 ​ *post和get的安全性只是相对这两者比较而言的，事实上两种方式都不安全。 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[请求和响应]]></title>
      <url>%2F2017%2F03%2F12%2Fhttp%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
      <content type="text"><![CDATA[HTTPhttp（HyperText Transfer Protocol），超文本传输协议，它是一种网络协议，所有的www文件都必须遵守这个标准。可以说，web是建立在http协议上通信的。 DNSdns（DomainName System），域名系统（域名解析系统），主要让用户在互联网上通过域名找到对应的ip地址，而不用去记住能够被机器直接读取的IP数串。 输入：域名 ， 输出：IP 一个域名对应的ip可以有很多（eg：ping baidu.com) 一个域名对应的ip是由域名所有者指定的 改 hosts 可以手动指定域名对应的 IP DNS 可能有缓存，浏览器或者运营商 端口 TCP 或 UDP 协议的规则，一个端口对应一个服务 0 到 1023 号端口是保留端口（只有管理员才能用） 常用端口 21 端口 - FTP 80 端口 - HTTP 53 端口 - DNS 443 端口 - HTTPS 1080 端口 - SOCKS 代理 请求和响应我们在浏览器中输入Google网址到Google网页跳转出来，就经历了一次完整的请求和响应。请求由客户端（即浏览器）发出，响应由服务器端发出。 请求分析123456请求行:（请求方法 路径 协议／版本号） #eg: GET /index.html HTTP/1.1请求头: 请求首部字段 通用首部字段 实体首部字段空格消息体:（aaa=bbbb&amp;ccc=ddd） 注：一般的请求方法有：POST \DELETE \PUT \PATCH \GET \HEAD \OPTIONS \CONNECT \TRACK 响应分析123456状态行 （协议／版本号 状态码 状态描述）#eg:TTP/1.1 200 OK响应头：响应首部字段 通用首部字段 实体首部字段空格消息体 状态码状态码的类别： 类别 原因 1XX Informational（信息状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常，200 3XX Redirection（重定向状态码） 301、302(move temporarily ) 4XX Client Error（客户端错误状态码） 403、404、414 5XX Sever Error（服务器端错误状态码） 500（internal sever error) 一些常见的状态码 状态码 状态描述 200：OK 请求成功 301:moved permanently 请求的资源重定向了，永久移动到新位置（并且浏览器缓存这个结果） 302：move temporarily 请求的资源临时从不同的 URI响应请求。 （浏览器不缓存这个结果） 403:forbidden 服务器拒绝访问。 404:not found 请求失败，请求的资源未在服务器上发现。 405:method not allowed 请求行中指定的请求方法不能被用于请求相应的资源。 414:request-url too long 请求的uri长度超过了服务器能够理解的长度，因此拒绝提供服务。 500:internet server error 服务器遇到了一个未曾预料的状况，导致它无法完成对请求的处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH验证]]></title>
      <url>%2F2017%2F03%2F11%2FSSH%E9%AA%8C%E8%AF%81%2F</url>
      <content type="text"><![CDATA[SSH（ Secure Shell ）是一种网络安全协议，用于计算机之间的加密登入。 两种验证方式： 基于口令的安全验证：输入账号和密码来登入到远程主机，虽然传输的数据都会被加密，但是如果有 ‘中间人’ 冒充我们要访问的服务器，那我们的账号密码就会被 ‘中间人’ 盗取 基于密钥（yuè）的安全验证：用户有两把密钥，一把公钥（对外公开），一把私钥（自己保管）。用ssh公钥登入远程主机，可以免去每次输入密码。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的用户公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。 1命令行操作：ssh-copy-id + url ，把自己的公钥传送存储在远程主机上。 公钥和私钥间的关系： 公钥和私钥是成对的，他们相互解密 公钥加密，只有私钥才能解密，保证数据安全传输 私钥加密签章（数字签名），公钥解密验章用来验证确认对方的身份，用hash函数解密摘要对比来确定信息是否被篡改 数字证书：由CA机构（certificate authority，证书中心）颁发，为公钥做认证，在网上用来识别他人身份的真实性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[input 标签详解]]></title>
      <url>%2F2017%2F03%2F11%2Finput%20%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[input标签用于搜集用户信息，一般放在标签下，根据不同的type属性值，输入字段拥有很多种形式，可以是文本、复选框、按钮等。 一般跟随method属性和action属性，表示如何发送表单数据到action属性所规定的页面 type属性规定input元素的类型，type属性不是必需的，但是应该始终使用它1eg: &lt;input type=&quot;value&quot;&gt; ####type属性及其他常见属性 type=”text” ：默认，定义单行输入字段，用户可在其中输入文本。超出输入字符会继续往后输入，不会换行，也不会调整文本框大小。 type=”password” ：定义密码字段，字段中的字符会被遮蔽。（但是提交上去后密码是可见的，需要其他手段进行加密 其他属性：value \ placeholder \ maxlength \ size \ readonly 123456&lt;form&gt; &lt;input type=&quot;text&quot; value=&quot;hhh&quot;&gt; #value表示显示在文本框中的值，用户输入的时候需要删除 &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; maxlength=&quot;4&quot;&gt; #placeholder作用为提示，文本框中呈灰色字体，输入的时候自动消失，maxlength表示最大能输入的字符（即只能输入4个字符的密码） &lt;input type=&quot;text&quot; size=&quot;30&quot;&gt; # size会生成一个可见30个字符大小的文本框 &lt;input type=&quot;text&quot; value=&quot;hhh&quot; readonly&gt; # readonly是没有值的属性，表示只读，无法修改输入。&lt;/form&gt; type=”button”：定义可点击的按钮（大多与 JavaScript 使用来启动脚本） type=”submit”：定义提交按钮，向服务器发送数据 1234&lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; type=”range” ：定义带有 slider 控件的数字字段。 type=”number” ：定义带有 spinner 控件的数字字段 type=”checkbox” ：定义复选框。 type=”radio”：定义单选按钮。 其他属性：min \ max \ step 12345678910&lt;form&gt; &lt;input type=&quot;range&quot; min=&quot;-10&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;8&quot;&gt; # min和max规定输入的最小和最大值，创建合法值的范围，step表示间隔，value表示初始值 &lt;input type=&quot;number&quot; min=&quot;-100&quot; max=&quot;200&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;小狗 &lt;input type=&quot;checkbox&quot; checked&gt;小猫 #checked表示预先选择该input元素，长与radio和checkbox配合使用） &lt;input type=&quot;radio&quot; name=&quot;a&quot; checked&gt;西瓜 #相同的name值表示3个选项只能选择其一 &lt;input type=&quot;radio&quot; name=&quot;a&quot;&gt;黄瓜 &lt;input type=&quot;radio&quot; name=&quot;a&quot;&gt;苦瓜&lt;/form&gt; type=”color” ; type=”time” ; type=”week” ; type=”month” ; type=”date” ; type=”datetime-local” 123456789&lt;form&gt; &lt;input type=&quot;email&quot;&gt; #定义用于 e-mail 地址的文本字段 &lt;input type=&quot;color&quot;&gt;&lt;br&gt; #定义拾色器 &lt;input type=&quot;time&quot;&gt;&lt;br&gt; #定义时、分、秒（带有 time 控件） &lt;input type=&quot;week&quot;&gt;&lt;br&gt; #定义周（带有 calendar 控件） &lt;input type=&quot;month&quot;&gt;&lt;br&gt; #定义月（带有 calendar 控件） &lt;input type=&quot;date&quot;&gt;&lt;br&gt; #定义日期（带有 calendar 控件） &lt;input type=&quot;datetime-local&quot;&gt; #定义日期及时间（带有 calendar 和 time 控件） &lt;/form&gt; ​ type=”hidden” : 隐藏输入字段，但是提交表单会一起被提交上去 type=”image” : 定义图像作为提交按钮 ; width \ height \ ale 属性 123&lt;form&gt; &lt;input type=&quot;image&quot; src=&quot;image url&quot; width=&quot;30px&quot; alt=&quot;红色按钮&quot;&gt; #width属性调节图片大小(height类似），alt属性表示图片的替代文本 &lt;/form&gt; type=“file” ：提供供文件上传 ；required \ multiple 属性 1234&lt;form&gt; &lt;input type=&quot;file&quot; required&gt; #required 指示输入的字段值是必需的，一次只能上传一个文件，默认也是上传一个 &lt;input type=&quot;file&quot; mulitple&gt; #multiple 允许一个以上的值，可以一下子上传多个文件&lt;/form&gt; 其他属性：list：引用包含输入字段的预定义选项 datalist ，datalist下面接option属性用来提供选择项目，datalist需要type=”text” , 并指定一个id 12345678&lt;form&gt; &lt;input type=&quot;text&quot; list=&quot;datalist1&quot;&gt; #可以预选项里选择，也可以自定义输入其他 &lt;datalist id=&quot;datalist1&quot;&gt; &lt;option&gt;西瓜&lt;/option&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option&gt;香蕉&lt;/option&gt; &lt;/datalist&gt;&lt;/form&gt; select元素（包含在标签里），下面也是接option属性来提供选择项目 1234567&lt;form&gt; &lt;select&gt; &lt;option&gt;西瓜&lt;/option&gt; #只能预选项里选择 &lt;option&gt;苹果&lt;/option&gt; &lt;option&gt;香蕉&lt;/option&gt; &lt;/select&gt; &lt;/form&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符集和字符编码]]></title>
      <url>%2F2017%2F03%2F11%2F%E5%AD%97%E7%AC%A6%E9%9B%86%26%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[字符集和字符编码计算机中存储的信息都是用二进制数表示的（即0和1，逢二进一，这和计算机逻辑电路中的接通和断开两个物理状态对应），而我们在屏幕上看到的英文汉字是二进制数转换的结果。 字符集（Charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 字符编码（Character Encoding）：规定把字符集中的字符编码成计算机可以接受的存储对象，以便文本在计算机中存储和传递。 常用的字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等 字符集 字符编码 ASCII(american standard code for information interchange)美国信息交换标准代码 主要显示现代英语 7位（bits）表示一个字符，共2^7，128个字符 EASCII 追加扩展了一些欧洲常用字符 8位（bits）表示一个字符，共2^8，256个字符 GB2312 国标，用于汉字 小于127的字符意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。 在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GB18030 对gb2312追加扩展，支持国内少数名族文字 采用多字节编码，与utf-8相同 GBK 微软利用GB 2312未使用的编码空间，收录GB 13000.1-93全部字符制定了GBK编码 字符有一字节和双字节编码 BIG5 繁体字 Unicode 万国码 uft-32（每个字符都使用4个字节，造成存储浪费） / utf-16 / utf-8]]></content>
    </entry>

    
  
  
</search>
