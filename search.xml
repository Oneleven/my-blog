<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS高级程序读书笔记（1）]]></title>
      <url>%2F2018%2F03%2F28%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%2F</url>
      <content type="text"><![CDATA[复制 基本类型：从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。两个值是独立的。基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中。 12345var num1 = 5var num2 = num1num1 ++num1 //6num2 //5 引用类型：从一个变量向另一个变量复制引用类型的值时，新变量分配的空间中存放的副本是一个指针，这两个变量都指向存储在堆内存中的同一个对象。 执行环境&amp;作用域 执行环境有全局执行环境和函数执行环境之分。全局执行环境（window对象）是最外围的一个执行环境，关闭网页或浏览器时全局执行环境被销毁 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。 1当引用一个变量时，会从当前作用域开始搜索查询，然后逐级向上搜索，如果一直追溯到全局环境没找到这个变量，说明该变量尚未声明。 垃圾收集 JS具有自动垃圾收集机制，即找出那些不再使用的变量打上标记，然后释放其占用的内存空间。 1最常用的垃圾收集方式是标记清除（mark-and-sweep），垃圾收集器在运行的时候会给存储在内存中的所有变量加上标记----&gt; 去掉环境中的变量和被环境中变量引用的变量的标记 -----&gt; 在此之后变量被打上标记视为准备删除的变量 内存管理—解除引用：一旦数据不再有用，可将其设置为null 1234567function fn(name)&#123; var localPerson = new Object() localPerson.name = name return localPerson&#125;var globalPerson = fn(&apos;tom&apos;)globalPerson = null //对于全局变量而言，需要手动解除 对象的属性表示 person.name === person[“name”] ，使用方括号语法时，里面的属性是字符串的形式 person[“first name”]，如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法 数组 给数组添加新的项：var arr = [1, 2, 3, 4] arr[arr.length] = 5 //[1, 2, 3, 4, 5] arr.push(5,6) //返回数组长度6 ，原数组变为[1, 2, 3, 4, 5, 6] arr.pop() arr.unshift() arr.shift() arr.splice(index, howmany, itmes) 判断数组：Array.isArray(arr) 重排序方法 arr.reverse() arr.sort(value1,value2) 1234var arr1 = [3,5,2,4,1]var arr2 = arr1.sort((value1,value2)=&gt;&#123; return value1 - value2&#125;) arr.concat() arr.slice(start,end) 位置方法：arr.indexOf(searchElement,startIndex) ：没有找到就返回-1 string也有atr.indexOf() 方法（根据内容找index），str.charAt(index) （根据index找内容） 迭代方法 forEach(item, index, array) ：没有返回值 map(item, index, array) ：返回数组 filter(item, index, array) ：返回满足条件true的数组 every(item, index, array) ：返回布尔值 some(item, index, array) ：返回布尔值 归并方法：reduce(preValue, currentValue, currentIndex, array, initialValue) 123456#数组求和var arr = [1,2,3,4]var sum = arr.reduce((pre,cur)&#123; return pre+cur&#125;,7)sum // 17 Date 1970年1月1日午夜（零时）开始经过的毫秒数保存日期 Date.now()：返回距离1970年1月1日的毫秒数 指定生成日期new Date(&quot;Mar 18, 1992&quot;)或者 new Date(1992,2,18,17,03,55) 1234new Date(&quot;Mar 18, 1992&quot;) 字符串格式----------new Date(1992,2,18,17,03,55) 分别对应年，月（从0开始），日，时(0~23),分，秒//Wed Mar 18 1992 17:03:55 GMT+0800 (中国标准时间) toString()和 toLocalString()和valueOf() 1234var a = New Date()a.toString() //&quot;Fri Mar 30 2018 16:14:34 GMT+0800 (中国标准时间)&quot;a.toLocalString() //&quot;2018/3/30&quot; 返回当地时间格式a.valueOf() //1522397674376 返回毫秒数 getFullYear()：年份 getMonth()：月份，0表示1月 getDate()：天数 getDay()：返回星期几，0表示周日 getHours()：小时 getMinutes()：分钟 getSeconds()：秒 #####this this引用的是函数执行时所在的环境对象（谁调用指向谁），es6的箭头函数体内的this引用的是函数定义时的环境对象 函数的属性和方法 2个属性： length：函数希望接收到参数的个数 prototype：保存所有实例方法的属性 2个方法：每个函数都有两个非继承而来的方法，apply和call，他们的作用是在特定的作用域中调用函数，相当于设置函数体内this对象的值。 call()：第一个参数是this（运行函数的作用域），其余的参数直接传递给函数（必须逐个列举出来） apply()：第一个参数是this，其余的参数可以是arguments对象，也可以是Array的实例 123456789101112131415function sum(n1, n2)&#123; return n1 + n2&#125;function callSum1(n1, n2)&#123; return sum.call(this, n1, n2) //必须逐个列举&#125;function callSum2(n1, n2)&#123; return sum.supply(this, arguments) //传入arguments对象&#125;function callSum3(n1, n2)&#123; return sum.apply(this, [n1, n2]) //传入数组&#125;callSum1(10, 10) //20callSum2(10, 10) //20callSum3(10, 10) //20 bind()：创建一个函数的实例（新函数），this值被绑定到传入bind()函数的第一个参数 123456789var o = &#123;color:&quot;red&quot;&#125;var color = bluefunction fn()&#123; console.log(this.color) &#125;fn() //blue,这里this引用的是windows环境对象-----------var xxx = fn.bind(o) xxx() //red 即fn.bind(o)() 基本包装类型每当读取一个基本类型值得时候，后台会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。有了基本包装类型， js中的基本类型值可以被当作对象来访问。三种基本包装类型有string，boolean，number 每个包装类型都映射到同名的基本类型 访问基本类型值时，会创建对应的基本包装类型对象，从而方便数据操作 操作完毕后，立即销毁新创建的包装对象 123456var s1 = &quot;heihei&quot;var s2 = s1.substr(3,2) //&quot;hei&quot; s1是基本类型不是对象，逻辑上不应该有方法----------实际上执行到第二段代码时，后代自动完成下列处理var s1 = new String(&quot;some text&quot;); 创建String实例 s1 instanceof String //truevar s2 = s1.substring(2); 在实例上调用指定的方法s1 = null; 销毁这个实例 1234# 引用类型与基本包装类型的主要区别就是对象的生存期。使用new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。var s1 = &quot;some text&quot;; //与 new String(&quot;some text&quot;)是有区别的s1.color = &quot;red&quot;;alert(s1.color); //undefined String类型 str.charAt(index) ：返回位置字符 str.charCodeAt(index) ：返回字符编码 str.indexOf(content) ：根据字符查找index str.lastIndexOf() str.search(RegExp) ：找到首个匹配成功的index，没有返回-1(可以用正则) str.concat(str2，str3) ：拼接字符串 str.slice(start, end) ：如果参数为负数，被str.length + 负数 看待 str.substring(start, end) ：会自动调整start和end，较小的数字在前。任意参数小于0或者为NaN，会被视为0 str.substr(start, length) ：length为0或者负数，返回空字符串””, start为负数，从末尾开始往右取值 1234var stringValue = &quot;hello world&quot;;alert(stringValue.slice(3, 7)); //&quot;lo w&quot;alert(stringValue.substring(3,7)); //&quot;lo w&quot;alert(stringValue.substr(3, 7)); //&quot;lo worl&quot; str.trim() ：除去字符串两端的空格 str.toLowerCase() &amp;&amp; str.toUpperCase() str.match(RegExp) : 返回满足条件的数组，如果正则不带g，与RegExp.exec(str)相同效果，返回第一个匹配到的元素数组，并带有index和input(原字符串)属性 str.replace(RegExp|str, newStr|function(match,index,str) 1234交换两个字符串的位置var str = &quot;Tom Jack&quot;var reg = /(\w+)\s(\w+)/var newStr = str.replace(reg, &quot;$2 $1&quot;) //$n表示第n个被捕获的内容 str.split([separator[, limit]]) Math对象 四舍五入： Math.floor(num) ：往下舍入 Math.ceil(num) ：往上舍入 Math.round(num) ：四舍五入 Math.random(num) 12345#在某个整数范围内随机一个值值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)---------取2～10的随机整数var random = Math.floor(Math.random * 10 + 2) Math.abs(num) ：绝对值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS高级程序读书笔记（1）]]></title>
      <url>%2F2018%2F03%2F28%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[ECMAScript与JavaScript ECMAScript定义了JS语言的基础标准，规定了语法、语句、类型、关键字、保留字、操作符、对象 JS是对ECMAScript的实现。一个完整的JS由ECMAScript、文档对象模型（DOM）、浏览器对象模型（BOM）组成 文档对象模型DOM 用于HTML的应用程序编程接口，提供访问和操作网页内容的方法和接口。DOM把整个页面映射为一个多层节点的树形结构。开发人员可以通过DOM提供的API进行节点的增删改查操作 DOM分为3个级别，支持DOM是浏览器开发商的首要目标 DOM1级：DOM核心模块+DOM HTML模块，主要是映射文档的结构 DOM2级：增加DOM事件，DOM试图，DOM样式，DOM遍历和范围 DOM3级：增加SVG等新接口 浏览器对象模型BOM 浏览器对象模型，提供与浏览器交互的方法和接口。 &lt;script&gt;加载外部js文件标签的位置浏览器在遇到&lt;body&gt;标签时才开始呈现内容，所以一般放在&lt;body&gt;元素中内容的后面。如果放在&lt;head&gt; 标签里，就必须等js代码下载解析和执行完成后才能呈现页面内容，这期间浏览器窗口一片空白。 标识符 变量，函数，属性的名字，一般采用驼峰大小写格式 第一个字符必须是字母，下划线_ ，美元符号$ 其他字符可以是字母，_ ，$， 数字 关键字和保留字 关键字是具有特定用途的字符，不能用作标识符，比如new， var， if， return 保留字是有可能将来被用作关键字，如double，private，package nullnull值表示一个空对象的指针，因此用typeof null 得出的结果是object。当定义的变量准备在将来用于保存对象时，可以初始化为null 123if(car !== null)&#123; //对car 对象执行某些操作&#125; boolean转换为false的值：false , “”（空字符串）, 0 , null , undefined , NaN number 八进制数（0开头）：070 十六进制（0x开头，后面跟0~9及A~F）：0xA 在进行计算是，都会被转为十进制数 NaNNaN是一个非数值，任何值除以非数值都会返回NaN NaN不等于任何值，包括自己 NaN任何计算操作都返回NaN 12345678#isNaN(arg): 任何不能转为数字的arg都会返回trueisNaN(&apos;10&apos;) //false 能转为数值就返回falseisNaN(&apos;true&apos;) //falseisNaN(&apos;hello&apos;) //true----------------# Number.isNaN(arg) //arg值是NaN就返回true，用来判断是否是NaNNumber.isNaN(0/0) //trueNumber.isNaN(&apos;NaN&apos;) //false 字符串“NaN”不会转换为NaN 数值转换 Number()：可以用于任何数据类型 123456Boolean值：true返回1，false返回0null值：返回0&quot;&quot; 空字符串：返回0undefined值：返回NaN其他进制的数字都转换为：十进制数其他类型的值，返回NaN parseInt(str, 进制数)：常用来处理整数的转换，处理字符串，返回数字。第二个参数指定转换的进制数，最好不要省略 忽略字符串前的空格，直到找到第一个非空格字符 忽略字符串数字后面的非数字，只转换数字部分parseInt(&quot;1234blue&quot;,10) //1234 如果第一个字符不是数字或者负号，返回NaN 只处理有效数字，小数点不是有效数字parseInt(22.5, 10) //22 parseFloat(str) ：只有一个参数，可以处理浮点数。而parseInt()只能返回整数 12parseFloat(&apos;3.125e7&apos;) //31250000parseInt(&apos;3.125e7&apos;) //3 字符字面量（转义序列） \r ：回车（把打印头移到开头）windows系统里 \r\n表示换行 \n ：换行（向下移一行）mac系统里\n表示换行 \\：斜杠 \’：单引号 #####toString() 和String(value) 除了null和undefined，其他类型都有toString()方法 在不知道转换的值是不是null或者undefined的情况下，用String()方法 12String(null) //&quot;null&quot;String(undefined) //&quot;undefined&quot; 递增递减操作符++ &amp; – 放在数值变量前面，前置递增和递减操作符与执行语句的优先级相同 1234var a = 2var b = 20var num1 = --a + b //21var num2 = a + b //21 放在数值变量后面，执行语句优先级 &gt; 后置递增和递减操作符 1234var a = 2var b = 20var num1 = a-- + b //22 这里先执行a+b，再执行a--var num2 = a + b //21 ++ &amp; –操作符适用于任何值 12var a = &quot;z&quot; a++ //NaN 对于不能转化为数字的值，结果为NaN（非数字）var b = &apos;true&apos; b++ //2 布尔值true和false转化为1和0 逻辑操作符 逻辑非：! ，返回相反的布尔值 逻辑或：a||b||c ，最后一个值可以作为保底值。 121 || false //1 第一个值为true的情况下就不会对第二个值求值null || 2 //2 逻辑与：a &amp;&amp; b &amp;&amp; c 121 &amp;&amp; 2 //2 都为真的情况下返回第二个值undefined &amp;&amp;2 //undefined 运算操作符 取余数：var result = 26 % 5 //1 加法： 12var result1 = 5+5 //10var result2 = &quot;5&quot;+5 //&quot;55&quot; 字符串+数值 =&gt;字符串 switch…case…语句1234567891011121314151617# 每个case后面添加break，可以避免同时执行多个caseswitch(expression)&#123; case value:statement break; case value:statement break; defalut:statement&#125;--------------var num = 25switch(true)&#123; case num&lt;20: console.log(&apos;less than 20&apos;) break; default: console.log(&apos;more than 19&apos;)&#125; 函数的参数参数在函数内部是用一个数组来表示的，可以传递任意数量的参数，并且可以通过arguments 对象来访问这些参数数组。arguments对象是个类数组，可以通过arguments[0]等访问，arguments.length表示传进来的传参数个数。 12345function test()&#123; console.log(...arguments) console.log(arguments.length)&#125;test(1,2,3,4) //1 2 3 4 4 函数的返回值未指定返回值的函数返回的是一个特殊的undefined值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络是怎样连接的-第一第二章读书笔记]]></title>
      <url>%2F2018%2F03%2F27%2F%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84-%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[#####浏览器与服务器的交互过程 浏览器的第一步工作就是对URL进行解析（确定web服务器和要访问的文件名） 解析完后根据解析的信息生成HTTP请求（使用HTTP协议访问Web服务器） HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤 先客户端向服务器端发送请求消息：包括URI+方法 | 含义 | 方法 || :————————————–: | :——: || 获取URI 指定的信息。如果URI 指定的是文件，则返回文件的内容；get的消息体能发送的数据只有几百个字节 | GET || 从客户端向服务器发送数据。一般用于发送表单中填写的数据等情况下 | POST || 和GET 基本相同。不过它只返回HTTP 的消息头（message header），而并不返回数据的内容。用于获取文件最后更新时间等属性信息 | HEAD || 用于通知或查询通信选项 | OPTIONS || 替换URI 指定的服务器上的文件。如果URI 指定的文件不存在，则创建该文件 | PUT || 删除URI 指定的服务器上的文 | DELETE | 服务器端接收到请求消息后，根据请求的要求把处理的结果放在响应消息中，返回给客户端。 | 状态码 | 含义 || :–: | :————————–: || 1XX | 告知请求的处理进度和情况 || 2XX | 成功（200） || 3XX | 表示需要进一步操作（暂时重定向302；永久重定向301） || 4XX | 客户端错误（404请求失败，414url太长） || 5XX | 服务器端错误 | 如果网页的内容只有文字，那么响应消息体返回给客户端就结束了（1次） 如果网页有图片，浏览器会显示文字的时候所搜图片标签，遇到后留出显示图片的空间，然后再次请求图片。因为每个请求消息中只有一个uri，所以一次只能获取1个图片。如果网页中包含3个文件，那么要请求4次。 消息体的内容作为二进制数据来处理 生成HTTP消息后，委托（委托的操作是调用Socket库中的程序组建来执行的，Socket充当一个桥梁给操作系统的协议栈）操作系统将消息发送给Web服务器（通信数据是以包的形式传送的） 在生成HTTP消息后，根据域名查询IP地址（接着浏览器将ip地址和请求消息一起交给操作系统） 附1：TCP/IP网络的基本思路：通过小的子网（网络号）（用集线器连接起来的几台计算机（主机号）），通过路由器连接起来组成大的网络。网络号+主机号的整体称为IP 地址（一个IP地址长度为32比特）。（IP地址内部用 子网掩码 来表示网络号（1）和主机号（0）） 11. 发送过程：通过IP 地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上，接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器，直到传送到目的地。 附2 ：根据域名查询IP 地址时，浏览器会使用Socket 库中的解析器向DNS 服务器发出查询消息，并接收服务器返回的响应消息。我们计算机上对应的DNS客户端（一段代码，在Socket库中）称为DNS解析器。 调用解析器，向DNS 服务器发出查询消息 服务器返回响应消息，里面包含IP地址，并储存在浏览器指定的内存地址中（接着浏览器向Web服务器发送消息时，从内存中取出IP地址，将它与HTTP请求消息一起交给操作系统） #####浏览器与Web服务器之间接收发消息的过程 操作系统收到IP地址和HTTP请求消息后，通过内部的协议栈向目标IP地址发送请求消息。（委托协议栈发送数字信息适合所有的网络应用程序，不局限于web） 12345收发数据的操作分为4个阶段，由操作系统中的协议栈来执行- 创建套接字（IP地址加上端口号作为TCP连接的端点叫套接字，即 IP地址：端口号）- 将管道连接到服务器端套接字上- 收发数据- 断开管道并删除套接字（管道连接是由客户端发起，但在断开时可以由任意一方发起） 创建套接字阶段：调用Socket库的组建创建套接字，之后协议栈会返回一个描述符，来识别不同的套接字。 连接阶段：委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序调用Socket库中的connect程序组建，指定描述符，IP地址，端口号 。 1注：描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。 通信阶段：套接字连接起来之后，调用Socket库write组建，协议栈就将数据（输入网址生产的HTTP请求消息）送入套接字，然后发送到对方的套接字中。 1收到响应消息后，通过Socket库中的read组件委托协议栈来接收消息并放到接收响应的内存地址（命名为接收缓冲区） 操作系统中的网络控制软件（协议栈）和网络硬件（网卡）是如何处理数据发送请求的 ​ (协议栈内部图 ) 网络应用程序：像浏览器，电子邮件客户端等，将收发数据等工作委派给下层部分。下面是Socket库，其中包含解析器，用来向DNS服务器发送查询。 操作系统内部包含了协议栈： 上半部分分为TCP+UDP：接收应用程序的委托，执行收发数据的操作 12浏览器、邮件等一般应用程序收发数据时用TCP；DNS 查询等收发较短的控制数据时用UDP。 下半部分是IP协议：用来控制网络包收发操作 网卡驱动程序：负责控制网卡硬件 网卡：负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。 12附：套接字：协议栈内部有一块存放控制信息的内存，控制信息包括IP地址，端口号，通信操作的状态等，这些控制信息就是套接字的实体。 #####具体过程 浏览器通过 Socket 库向协议栈发出委托，委托协议栈通过TCP协议来收发数据。 创建套接字：浏览器调用Socket库申请创建套接字，协议栈根据此申请执行创建套接字，在创建套接字时： 首先分配一个套接字所需的内存空间，然后向其中写入初始状态。 将表示这个套接字的描述符告知应用程序 应用程序收到描述符后，向协议栈发起收发数据委托时需要提供这个描述符。 连接：浏览器调用socket库中的connect，然后协议栈将本地套接字和服务器的套接字连接。套接字创建完后，协议栈并不知道要和谁进行沟通 1231. 浏览器可以根据网址查询ip地址及端口号，但是协议栈不知道，这是就需要调用connect将这些信息传递给协议栈。2. 向服务器端发送TCP包进行连接请求3. 分配一块内存空间用来临时存放收发信息（缓冲区） 控制信息分类 头部中记录的控制信息：网络包开头的控制信息称为TCP头部（20个字节），还有以太网头部，IP头部。客户端和服务器端在通信过程中会将头部的信息相互确认，头部是用来记录和交换控制信息的。 保存在套接字中，用来操作协议栈的操作信息： 应用程序传递过来的信息，ip地址等 通信对象接收到的信息 收发数据操作的执行状态 具体步骤 应用程序调用connect(&lt;描述符&gt;,&lt;ip地址和端口号&gt;) ，这些信息会传递给协议栈中的TCP模块，并在TCP模块处创建 表示连接控制信息 的头部。（TCP模块会与ip对应的服务器的TCP模块交换控制信息） 根据头部中的发送方和接收方端口号找到要连接的套接字 TCP头部创建好后，将信息传递给IP模块并委托它进行发送 1IP模块执行网络包发送操作后，网络包就会通过网络传递到服务器 服务器上的IP模块将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部信息找到端口号对应的套接字，并写入相应的信息将状态改为正在连接。 然后服务器的TCP模块会返回响应，将ACK控制为设为1，表示已经接收到相应的网络包。 网络包返回客户端，通过IP模块到达TCP模块，并通过TCP头部信息确认是否连接成功。客户端也将ACK设置为1发回服务器，表示响应包已经收到 收发数据：应用程序调用write将发送的数据交给协议栈，协议栈收到数据后执行发送操作。 通过“序号”和“ACK 号”可以确认接收方是否收到了网络包。 123456协议栈收到数据后，会先存放在内部的发送缓冲区中，并等待下一段数据。它有两个维度，一个是长度优先，长度满MSS后发送，但是造成发送延迟；另一个是时间，经过一段时间后，就把包发送出去，但是会降低网络效率。- 一个网络包最大长度是MTU，1500字节- 去掉头部后的能容纳最大数据的长度MSS------------------------当发送数据较大时，会分割成一个个小的网络包，当判断要发送这些数据时，在每一个数据前面加上TCP头部。TCP在拆分数据时，会在TCP头部写上“序号”字段（从头开始的第几个字节，实际应用过程中这个第一个号是随机的，所以在连接阶段需要将序号的初始值告诉对方） + 包的长度；对方在收到数据包后，确认返回ACK号（一共收了多少字节） 通过滑动窗口管理ACK号：在发送完一个包后，不等待这个包的ACK返回，直接发送后续一系列包，并且客户端告知发送方自己能接收的最大数据量（称为窗口大小），发送方根据这个来控制数据发送操作。 1231. 接收方在接到包后，先将数据保存在接收缓冲区中，计算ACK号并组装数据包，将数据传递给应用程序，然后释放缓冲区2. 当接收方将缓冲区的数据传递给应用程序释放缓冲区的时候，需要将窗口大小字段发送给发送方3. 连续的ACK号可以合并，发送最后一个ACK号即可，并会和窗口大小字段合并在一个包里一起发送 断开连接：双方都可以发起断开连接，然后过一段时间后客户端删除套接字。 12345以服务器发起断开为例：1. 调用Socket库中的close，协议栈生产断开信息的TCP头部，将FIN设为1，并委托IP模块发送数据2. 客户端收到网络包后，将自己的套接字标记为断开操作状态。并反馈ACK号给服务器3. 客户端也会调用close，生成FIN为1的TCP包，发送服务器4. 服务器返回ACK号 #####收发数据总结： 第一步是创建套接字，服务器端启动时就创建好套接字并等待连接状态，客户端一般是发送请求的时候创建套接字 包含了通信的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 然后客户端向服务器端发起连接操作。客户端生成一个SYN为1的TCP包，头部也包含发送数据的初始序号（随机生成）和窗口大小（接收缓冲区最多能接收的容量大小）。服务器端返回SYN为1的TCP包，也包含了序号和窗口大小，还有表示确认收到包的ACK号（为1），然后客户端再返回一个确认的ACK号。3次握手确认。连接完毕。 1SYN 是 Synchronize(同步)的缩写，意思是通过告知初始序号使通信双方保持步调一致，以便 完成后续的数据收发检查 数据收发阶段，客服端向服务器端发送请求信息，TCP将请求信息切分成一个个数据包，并打上TCP头部（头部包含序号，它表示当前发送的是第几个字节的数据），然后发送给服务器。服务器返回ACK号。起初服务器不断接收数据存储在缓冲区中，随着数据传递给应用程序，缓冲区空间被释放，此时将窗口大小反馈告知客户端。当收到请求后，服务器端向客户端返回相应消息。这个过程和刚才相反。 服务器响应消息发送完后，开始执行断开操作。以HTTP1为例，客户端发起断开过程。客户端发送一个FIN为1的TCP包，客户端返回一个确认收到的ACK号，然后双方交换一组方向相反的过程。最后，在一段时间后，套接字会被删除。 IP模块TCP模块在执行连接，收发和断开操作时，都需要委托IP模块将数据封装成包发送给通信对象（整个传输是由集线器和路由器等设备完成的，IP模块是传输过程的一个入口）。网络包是由头部信息+数据组成的。 TCP/IP包包含如下两个头部，MAC头部（包含MAC地址） + IP头部（包含IP地址） 网络中有路由器和集线器两种不同的转发设备，他们在传输网络包时有着各自的分工 路由器根据目标地址判断下一个路由器的位置（按照IP规则传输） IP协议根据目标地址判断下一个IP转发设备的位置 集线器在子网中将网络包传输到下一个路由（按照以太网规则） 子网中的以太网协议将包传输到下一个转发设备 整个传输过程：首先发送方将服务器IP地址写入IP头部（IP协议就可以根据地址查找包的传输方向），IP协议会查找下一个路由器的以太网地址，并写在MAC头部，这样以太网协议就知道要将这个包发送到哪个路由器上。IP协议协议会委托以太网协议把包传输出去） MAC头部 - IP头部 - TCP头部+数据 ， 经过集线器（有以太网协议表，根据MAC头部信息查出下一个路由器地址并发送到下一个路由器），路由器（有IP协议表（即路由表），根据IP头部的信息查出下一个路由器地址和MAC头部地址(通过ARP查询对应的MAC地址)，并改写MAC头部）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[像素和viewport]]></title>
      <url>%2F2018%2F03%2F26%2F%E5%83%8F%E7%B4%A0%E5%92%8Cviewport%2F</url>
      <content type="text"><![CDATA[三种像素的概念 css像素：在写样式代码的时候使用到的逻辑像素，是一个抽象的概念，实际并不存在 设备独立像素（dip）：独立于设备的用于逻辑上衡量像素的单位，是一个总体概念，包括了css像素 设备像素：物理像素，设备能控制显示的最小单位 12在pc端100%未缩放的情况下，一个设备独立像素 = 1个设备像素如果放大到200%，那么可以说一个设备独立像素 = 2个设备像素（1个虚拟像素实际上占用了电脑屏幕的2个物理像素） ppi和dpr的概念 ppi：屏幕像素密度。即每英寸像素数，即在一个对角线长度为1英寸的正方形内所拥有的像素数，并非没英寸面积 dpr：设备像素比，设备像素/设备独立像素，在js中可以通过window.devicePixelRatio 来获取。 1dpr为2时，使用4（2*2）个设备像素显示1个css像素 图片缩放大小 = 图片css大小 * dpr所以我们要在非标准屏幕上以同样大小显示同一张图片时，需要缩放图片大小。 viewport1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&gt; 视觉视窗：设备的屏幕区域，用户通过屏幕所看到的页面内容，对应的是css像素，会随着页面的缩小放大而改变。 布局视窗：document.documentElement.clientWidth ，布局视窗的宽高值是在页面没添加viewport 时所获得的值，一般为980px 理想视窗：就是优化布局视窗，viewport的终极形态。 1234#理想视窗会随着设备的翻转而改变，user-scalable=yes可以防止缩放也可以翻转&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=yes&quot;&gt;# 全部禁止&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot;&gt; 各种宽高 window.screen.height/width ：表示的是设备独立像素！比如ip6（分辨率为1334*750），但是用这个属性测出来的是375*667。乘以设备像素比dpr正好是分辨率的值。 window.innerHeight/innerWidth ：屏幕可视宽高，包含了滚动条的宽高 window.outerHeight ： document.documentElement.clientWidth/clientHeight ：屏幕可视区域宽高，不包括滚动条和工具条，和$(window).width() 结果一样 document.body.clientWidth element.offsetWidth/Height ：本身宽高+padding+滚动条+border element.offsetTop/offsetLeft ：相对位置 element.scrollWidth/scrollHeight ：包含溢出内容的尺寸 element.scrollTop/scrollLeft]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gif、jpg、png图像的区别]]></title>
      <url>%2F2018%2F03%2F25%2Fgif%E3%80%81jpg%E3%80%81png%E5%90%84%E7%A7%8D%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[索引色&amp;直接色 索引色（Index Color）：用一个数字来代表一种颜色，存储图片的时候，存储一个数字的组合，同时存储数字到颜色的映射。这种只能存储有限种颜色，256色。 直接色（Direct Color）：使用四个数字代表一种颜色，分别是红、绿、蓝、透明度。可以表示2的32次方种颜色（grba表示） 点阵图&amp;矢量图 点阵图：构成点阵图的最小单位是像素。每个像素都有自己的颜色信息。在对点阵图缩放时会失真。 矢量图：记录的是元素形状和颜色的算法，并将运算结果呈现出来。无论缩放与否，对应的图像的算法是不变的。所以对矢量图缩放时不会失真。 gif是无损的采用索引色的点阵图。适用于企业logo，线条绘制等（对颜色不高，体积小的场景） 优点：用gif格式保存图片不会降低图片质量 ​ 支持动图和透明度 缺点：只支持 8bit的索引色，只能存储256种不同的颜色 jpeg一种有损压缩的采用直接色的点阵图。 优点：采用直接色，有丰富的色彩，适合存储颜色丰富的照片 缺点：在不影响人类可分辨图片质量的前提下，尽可能地压缩文件大小。因此在压缩的过程中图像的质量会遭到破坏。不适用于线条绘制，文字或者图标（png和gif适合） png-8是png的索引色版本。无损的使用索引色的点阵图 优点：是gif格式的替代者，在相同的图片效果下，比gif提及更小 ​ 支持透明度的调节 缺点：动画浏览器支持得没有gif好 png-24是png的直接色版本。无损的使用直接色的点阵图 优点：色彩更全，支持透明度 缺点：提及比jpg，gif，png-8都要大，是jpg大小的5倍，但是显示效果提升不明显。 svg是无损的矢量图，适合用来绘制企业logo和icon等。 优点：可以方便地修改svg图片]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[了解es6之模块化，以及模块化的历史进程]]></title>
      <url>%2F2017%2F10%2F20%2F%E6%A8%A1%E5%9D%97%E5%8C%96es6%2F</url>
      <content type="text"><![CDATA[#####ES6模块 ES6模块自动采用严格模式，通过export命令显示指定输出代码，再通过import命令输入。 export输出命令：export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 1234567//profile.jsexport var name = &apos;tom&apos;export var age = 18---------推荐以下这种写法var name =&apos;tom&apos;var age =18export &#123;name,age&#125; 1234567891011#对外输出函数fnexport function fn(x,y)&#123; return x+y&#125;---------或者function fn(x,y)&#123; return x+y&#125;export &#123;fn&#125;#重命名export &#123;fn as m&#125; import 命令: 具体提升效果，会提升到整个模块的头部 1234//main.jsimport&#123;name,age&#125; from &apos;./profile.js&apos; //js后缀可以省略-----------也可以重命名import &#123;name as firstName&#125; from &apos;./profile&apos; 模块整体加载 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 1234567891011121314//circle.jsfunction area(radius)&#123; return Math.PI * radius * radius&#125;function circumference(radius)&#123; return 2*Math.PI * radius&#125;export&#123;area,circumference&#125;------------------import&#123;area,circumference&#125; form &apos;./circle&apos;console.log(area(2))--或者import * as circle from &apos;./circle&apos; 用*指定一个对象，可以用重命名的circle.xxx来调用属性或者方法console.log(&apos;面积：&apos;+ circle.area(2)) export default：为模块指定默认输出，不需要知道对外输出的变量名或者函数名，用import引入的时候重命名就行。 注：一个模块只能有一个默认输出，所以export default只能使用1次 12345678//export-default.jsexport default function()&#123; console.log(&apos;fuck&apos;)&#125; //默认输出一个函数，其他模块加载时，可以为改匿名函数指定任意名字----------------// import-default.jsimport customName from &apos;./export-default&apos;customName() // &apos;fuck&apos; customName就是上面那个函数名。此时import不需要&#123;&#125;了！！ 123456非匿名函数也可以用export default来输出，但是在其他模块加载的时候，视同匿名函数加载//fn.jsexport default function fn()&#123; //...&#125;import fn from &apos;./fn.js&apos; export 和 import的复合写法 在一个模块中，先输入后输出同一个模块，可以用以下写法export{} from ‘’ 1234567891011export &#123;foo,bar&#125; from &apos;myModule&apos;等同于import &#123;foo,bar&#125; from &apos;myModule&apos;export &#123;foo,bar&#125;-------------------整体输出：export * from &apos;myModule&apos;-------------------默认接口写法：export &#123;default&#125; from &apos;myModule&apos;具名接口改为默认接口：export &#123;foo as default&#125; from &apos;myModule&apos;等同于 import &#123;foo&#125; from &apos;./myModule&apos; export default foo 模块在浏览器中的加载默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。 12&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt; 上面代码中，&lt;script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。 defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 浏览器加载ES6模块，也适用&lt;script&gt;标签，但是要加入type=”module”属性，加了这个属性等同于加了defer。 1&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt; 12#也可以添加async&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; async&gt;&lt;/script&gt; ES6模块和CommonJS模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。而ES6模块原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 模块化的进程 各种全局变量 12345678var $topbar = $(&apos;#topbar&apos;)$topbar.on(&apos;click&apos;,functuion()&#123; console.log(&apos;topbar&apos;)&#125;)var $banners = $(&apos;#banners&apos;)$banners.on(&apos;click&apos;,function()&#123; console.log(&apos;banners&apos;)&#125;) 用立即执行函数消除全局变量（或者用{}块级作用域+let） 12345678910111213141516171819!function()&#123; var $topbar = $(&apos;#topbar&apos;) $topbar.on(&apos;click&apos;,functuion()&#123; console.log(&apos;topbar&apos;) &#125;)&#125;() //让这些变量变成局部变量，放进一个函数里并且调用，但是函数前要加上一个符号（+,-,!等）!function()&#123; var $banners = $(&apos;#banners&apos;) $banners.on(&apos;click&apos;,functuion()&#123; console.log(&apos;banners&apos;) &#125;)&#125;()------------------&#123; let $topbar = $(&apos;#topbar&apos;) $topbar.on(&apos;click&apos;,functuion()&#123; console.log(&apos;topbar&apos;) &#125;)&#125; //或者用es6语法:块级作用域，局部变量 按照上述方法，作用域与作用域之间是隔开的，如果作用域B想使用作用域A的变量，怎么办？可以使用两个作用域都能访问到的全局变量window，作为桥梁，赋值给window属性并访问 123456789101112!function()&#123; var $topbar = $(&apos;#topbar&apos;) var user = &#123; name:&apos;yom&apos;, age:20 &#125; window.user = user //全局变量&#125;() !function()&#123; console.log(window.user)&#125;() 如果不能让别的作用域改user，只能读（暴露一个函数，不要暴露整个变量） 123456789101112131415!function()&#123; var $topbar = $(&apos;#topbar&apos;) var user = &#123; name:&apos;yom&apos;, age:20 &#125; window.user = &#123; nameGetter:function()&#123;return user.name&#125;, ageGetter:fucntion()&#123;return user.age&#125; &#125;&#125;() !function()&#123; console.log(window.user.nameGetter) //yom&#125;() 什么时候闭包：只要一个函数使用了它外面的变量，这个函数就是闭包，闭包是指这个函数以及它能访问到的这个变量。闭包是作用域的一种特殊的使用方式。 举例：年龄增长器 1234567891011function olderMaker()&#123; var user = &#123; name:&apos;jack&apos;, age:18 &#125; return function()&#123; user.age += 1 &#125;&#125;var older = olderMaker() //函数older.call() 每call一下，年龄增加一岁 require.js（固定使用window.require()与window.define()） 首先引入require.js 1&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt; 加载完require.js后，加载自己的代码，如果我们的代码主文件是main.js，那么需要用data-main=”./main”来引入（data-main属性的作用是，指定网页程序的主模块。） 1&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; 主模块的写法，需要使用AMD规范定义的require()函数。 function里的参数可以是任何命名，但是参数是按照顺序的 123456//main.jsrequire([&apos;./moduleA&apos;,&apos;moduleB&apos;,&apos;moduleC&apos;],function(moduleA, moduleB, moduleC)&#123; some code here&#125;)//require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，并且参数是按照模块顺序的！！ 1234567891011121314151617require.config(&#123; paths: &#123; &quot;jquery&quot;: &quot;lib/jquery.min&quot;, &quot;underscore&quot;: &quot;lib/underscore.min&quot;, &quot;backbone&quot;: &quot;lib/backbone.min&quot; &#125; &#125;);//使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。---------------------or直接改变基目录（baseUrl）。require.config(&#123; baseUrl:&apos;js/lib&apos;, paths:&#123; &quot;jquery&quot;: &quot;jquery.min&quot;, &quot;underscore&quot;: &quot;underscore.min&quot;, &quot;backbone&quot;: &quot;backbone.min&quot; &#125;&#125;) 假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写 1234567891011121314// math.js define(function()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;; &#125;)加载方法如下： // main.js require([&apos;math&apos;], function (math)&#123; alert(math.add(1,1)); &#125;); 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。 define([‘myLib’], function(myLib){ function foo(){ myLib.doSomething(); } return { foo : foo }; }); 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。 举例 1234567891011121314151617181920212223242526272829303132333435363738394041index.htmlrequire.jsmain.js ......topbar.js ......banners.js ......slides.js .......plugin.jsindex.html：&lt;script src=&quot;./require.js&quot; data-main=&quot;./main&quot;&gt;&lt;script/&gt; //data-main=&quot;&quot; 路径plugin.js:-----------define(function()&#123; console.log(&apos;this is plugin&apos;) function aaa()&#123; console.log(&apos;bbb&apos;) &#125; return aaa&#125;)banners.js:----------define(functuon()&#123; console.log(&apos;banners&apos;)&#125;)topbar.js:------------define([‘./plugin’],function(plugin)&#123; console.log(&apos;topbar&apos;) console.log(aaa)&#125;)slides.js:----------define([‘./plugin’],function(plugin)&#123; console.log(&apos;slides&apos;) aaa()&#125;)main.js:-----------require([&apos;./slides&apos;,&apos;./banners&apos;,&apos;./topbar&apos;],function()&#123; console.log(&apos;main is runned&apos;)&#125;) 加载顺序：1. 先加在没有依赖的模块js ​ 2.再加载子模块依赖的plugin模块 ​ 3.最后加载main.js主文件 common.js暴露：exports.xxx={} / module.exports={} ，接收：let 变量=require(&#39;./xxx&#39;) 1234567891011121314151617//适用于node.js,不适用于浏览器的异步ModuleA.js: exports.xxx=&#123; ／／暴露一个变量 name:&apos;Tom&apos;&#125;---------------index.jslet a = require(&apos;./MoudleA&apos;)console.log(a)//&#123;xxx:&#123;name:&apos;Tom&apos;&#125;&#125; 得到一个xxx属性的对象，相当于a=exports等价于-----------module.exports=&#123; xxx:&#123; name:&apos;Tom&apos; &#125;&#125; 注：如果ModuleA.js中只想暴露name，不像暴露xxx，不能写成这样 1234567891011exports=&#123; name:&apos;Jack&apos;&#125;//index.js运行的结果是空对象&#123;&#125;//这是因为默认module.exports=&#123;&#125;，标准写法是exports.xxx=yyy,表示在这个空对象里加属性，但是如果直接像上面那样写exports=&#123;xxx:yyy&#125;，表示另外一块内存，原先的module.exports=&#123;&#125;不变module.exports=&#123; name:&apos;jack&apos;&#125;或者exports.name=&apos;jack&apos; AMD（异步模块定义）require.js ES Modules12345678910//使用模块import &#123;* as a&#125; from &apos;./ModuleA&apos;console.log(a.xxx)console.log(a.yyy)//暴露let xxx=&#123;&#125;export xxxlet yyy=&#123;&#125;export yyy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[了解es6之Generator函数]]></title>
      <url>%2F2017%2F10%2F14%2FGenerator%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[基本概念Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 (Generator 生产者，yield产出) 特征： function关键字与函数名之间有一个星号 ​ 函数体内部使用yield表达式，定义不同的内部状态 123456789101112131415161718192021222324function* fn()&#123; //定义了3个状态hello，world，和ending（结束执行） yield &apos;hello&apos; yield &apos;world&apos; return &apos;ending&apos;&#125;-----------fn() //返回的是遍历器对象Iterator Object，并不会执行函数，必须调用next函数，开始执行第一个yield表达式，next()方法返回一个对象。value属性表示yield表达式的值，done表示是否完成了遍历fn().next() //&#123;value: &quot;hello&quot;, done: false&#125;fn().next() //&#123;value: &quot;world&quot;, done: false&#125;需要重新声明赋值给一个变量var a=fn()a.next() // &#123; value: &apos;hello&apos;, done: false &#125; a.next() // &#123; value: &apos;world&apos;, done: false &#125;a.next() // &#123; value: &apos;ending&apos;, done: true &#125;a.next() // &#123; value: undefined, done: true &#125;----------------或者var a=(function* ()&#123; yield &apos;hello&apos; yield &apos;world&apos; return &apos;ending&apos;&#125;)()a.next() //&#123;value: &quot;hello&quot;, done: false&#125;a.next() //&#123;value: &quot;world&quot;, done: false&#125; yield表达式： 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志 。 yield只能在Generator函数里面有效 yield没有返回值，或者总是返回undefined，next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。(所以第一次使用next()方法传递参数是无效的，因为他表示的是上一个yield表达式的返回值) 1234567891011121314function* foo()&#123; var y = 2*(yield(x+1)) var z= yield(y/3) return (x+y+3)&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125; //返回yield后面式子的值a.next() // Object&#123;value:NaN, done:false&#125; //第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN）a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 1234567function* demo() &#123; console.log(&apos;Hello&apos; + yield); // SyntaxError console.log(&apos;Hello&apos; + yield 123); // SyntaxError console.log(&apos;Hello&apos; + (yield)); // OK console.log(&apos;Hello&apos; + (yield 123)); // OK&#125; yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。 1234function* demo() &#123; foo(yield &apos;a&apos;, yield &apos;b&apos;); // OK let input = yield; // OK&#125; 123456789function* f() &#123; console.log(&apos;执行了！&apos;) Generator函数不用yield表达式，变成了暂缓执行函数&#125;var generator = f() //一般函数到这一步赋值就会执行setTimeout(function () &#123; generator.next()&#125;, 2000); 从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。 1234567891011121314function* inner() &#123; yield &apos;hello!&apos;;&#125;function* outer1() &#123; yield &apos;open&apos;; yield inner(); yield &apos;close&apos;;&#125;var gen = outer1()gen.next().value // &quot;open&quot;gen.next().value // 返回一个遍历器对象gen.next().value // &quot;close&quot; 如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。 123456function* gen()&#123; yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];&#125;var a = gen()a.next() //&#123;value: &quot;a&quot;, done: false&#125;a.next() //&#123;value: &quot;b&quot;, done: false&#125; 实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。 1234567let read = (function* () &#123; yield &apos;hello&apos;; yield* &apos;hello&apos;;&#125;)();read.next().value // &quot;hello&quot;read.next().value // &quot;h&quot; ​ for…of循环for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。 1234567891011121314function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5上面代码使用for...of循环，依次显示5个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。 12345678910111213141516171819202122232425除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2// for...of 循环for (let n of numbers()) &#123; console.log(n)&#125;// 1// 2 Generator.prototype.return可以传递参数返回给定的值，并且终结遍历Generator函数（done:flase）。 1234567891011121314function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();----------------g.next() // &#123; value: 1, done: false &#125;g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next() // &#123; value: undefined, done: true &#125;-----------------没有参数的话value为undefinedg.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; yield*表达式用来在一个Generator函数foo里调用另外一个Generator函数bar，如果bar函数有return，那么foo函数里的yield*fn()就提供了上个函数bar的返回值 12345678910111213141516171819202122232425262728293031function* foo()&#123; yield &apos;a&apos; yield &apos;b&apos;&#125;function* bar()&#123; yield &apos;c&apos; yield* foo() yield &apos;d&apos;&#125;for(let x of bar())&#123; console.log(x)&#125;//&apos;c&apos; &apos;a&apos; &apos;b&apos; &apos;d&apos;--------------function *foo() &#123; yield 2; yield 3; return &quot;foo&quot;;&#125;function *bar() &#123; yield 1; var v = yield *foo(); console.log( &quot;v: &quot; + v ); yield 4;&#125;var it = bar()it.next() // &#123;value: 1, done: false&#125;it.next() // &#123;value: 2, done: false&#125;it.next() // &#123;value: 3, done: false&#125;it.next() // &quot;v: foo&quot; &#123;value: 4, done: false&#125;it.next() // &#123;value: undefined, done: true&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[了解Promise]]></title>
      <url>%2F2017%2F09%2F10%2FPromise%2F</url>
      <content type="text"><![CDATA[http://liubin.org/promises-book/ 同步回调以及异步回调回调不一定是异步过程，回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行。 形式 1234567function f1(callback) &#123; // f1 的代码 // f1 执行完成后，调用回调函数 callback();&#125;-------------执行代码变成如下f1(f2) 同步回调 12345678function f1(callback)&#123;console.log(&apos;f1&apos;)f2() //调用f2函数并执行&#125;function f2()&#123;console.log(&apos;f2&apos;)&#125;f1(f2) // f1 f2 异步回调 12345678910111213141516171819202122function f1(callback)&#123; setTimeout(function()&#123; console.log(&apos;f1&apos;) callback() &#125;,2000)&#125;function f2()&#123; console.log(&apos;f2&apos;)&#125;f1(f2) //f1 f2------------如果不采用回调，输出结果为f2 f1fucntion f1()&#123; setTimeout(function()&#123; console.log(&apos;f1&apos;) &#125;,2000)&#125;function f2()&#123; console.log(&apos;f2&apos;)&#125;f1()f2()// f2 (两秒后)f1 Promise 它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。 Promise接口的基本思想是，异步任务返回一个Promise对象。 Promise对象只有三种状态。 异步操作“未完成”（pending） 异步操作“已完成”（resolved，又称fulfilled） 异步操作“失败”（rejected） 这三种的状态的变化途径只有两种。 异步操作从“未完成”到“已完成” 异步操作从“未完成”到“失败”。 这种变化只能发生一次，一旦当前状态变为“已完成”或“失败”，就意味着不会再有新的状态变化了。因此，Promise对象的最终结果只有两种。 异步操作成功，Promise对象传回一个值，状态变为resolved。 异步操作失败，Promise对象抛出一个错误，状态变为rejected。 Promise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时（变为resolved状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。 then方法可以链式使用。 12345678po .then(step1) .then(step2) .then(step3) .then( console.log, console.error ); 上面代码中，po的状态一旦变为resolved，就依次调用后面每一个then指定的回调函数，每一步都必须等到前一步完成，才会执行。最后一个then方法的回调函数console.log和console.error，用法上有一点重要的区别。console.log只显示回调函数step3的返回值，而console.error可以显示step1、step2、step3之中任意一个发生的错误。也就是说，假定step1操作失败，抛出一个错误，这时step2和step3都不会再执行了（因为它们是操作成功的回调函数，而不是操作失败的回调函数）。Promises对象开始寻找，接下来第一个操作失败时的回调函数，在上面代码中是console.error。这就是说，Promises对象的错误有传递性。 用法 new Promise 1234567891011121314先声明生成一个Promise实例var pro = new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(&apos;2秒后done&apos;)resolve(&apos;ok&apos;,&apos;hello&apos;) //resolve这里只能接受一个参数传递出去，第二个参数没用 &#125;,2000)&#125;)然后再回调pro.then(function(val)&#123; //这里的val就是上面的第一个参数&apos;ok&apos;console.log(val+&apos;&apos;+&apos;hello&apos;)&#125;,function()&#123; console.log(&apos;error&apos;)&#125;)//ok hello Promise.resolve(value) &amp;&amp; Promise.reject() 12345678Promise.resolve(30)===等价于new Promise(function(resplve)&#123; resolve(30)&#125;)//value为空时，返回value为undefined的promise对象 value为普通对象，返回状态为resolve的promise对象，起value为传入的参数 value为promise对象，直接返回该promise对象 Promise.then Promise.then(resolved,rejected) resolved 和 rejected必须是函数，否则忽略 resolved必须在 Promise 的 Resolve 状态后调用，Promise 的 value 为其第一个参数，只能被调用一次。 rejected 必须在 Promise 的 Rejected 状态后调用，Promise 的 reason 为其第一个参数，只能被调用一次。 Promise.catch === Promise.then(undefined.rejected) Promise.all:接收一个 promise 对象的数组作为参数，返回一个新的 promise 对象，特点如下： 当数组内所有 promise 对象的状态为 Resolve，其状态才为 Resolve。 当数组内有一个 promise 对象的状态为 Rejected，其状态就为 Rejected。 12345678910111213141516171819202122232425262728293031323334// 第一种情况var promise1 = Promise.resolve(1)var promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log(33) resolve(&apos;yes&apos;) &#125;, 1000);&#125;);var promise3 = Promise.all([promise1, promise2]);promise3.then(function (val) &#123; console.log(&apos;resolve&apos;, val);&#125;, function (e) &#123; console.log(&apos;reject&apos;, e);&#125;);// 一秒后返回resolve [1, &quot;yes&quot;] 传的参数是一个数组，分别为promise1和promise2的参数。且按照最后一个值的时间一起打印！// 第二种情况var promise1 = Promise.resolve(1)promise.then(function(val)&#123;console.log(val)&#125;)var promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log(33) reject(&apos;error&apos;); &#125;, 1000);&#125;);var promise3 = Promise.all([promise1, promise2]);promise3.then(function (val) &#123; console.log(&apos;resolve&apos;, val);&#125;, function (e) &#123; console.log(&apos;reject&apos;, e);&#125;);// 1 1秒后打印33 reject error #####Promise：处理异步事件 用回调获取结果（get请求，缺点：无法获取失败的结果） 12345$.get(&apos;./data.json&apos;,function(data,statusText,xhr)&#123; console.log(data) console.log(statusText) console.log(xhr) //封装后的对象&#125;) //用jquery的get方法请求了这个路径 用ajax请求（通过回调来解决异步的流程控制） 123456789101112$.ajax(&#123; url:&apos;./data.json&apos;, method:&apos;get&apos;, success:function(data,statusText,xhr)&#123; //等价于上面get请求 console.log(data) &#125;， error:function(xhr,statusText,reason)&#123; console.log(xhr.status) ／/获取到状态码 console.log(statusText) console.log(reason) //请求失败 &#125;&#125;) 多层回调： 123456789&lt;body&gt; 用户：&lt;span id=&quot;user&quot;&gt;&lt;/span&gt; &lt;hr&gt; 分组：&lt;span id=&quot;group&quot;&gt;&lt;/span&gt; &lt;hr&gt; 其中第一个分组里面有成员：&lt;span id=&quot;group_number&quot;&gt;&lt;/span&gt; &lt;script src=&quot;./node_modules/jquery/dist/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233$.ajax(&#123; url:&apos;./user.json&apos;, method:&apos;get&apos;, success:function(data,statusText,xhr)&#123; console.log(data) $(&apos;#user&apos;).text(data.name) $.ajax(&#123; url:&apos;./group.json&apos;, method:&apos;get&apos;, success:function(data)&#123; console.log(data) $(&apos;#group&apos;).text([data[0].name,data[1].name].join(&apos;.&apos;)) $.ajax(&#123; url:&apos;./group_number.json&apos;, method:&apos;get&apos;, success:function(data)&#123; console.log(data) $(&apos;#group_number&apos;).text([data[0].name,data[1].name].join(&apos;.&apos;)) &#125;, error:function () &#123; alert(&quot;im fine,fuck you&quot;) &#125; &#125;) &#125;, error:function()&#123; alert(&quot;im fine,fuck you&quot;) &#125; &#125;) &#125;, error:function(xhr,statusText,reason)&#123; alert(&quot;im fine,fuck you&quot;) &#125;&#125;) promise的then方法，传有两个参数，一个成功，一个失败 1234567891011121314151617181920let getuserPromise = $.get(&apos;./user.json&apos;)getuserPromise.then(function(data)&#123; console.log(data) $(&apos;#user&apos;).text(data.name) let getgroupPromise = $.get(&apos;./group.json&apos;) getgroupPromise.then(function(data)&#123; console.log(data) $(&apos;#group&apos;).text([data[0].name,data[1].name].join(&apos;.&apos;)) let getgroupnumberPromise = $.get(&apos;./group_number.json&apos;) getgroupnumberPromise.then(function(data)&#123; console.log(data) $(&apos;#group_number&apos;).text([data[0].name,data[1].name].join(&apos;.&apos;)) &#125;,function()&#123; alert(&quot;im fine,fuck you&quot;) &#125;) &#125;,function()&#123; alert(&quot;im fine,fuck you&quot;) &#125;)&#125;,function()&#123; alert(&quot;im fine,fuck you&quot;)&#125;) 一个简单的异步摇骰子过程 1234567891011121314151617function number(callback)&#123; setTimeout(function()&#123; console.log(&apos;start&apos;) let random = Math.random() console.log(random) if(random&gt;0.5)&#123; callback(&apos;big&apos;) return(&apos;big&apos;) &#125;else&#123; callback(&apos;small&apos;) return(&apos;small&apos;) &#125; &#125;,1000)&#125;let result = number(function(data)&#123; console.log(data)&#125;) return new Promise(function(resolve, reject){}) //Promise里面一定是一个函数，这个函数一定会有两个参数，resolve和reject 123456789var a = new Promise(function(resolve,reject)&#123; console.log(1) resolve()&#125;)a.then(function()&#123; console.log(2)&#125;)console.log(3)//打印顺序：1，3，2 给promise传一个函数，会立即执行这个函数打印出1，promise回调会走完流程后再去执行，尽管它没有任何延迟立即执行成功，也会先打印出3，再去打印2 以上执行顺序是：1、5、2、3、6、4、7 promise里面的函数会立即执行，但是then之后的函数会在下一次的循环中执行。 #####小结 优点：避免了层层嵌套的回调函数，也让异步操作更加容易。 缺点：一旦建立Promise就会立即执行，中途无法取消 \ 如果不设置回调函数，Promise内部抛出的错误不会反应到外部 \ 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[到底什么是函数执行环境]]></title>
      <url>%2F2017%2F09%2F02%2F%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[一个函数被执行时，会创建一个执行上下文环境，函数的所有行为均发生在此执行环境中，构建执行环境时： 先创建arguments变量，包括调用函数时传入的参数 接着创建作用域链，然后初始化变量。 先是arguments变量，有值得赋值，没有的初始化为undefined 然后是函数内的局部变量，初始化为undefined，赋值的操作在执行环境创建成功后，函数执行时才会执行 最后为this赋值，根据函数调用方式的不同进行赋值 函数执行环境创建成功，函数开始逐行执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中数组方法小结]]></title>
      <url>%2F2017%2F08%2F16%2Farray%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Array.isArray()判断是不是数组的方法 123var a = [1, 2, 3];typeof a // &quot;object&quot; typeof运算符只能显示数组的类型是ObjectArray.isArray(a) // true toString()把数组返回字符串 123var a =[1,2,3]a.toString()//&apos;1,2&apos; push() &amp; unshift()语法：arr.push(element1, …, elementN) // arr.unshift(element1,……elementN) 参数：被添加到数组尾部的元素 返回值：新的length长度！（该方法会改变原数组） 1234567var a =[1,2,3]var b =[4,5,6]var c = Array.prototype.push.apply(a,b) 合并两个数组，也可以用a.concat(b)方法= a.push.apply(a,b)= a.push(4,5,6)a // [1,2,3,4,5,6]c // 6 (返回的是新数组的长度) pop() &amp; shift()语法：arr.pop() 不接受参数 （改变原数组的长度length） 返回值：数组中被移除的值 （空数组返回undefined） 12345var a =[1,2,3]var b = a.pop()a // [1,2]a.length // 2b //3 12345#数组末尾添加内容&amp;数组前增加内容var a = [1,2,3,4]a[a.length] = &apos;tom&apos; //速度最快,但改变原数组，只能是一个-------------var b = [&apos;jack&apos;,123].concat(a) //速度最快，不改变原数组 join() join() 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。 语法：str = arr.join() ; str = arr.join(“”) ; str = arr.join(separator) 返回值：字符串 （不会改变原数组！） 1234567891011121314var a = [1,2,3]var b = a.join()var c = a.join(&quot;&quot;)var d = a,join(&quot;c&quot;)------b// &quot;1,2,3&quot; 默认为逗号c // &quot;123&quot;d // &quot;1c2c3&quot;------------如果是undefined,null,或者空位，转换成空字符串[&apos;a&apos;,, &apos;b&apos;].join(&apos;-&apos;)// &apos;a--b&apos;--------------Array.protptype.jion.call()可以用于字符串或者类数组Array.prototype.join.call(&apos;sdf&apos;,&apos;#&apos;) //&apos;s#d#f&apos; concat() concat() 方法用于合并两个或多个数组。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。 语法：var new_array = old_array.concat(value1[, value2[, …[, valueN]]]) 参数：需要与原数组合并的数组或非数组值(可以是对象）。 返回值：新数组（原数组不变） 123456var array1=[1,2,3]var array2=[4,5,6]var array3=[7,8,9]var nums = array1.concat(array2,array3,5,[12,13])console.log(nums)// [1,2,3,4,5,6,7,8,9,5,12,13] concat()方法也可以用于将对象合并为数组，但是必须借助call方法。 12345678[].concat.call(&#123;a: 1&#125;, &#123;b: 2&#125;) 这里是空数组,用call的时候不加()!!!// [&#123; a: 1 &#125;, &#123; b: 2 &#125;][].concat.call(&#123;a: 1&#125;, [2])// [&#123;a: 1&#125;, 2][2].concat(&#123;a: 1&#125;) 这里不需要call// [2, &#123;a: 1&#125;] 1234var arr1 = [&apos;two&apos;, &apos;three&apos;];var arr2 = [&apos;one&apos;, ...arr1, &apos;four&apos;, &apos;five&apos;];// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;] reverse() reverse方法用于颠倒数组中元素的顺序，返回改变后的数组。注意，该方法将改变原数组。 返回值：颠倒后的数组 （原来数组会改变） 123var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.reverse() // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]a // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;] slice() slice()方法用于提取原数组的一部分，返回一个新数组，原数组不变。 语法：arr.slice() // arr.slice(begin) // arr.slice(begin,end) 参数：index，可以是负数，数组最后一个数值为-1开始 返回值：提取出来的新数组 ，原数组不变 注：它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。 12345var a =[1,2,3,4]a.slice() // [1,2,3,4]a.slice(1) //[2,3,4]a.slice(-3,-1) //[2,3]a.slice（-3,0） //[] 如果参数大小出错，就会返回空集 splice() splice()方法通过删除现有元素和/或添加新元素来更改一个数组的内容。（原来数组会改变） 语法：array.splice(start) // array.splice(start, deleteCount) // array.splice(start, deleteCount, item1, item2, …) 参数：start，deleteCount，item（添加的内容，添加到start前面 ） 返回值：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。 123456789var a =[1,2,3,4,5,6]var b =a.splice(2,0,&apos;tom&apos;)a // [1,2,&apos;tom&apos;,3,4,5,6] 从2位置删除0个，添加了&apos;tom&apos;b // [] 被删除0个，所以是空集----------------var c = [1,2,3,4,5]var d = c.splice(3,2,&apos;jack&apos;)c // [1,2,3,&apos;jacl&apos;]d // [4,5] 123456#从数组中指定位置插入数组,用扩展运算符...来运算var arr1 = [1,2,3,4,5,6]var arr2 = [&apos;tom&apos;,&apos;jack&apos;]arr1.splice(1,0,...arrs)arr1 // [1, &quot;tom&quot;, &quot;jack&quot;, 2, 3, 4, 5, 6]arr2 // [&quot;tom&quot;, &quot;jack&quot;] sort() sort()`方法在适当的位置对数组的元素进行排序，并返回排序后的数组。 语法：arr.sort() 元素按照转换为的字符串的诸个字符的Unicode位点进行排序 ​ arr.sort(compareFunction) comparFunction接受两个参数a，b进行比较，如果返回值&lt;0，a在b之前；返回值=0，位置不变；返回值大于0，b在a前面 返回值：排序后的数组 （原数组改变） 123456789101112131415161718192021222324252627升序排列var nums = [3,5,1,4,8]var a = nums.sort(function(a,b)&#123; return a-b&#125;)console.log(nums) //[1, 3, 4, 5, 8]console.log(a) //[1, 3, 4, 5, 8]--------------对象按照某个属性排列var items = [ &#123;name:&apos;tom1&apos;,age:21&#125;, &#123;name:&apos;tom2&apos;,age:43&#125;, &#123;name:&apos;tom3&apos;,age:15&#125;, &#123;name:&apos;tom4&apos;,age:18&#125;, &#123;name:&apos;tom5&apos;,age:50&#125;,]items.sort(function(a,b)&#123; return a.age - b.age&#125;)console.log(items)// [ &#123;name:&apos;tom3&apos;,age:15&#125;, &#123;name:&apos;tom4&apos;,age:18&#125;, &#123;name:&apos;tom1&apos;,age:21&#125;, &#123;name:&apos;tom2&apos;,age:43&#125;, &#123;name:&apos;tom5&apos;,age:50&#125;,] map()（目的是遍历数组并返回一个新数组） map()方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。 语法： 123let array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array &#125;[, thisArg]) 参数：currentValue：当前成员 / index 位置索引 / array 数组本身 返回值：一个新数组，每个元素都是回调函数的结果 （不改变原数组） 可用于字符串 123用于字符串，用call,而且map后面不加()Array.prototype.map.call(str,function(x)&#123;&#125;)或者[].map.call(str,function(x)&#123;&#125;) forEach()（目的是遍历元素执行某个操作） forEach() 方法对数组的每个元素执行一次提供的函数。 语法： 123array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, this) 参数：和map一致 返回值：undefined 注意和map的区别 注：forEach()方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 forEach()方法不会跳过undefined和null，但会跳过空位。 filter()(用来筛选) filter() 方法把返回结果为true的成员组成一个新数组返回。 语法：var new_array = arr.filter(callback[, thisArg]) 参数：callback接受三个参数（类似map()，forEach()），currentValue：当前成员 / index 位置索引 / array 数组本身 返回值：一个新的通过测试的元素的集合的数组（不改变原数组） 123456var a = [1,3,5,7,9]var b = a.filter(function(nums)&#123; return nums&gt;3&#125;)a // [1,3,5,7,9]b // [5,7,9] some() &amp; every() some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试。 some方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。 every()方法测试数组的所有元素是否都通过了指定函数的测试。 every方法则是所有数组成员的返回值都是true，才返回true，否则false。 语法：arr.some(callback[, thisArg]) ​ arr.every(callback[, thisArg]) 参数：callback接受三个参数（类似map()，forEach()，filter()） 返回值：布尔值 （不改变原数组） reduce() &amp; reduceRight() reduce()方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。 语法：array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue) 参数(前两个必须）：accumulator：初始值(默认第一个)，或者提供的初始值initialValue ​ currentValue：正在处理的元素（如果没有设置初始值initialValue，则从index=1开始，如果设置了，从index=0开始） ​ currentIndex：索引 ​ array：原数组 ​ initialValue：其值用于第一次调用 callback 的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。 返回值：函数累计处理的结果 (原数组不变) 数组累加和 1234567891011121314var a=[1,2,3,4,5]var b=a.reduce(function(x,y)&#123; console.log(x,y) return (x+y)&#125;)//1,2 3,3 6,4 10,5 15-----------var c=a.reduce(function(x,y)&#123; return(x+y)&#125;,10) indexOf() &amp; lastIndexOf() indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 语法：arr.indexOf(searchElement) / arr.indexOf(searchElement[, fromIndex = 0]) 返回值：首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1 123456var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.indexOf(&apos;b&apos;) // 1a.indexOf(&apos;y&apos;) // -1-----------判断这个元素是不是在数组里if（b.indexOf(a) === -1） 扩展运算符… 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 传递一个数组作为参数 123456function test(x,y,z)&#123; console.log(x+y+z)&#125;var args=[1,2,3]test(...args)//6 合并数组（也可以用concat()，或者split()，push()，unshift()） 1234567891011var arr1=[1,2,3]var arr2=[7,8,9]------var arr = arr1.concat(arr2)//arr [1,2,3,7,8,9]------var arr=[...arr2,&apos;tom&apos;,...arr1,&apos;jack&apos;]//[7,8,9,&apos;tom&apos;,1,2,3,&apos;jack&apos;]-----------var arr4 = arr1.push(...arr2) or/arr1.push.apply(arr1，arr2)//[1,2,3,7,8,9] 拷贝数组（也可以用arr.slice()） 12var arr1 =[1,2,3]var arr2=[...arr1] 求数组的最大值 123var arr=[1,2,3,54,65,7]Math.max(...arr) === Math.max.apply(null,arr)//65 将字符串转为数组 123456[...&apos;hello&apos;]//[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]-------------&quot;hello&quot;.split(&quot;&quot;) //[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]------------Array.from(&apos;tom&apos;) // [&quot;t&quot;,&quot;o&quot;,&quot;m&quot;] Array.from() 从一个类似数组或可迭代的对象中创建一个新的数组实例。只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。 语法：Array.from(arrayLike[, mapFn[, thisArg]]) 参数：arrayLike :想要转换成真实数组的类数组对象或可遍历对象。 ​ mapFn :可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。 ​ thisArg :可选参数，执行 mapFn 函数时 this 的值。 字符串 12Array.from(&apos;tom&apos;)//[&quot;t&quot;,&quot;o&quot;,&quot;m&quot;] 类似[...&apos;tom&apos;] DOM操作返回的NodeList集合 1234let p = document.querySelectorAll(&apos;p&apos;);Array.from(p).forEach(function (p) &#123; console.log(p);&#125;); 函数内部的arguments对象 1234function foo()&#123; var args=Array.from(arguments) ......&#125; Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组. 12345Array.from(&#123; &apos;1&apos;:&apos;sdf&apos;,&apos;2&apos;:&apos;sdf&apos;,length: 4 &#125;)//[undefined, &quot;sdf&quot;, &quot;sdf&quot;, undefined]-------------Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456789Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9]------------------Array.from([1,,2,,3],(n)=&gt;n||0) 把布尔值为false转为0[1,0,2,0,3] Array.of()Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 1234Array.of() // [] 没有参数就返回一个空数组Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] copyWithin() copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。 注：返回一个新的数组，（改变原数组，但是不改变原数组长度） 参数可以是负数，-1表示数组最后一个数 12[1,2,3,4,5,6].copyWithin(1,3,4)//[1,4,3,4,5,6] //3,4表示不包括4号位！！ find() &amp; findIndex()find()方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined 语法：arr.find(callback[, thisArg]) ，它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 参数：参数的回调函数接受三个参数，（element , index , array） 123456[1,34,12,5].find((value,index,array)=&gt;value &gt; 9) es6的语法不用return，不然出错！！-------[1,34,12,5].find(function(value,index,array)&#123; return value&gt;9&#125;)//34 123456[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0注意：Object.is(value1,value2)这个方法用来确定两个值是否相同！！ fill()fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。（可以替换数组里的值） 语法：arr.fill(value, start, end) （具体要填充的元素区间是 [start, end) , 一个半开半闭区间） 返回值：修改后的数组 1234[1, 2, 3].fill(4) // [4, 4, 4]Array(3).fill(4); // [4, 4, 4][1, 2, 3].fill(4, 1, 1) // [1, 2, 3] 这样选不到任何一个位置[1, 2, 3].fill(4, 1, 2) // [1, 4, 3] keys() , values() , entries()用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 123456789101112131415161718192021222324252627282930var arr = [&quot;a&quot;, , &quot;c&quot;];var sparseKeys = Object.keys(arr);var denseKeys = [...arr.keys()];console.log(sparseKeys); // [&apos;0&apos;, &apos;2&apos;]console.log(denseKeys); // [0, 1, 2]---------------Object.keys(obj)数组 返回索引 var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; console.log(Object.keys(arr)); // console: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]对象返回键名var obj = &#123;&apos;a&apos;:&apos;123&apos;,&apos;b&apos;:&apos;345&apos;&#125;;console.log(Object.keys(obj)); //[&apos;a&apos;,&apos;b&apos;]var obj1 = &#123; 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot;&#125;;console.log(Object.keys(obj1)); // console: [&quot;2&quot;, &quot;7&quot;, &quot;100&quot;] 注意这里是自动排序的！字符串，返回索引的数组var str = &apos;ab1234&apos;;console.log(Object.keys(obj)); //[0,1,2,3,4,5]构造函数 返回空数组或者属性名 function Pasta(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; this.toString = function () &#123; return (this.name + &quot;, &quot; + this.age + &quot;, &quot; + this.gender); &#125; &#125; console.log(Object.keys(Pasta)); //console: [] var spaghetti = new Pasta(&quot;Tom&quot;, 20, &quot;male&quot;); console.log(Object.keys(spaghetti)); //console: [&quot;name&quot;, &quot;age&quot;, &quot;gender&quot;, &quot;toString&quot;] includes()和字符串的方法类似语法：arr.includes(searchElement, fromIndex) 1234[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 可以判断NaN是否在数组里，但是indexOf不行对比 [NaN].indexOf(NaN) // -1 实战：数组去重]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM小结]]></title>
      <url>%2F2017%2F08%2F07%2FDOM%2F</url>
      <content type="text"><![CDATA[####节点的属性 Node.textContentNode.textContent 返回当前节点和所有后代节点的文本内容，会忽略HTML标签 123&lt;div id=&quot;x&quot;&gt;Tom is a &lt;span&gt;handsome&lt;/span&gt; boy!&lt;/div&gt;----document.getElementById(&apos;x&apos;).textContent //Tom is a handsome boy! 这里包含了子节点span！ Node.baseURINode.baseURI 返回一个字符串，表示当前网页的绝对路径，如果无法取到这个值，返回null 1234// 当前网页的网址为// http://www.example.com/index.htmldocument.baseURI// &quot;http://www.example.com/index.html&quot; #####Node.ownerDocument Node.ownerDocument 返回当前节点所在的顶层文档对象。document 对象的ownerDocument属相，返回null。 Node.nextSibling &amp;&amp; Node.previousSibling / Element.nextElementSibling &amp; Element.previousElementSiblingNode.nextSibling 返回后面的第一个兄弟节点，如果没有则返回null，包括文本节点。 区别Element.nextElementSibling属性返回当前HTML元素节点的后一个同级HTML元素节点，如果没有则返回null。 注：该属性包括文本节点和评论节点，所以当前节点后面有空格的话，会返回一个文本节点，内容为空格。！！ 12345// html代码如下// &lt;a&gt;&lt;b1 id=&quot;b1&quot;/&gt;&lt;b2 id=&quot;b2&quot;/&gt;&lt;/a&gt;document.getElementById(&quot;b1&quot;).previousSibling // nulldocument.getElementById(&quot;b2&quot;).previousSibling.id // &quot;b1&quot; Node.parentNode返回当前节点的父节点。document的父节点为null。 #####Node.parentElement 返回当前节点的父Element节点。如果当前节点没有父节点，或者父节点类型不是Element节点，则返回null Node.childNodes &amp;&amp; Element.children 返回一个NodeList集合，成员包括当前节点的所有子节点。由于NodeList对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。 注：包含了text节点和comment节点 123456789&lt;body&gt;&lt;ul id=&quot;x&quot;&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;12344&lt;/li&gt; &lt;li&gt;432&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;------------document.getElementById(&apos;x&apos;).childNodes //[text, li, text, li, text, li, text] 包含了回车 返回一个包含当前元素节点的所有子元素HTMLCollection对象，它只包含HTML元素类型，不包含其他类型的子节点。 Node.firstChild &amp;&amp; Node.lastChild / Element.firstElementChild &amp; Element.lastElementChild返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null，包括文本节点 。 然而Element.firstElementChild 返回的是第一个HTML节点，不包括文本节点。 1234567891011121314151617&lt;p id=&quot;para-01&quot;&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; console.log( document.getElementById(&apos;para-01&apos;).firstChild.nodeName ) // &quot;span&quot;&lt;/script&gt;--------------&lt;p id=&quot;para-01&quot;&gt; &lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; console.log( document.getElementById(&apos;para-01&apos;).firstChild.nodeName ) // &quot;#text&quot;&lt;/script&gt; 节点的方法Node.appendChild()方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。 12var p = document.createElement(&apos;p&apos;)document.appendChild(p) *如果参数节点是DOM中已经存在的节点，appendChild方法会将其从原来的位置，移动到新位置。 Node.hasChildNodes() &amp;&amp; Node.contains()返回一个布尔值，表示当前节点是否有子节点。 返回一个布尔值，表示参数节点是否为当前节点的后代节点。(自身节点返回true nodeA.contains(nodeA)) Node.cloneNode()用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点，默认是false 。 需要注意的是，克隆一个节点，会拷贝该节点的所有属性，但是会丧失addEventListener方法。也会克隆两个有相同ID属性的HTML元素。 Node.insertBefore()Node.insertBefore在当前节点的某个子节点之前再插入一个子节点。返回被插入的新节点。 语法：var insertedElement = parentElement.insertBefore(newElement, referenceElement); 如果referenceElement为null则newElement将被插入到子节点的末尾。如果newElement已经在DOM树中，newElement首先会从DOM树中移除。 insertedElement 是被插入的节点，即 newElement parentElement 是新插入节点的父节点 newElement 是被插入的节点 referenceElement 在插入newElement之前的那个节点 123456789101112&lt;div&gt; &lt;span id=&quot;childElement&quot;&gt;foo bar&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var sp1 = document.createElement(&quot;span&quot;);var sp2 = document.getElementById(&quot;childElement&quot;);sp2.parentNode.insertBefore(sp1, sp2);&lt;/script&gt;--------------#如果要sp1 插入到 sp2 后面parentDiv.insertBefore(sp1, sp2.nextSibling) Node.removeChild()接受一个子节点作为参数，用于从当前节点移除该子节点。它返回被移除的子节点。 12345移除当前所有的子节点var element=document.getElementById(&apos;div&apos;)while(element.firstChild)&#123; element.removeChild(element.firstChild)&#125; Node.replaceChild()语法：replacedNode = parentNode.replaceChild(newChild, oldChild) 1234var divA = document.getElementById(&apos;A&apos;)var newSpan = document.createElement(&apos;span&apos;)newSpan.textContent = &apos;Hello World!&apos;divA.parentNode.replaceChild(newSpan, divA) Document节点 document.links 属性返回当前文档所有设定了href属性的a及area元素。 document.forms 属性返回页面中所有表单元素form。 document.images 属性返回页面所有图片元素（即img标签）。 注：如果一个元素有id或name属性，就可以直接引用。 1234&lt;a href=&quot;www.baidu.com&quot; id=&quot;a&quot;&gt;1&lt;/a&gt;&lt;a href=&quot;www.qq.com&quot; name=&quot;b&quot;&gt;2&lt;/a&gt;---------document.links.a.textContent //1 123form表单的name属性可以直接引用&lt;form name=&quot;c&quot;&gt;123&lt;/form&gt;document.c.textContent === document.forms.c.textContent //123 document.documentURI &amp;&amp; document.URL都返回一个字符串，表示当前文档的网址。documentURI属性可用于所有文档（包括 XML 文档），URL属性只能用于 HTML 文档。 还有类似的document.baseURI document.domain返回当前文档的域名 12https://www.baidu.com/s?wd=Array.split%20mdn&amp;rsv_spt=1document.domain //www.baidu.com document.lastModified返回当前文档最后修改的时间戳，格式为字符串。字符串是不能比较的，用Date.parse()方法转换成时间戳才能进行比较 123if (Date.parse(doc1.lastModified) &gt; Date.parse(doc2.lastModified)) &#123; // ...&#125; document.location123456789101112##location的属性// 当前网址为 http://user:passwd@www.example.com:4097/path/a.html?x=111#part1document.location.href // &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;document.location.protocol // &quot;http:&quot;document.location.host // &quot;www.example.com:4097&quot;document.location.hostname // &quot;www.example.com&quot;document.location.port // &quot;4097&quot;document.location.pathname // &quot;/path/a.html&quot;document.location.search // &quot;?x=111&quot;document.location.hash // &quot;#part1&quot; //网页的位置document.location.user // &quot;user&quot;document.location.password // &quot;passwd&quot; 1234567##location的方法:##location.assign() location.reload() location.toString()===document.location.hrefdocument.location.assign(&apos;http://www.google.com&apos;) // 跳转到另一个网址document.location.reload(true) // 优先从服务器重新加载document.location.reload(false) // 优先从本地缓存重新加载（默认值）document.location.replace(&apos;http://www.google.com&apos;) // 跳转到新网址，并将取代掉history对象中的当前记录。浏览器history对象就会用新的网址，取代当前网址，这样的话，“后退”按钮就不会回到当前网页了。document.location.toString() // 将location对象转为字符串，等价于document.location.href 1234567891011#如果将新的网址赋值给location对象，网页就会自动跳转到新网址。document.location = &apos;http://www.example.com&apos;// 等同于document.location.href = &apos;http://www.example.com&apos;document.assign(&apos;http://example.com&apos;)----------------#也可以指定相对URLdocument.location = &apos;page2.html&apos;-----------#跳转到锚点处document.location=&quot;#top&quot; #####document.referrer , document.title , document.characterSet document.referrer属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串。document.referre的值，总是与HTTP头信息的Referer保持一致，但是它的拼写有两个r。 document.title属性返回当前文档的标题，该属性是可写的。document.title = &#39;新标题&#39; document.characterSet属性返回渲染当前文档的字符集，比如UTF-8 document.readyState返回当前文档的状态，共有三种可能的值。 loading：加载HTML代码阶段（尚未完成解析） interactive：加载外部资源阶段时 complete：加载完成时 123456789101112// 基本检查if (document.readyState === &apos;complete&apos;) &#123; // ...&#125;// 轮询检查var interval = setInterval(function() &#123; if (document.readyState === &apos;complete&apos;) &#123; clearInterval(interval); // ... &#125;&#125;, 100); 查找节点document.querySelector() &amp;&amp; document.queryselectorAll() /Element.querySelector() &amp; Element.querySelectorAll()document.querySelector方法接受一个CSS选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。 document.querySelectorAll() 方法返回NodeList对象，有多个选择器可以用逗号分开 12var elements = document.querySelectorAll(&apos;div.a,.topBar&apos;)//同时选中class为a的div元素 和 class为topBar的元素数组集合 需要注意的是，浏览器执行querySelector方法时，是先在全局范围内搜索给定的CSS选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，请看下面的HTML代码。 12345678&lt;div&gt;&lt;blockquote id=&quot;outer&quot;&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;div id=&quot;inner&quot;&gt; &lt;p&gt;World&lt;/p&gt; &lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt; 那么，下面代码实际上会返回第一个p元素，而不是第二个。 123var outer = document.getElementById(&apos;outer&apos;);outer.querySelector(&apos;div p&apos;)// &lt;p&gt;Hello&lt;/p&gt; document.getElementsByTagName() / Element.getElementsByTagName()方法返回所有指定HTML标签的元素，返回值是一个类似数组的HTMLCollection对象。 注：HTML元素本身也定义了getElementsByTagName方法，这个方法不仅可以在document对象上调用，也可以在任何元素节点上调用。 12var p = document.getElementsByTagName(&apos;p&apos;)var span = p.getElementsByTagName(&apos;span&apos;) document.getElementsByClassName() / Element.getElementsByClassName()和上面一样，可以在任何元素节点上调用该方法 12var elements = document.getElementsByClassName(&apos;foo bar&apos;)//这里同时满足class为foo和bar的节点。参数写法上与document.querySelector()区分开， #####document.getElementById() 注：只能用在document上，不能用在其他元素身上 12document.querySelector(&apos;#top&apos;)document.getElementById(&apos;top&apos;) //这种选择效率比上面这种方法高很多 document.getElementsByName()document.getElementsByName方法用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等），返回一个类似数组的的对象（NodeList对象的实例） 1//&lt;form&gt;&lt;/form&gt; Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName() 上面四个方法只返回Element子节点，因此可以采用链式写法。 123document .getElementById(&apos;header&apos;) .getElementsByClassName(&apos;a&apos;) 生成节点document.createElement()用来生成网页元素的节点，参数为标签名。 1document.createElement(&apos;div&apos;) document.createTextNode()用来生成文本节点，参数为文本的内容。 123var newDiv = document.createElement(&apos;div&apos;)var newContent = document.createTextNode(&apos;Hello&apos;)newDiv.appendChild(newContent) 这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作HTML代码渲染。因此，可以用来展示用户的输入，避免XSS攻击。 1234var div = document.createElement(&apos;div&apos;);div.appendChild(document.createTextNode(&apos;&lt;span&gt;Foo &amp; bar&lt;/span&gt;&apos;));console.log(div.innerHTML)// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt; innerHTML &amp; outerHTML &amp; textContent的区别1234567891011121314151617181920212223&lt;body&gt;&lt;ul id=&apos;a&apos;&gt; &lt;li&gt;花&lt;/li&gt; &lt;li&gt;草&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;-------------var innerHtml = document.getElementById(&apos;a&apos;).innerHTMLconsole.log(innerHTML) //注意innerHTML的写法//&lt;li&gt;花&lt;/li&gt; &lt;li&gt;草&lt;/li&gt; 会返回不包括父标签的内容，包含标签-----------var outerHTML = document.getElementById(&apos;a&apos;).outerHTMLconsole.log(outerHTML)//&lt;ul id=&quot;a&quot;&gt; &lt;li&gt;花&lt;/li&gt; &lt;li&gt;草&lt;/li&gt; &lt;/ul&gt; 返回包含父标签的所有html内容--------------var textContent = document.getElementById(&apos;a&apos;).textContentconsole.log(textContent)//花 草 返回所有的文本内容 属性操作document.createAttribute()生成一个新的属性对象节点 1234567var node = document.getElementById(&quot;div1&quot;)var a = document.createAttribute(&quot;my_attrib&quot;)a.value = &quot;newVal&quot;node.setAttributeNode(a)// 等同于var node = document.getElementById(&quot;div1&quot;)node.setAttribute(&quot;my_attrib&quot;, &quot;newVal&quot;) Element.getAttribute(name)返回当前元素节点的指定属性。如果指定属性不存在，则返回null。 123// &lt;div id=&quot;div1&quot; align=&quot;left&quot;&gt;var div = document.getElementById(&apos;div1&apos;);div.getAttribute(&apos;align&apos;) // &quot;left&quot; Element.setAttribute(name,value)用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。 12345var d = document.getElementById(&apos;d1&apos;);d.setAttribute(&apos;align&apos;, &apos;center&apos;);------var myImage = document.querySelector(&apos;img&apos;);myImage.setAttribute(&apos;src&apos;, &apos;path/to/example.png&apos;); Element.hasAttribute(name)返回一个布尔值，表示当前元素是否包含指定属性 1234var d = document.getElementById(&apos;div1&apos;)if(d.hasAttribute(&apos;align&apos;))&#123; d.setAttribute(&apos;align&apos;,&apos;center&apos;)&#125; Element.removeAttribute(name)从当前节点移除属性 1234//&lt;div id=&quot;div1&quot; align=&quot;left&quot; width=&quot;200px&quot;&gt;document.getElementById(&apos;div1&apos;).removeAttribute(&apos;align&apos;)// 现在的HTML代码为// &lt;div id=&quot;div1&quot; width=&quot;200px&quot;&gt; dataset属性有时需要再HTML元素上附加数据，可以使用标准提供的data-属性。然后使用节点对象的dataset属性来操作元素标签的data-\属性 123456&lt;div id=&quot;mydiv&quot; data-foo=&quot;bar&quot;&gt;&lt;/div&gt;var a = document.getElementById(&apos;mydiv&apos;)a.dataset.foo //bara.dataset.foo = &apos;baz&apos; //这个属性可以用来读写-------也可以直接用delete删除该属性delete a.dataset.foo 除了dataset属性，也可以用getAttribute(&#39;data-foo&#39;)、removeAttribute(&#39;data-foo&#39;)、setAttribute(&#39;data-foo&#39;)、hasAttribute(&#39;data-foo&#39;)等方法操作data-*属性。 注意，data-后面的属性名有限制，只能包含字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_)。而且，属性名不应该使用A到Z的大写字母，比如不能有data-helloWorld这样的属性名，而要写成data-hello-world。 转成dataset的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。反过来，dataset的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。比如，dataset.helloWorld会转成data-hello-world。 Element对象#####Element.className ,Element.classList className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。 classList属性则返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。 123456789101112&lt;div class=&quot;one two three&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;document.getElementById(&apos;myDiv&apos;).className// &quot;one two three&quot;--------------document.getElementById(&apos;myDiv&apos;).classList// &#123;// 0: &quot;one&quot;// 1: &quot;two&quot;// 2: &quot;three&quot;// length: 3// &#125; Element.classList.add()：增加一个class。 Element.classList.remove()：移除一个class。 Element.classList.contains()：检查当前元素是否包含某个class。 Element.classList.toggle()：将某个class移入或移出当前元素。 Element.classList.item()：返回指定索引位置的class。 Element.classList.toString()：将class的列表转为字符串。 1234567myDiv.classList.add(&apos;myCssClass&apos;);myDiv.classList.add(&apos;foo&apos;, &apos;bar&apos;);myDiv.classList.remove(&apos;myCssClass&apos;);myDiv.classList.toggle(&apos;myCssClass&apos;); // 如果myCssClass不存在就加入，否则移除myDiv.classList.contains(&apos;myCssClass&apos;); // 返回 true 或者 falsemyDiv.classList.item(0); // 返回第一个ClassmyDiv.classList.toString(); Element.closest()1234567891011121314151617181920&lt;p&gt; &lt;div id=&quot;div-01&quot;&gt;Here is div-01 &lt;div id=&quot;div-02&quot;&gt;Here is div-02 &lt;div id=&quot;div-03&quot;&gt;Here is div-03&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/p&gt;var el = document.getElementById(&apos;div-03&apos;);var r1 = el.closest(&quot;#div-02&quot;); // 返回 id 为 div-02 的那个元素var r2 = el.closest(&quot;div div&quot;); // 返回最近的拥有 div 祖先元素的 div 祖先元素，这里的话就是 div-03 元素本身var r3 = el.closest(&quot;p &gt; div&quot;); // 返回最近的拥有父元素 p 的 div 祖先元素，这里的话就是 div-01var r4 = el.closest(&quot;:not(div)&quot;); // 返回最近的非 div 的祖先元素，这里的话就是最外层的 p 盒模型相关属性#####Element.clientHeight, Element.clientWidth Element.clientWidth 属性表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。 Element.clientLeft ,Element.clientTop返回元素周围边框的厚度即border的宽度，不包括padding和margin #####Element.scrollHeight ,Element.scrollWidth Element.scrollHeight 是计量元素内容高度的只读属性，包括overflow样式属性导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的margin. 12Element.scrollHeight 是计量元素内容高度的只读属性，包括overflow样式属性导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的margin.element.scrollHeight - element.scrollTop === element.clientHeight Element.scrollLeft, Element.scrolltopElement.scrollLeft属性表示网页元素的水平滚动条向右侧滚动的像素数量，Element.scrollTop属性表示网页元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。 如果要查看整张网页的水平的和垂直的滚动距离，要从document.documentElement元素上读取。 12document.documentElement.scrollLeftdocument.documentElement.scrollTop 这两个属性都可读写，设置该属性的值，会导致浏览器将指定元素自动滚动到相应的位置。 Element.offsetHeight, Element.offsetWidth这两个属性值包括Padding和Border、以及滚动条。 123456789101112#整张网页的高度，可以在document.documentElement和document.body上读取。// 网页总高度document.documentElement.offsetHeightdocument.body.offsetHeight// 网页总宽度document.documentElement.offsetWidthdocument.body.offsetWidth--------------//视口高度/宽度window.innerHeight/innerWidth //包括滚动条document.documentElement.clientHeight/clientWidth //不包括滚动条 #####Element.getBoundingClientRect() Element.getBoundingClientRect方法返回一个对象，该对象提供当前元素节点的大小、位置等信息，基本上就是CSS盒状模型提供的所有信息。 1var rect = obj.getBoundingClientRect(); 上面代码中，getBoundingClientRect方法返回的rect对象，具有以下属性（全部为只读）。 x：元素左上角相对于视口的横坐标 left：元素左上角相对于视口的横坐标，与x属性相等 right：元素右边界相对于视口的横坐标（等于x加上width） width：元素宽度（等于right减去left） y：元素顶部相对于视口的纵坐标 top：元素顶部相对于视口的纵坐标，与y属性相等 bottom：元素底部相对于视口的纵坐标 height：元素高度（等于y加上height） 由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将left属性加上window.scrollX，top属性加上window.scrollY。 注意，getBoundingClientRect方法的所有属性，都把边框（border属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，width和height包括了元素本身 + padding + border。 获取某个网页元素距离视口左上角的坐标 12345// 网页元素左上角的视口横坐标Element.getBoundingClientRect().left// 网页元素左上角的视口纵坐标Element.getBoundingClientRect().top 1234567某个网页元素距离网页左上角的坐标，使用视口坐标加上网页滚动距离。// 网页元素左上角的网页横坐标Element.getBoundingClientRect().left + document.documentElement.scrollLeft// 网页元素左上角的网页纵坐标Element.getBoundingClientRect().top + document.documentElement.scrollTop 123456#网页目前滚动的距离，可以从document.documentElement节点上得到。// 网页滚动的水平距离document.documentElement.scrollLeft// 网页滚动的垂直距离document.documentElement.scrollTop Element.getClientRects()Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形。每个矩形都有bottom、height、left、right、top和width六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。 12345&lt;span id=&quot;inline&quot;&gt;Hello WorldHello WorldHello World&lt;/span&gt; 上面代码是一个行内元素&lt;span&gt;，如果它在页面上占据三行，getClientRects方法返回的对象就有三个成员，如果它在页面上占据一行，getClientRects方法返回的对象就只有一个成员。 1234567var el = document.getElementById(&apos;inline&apos;);el.getClientRects().length // 3el.getClientRects()[0].left // 8el.getClientRects()[0].right // 113.908203125el.getClientRects()[0].bottom // 31.200000762939453el.getClientRects()[0].height // 23.200000762939453el.getClientRects()[0].width // 105.908203125 这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。 Element.insertAdjacentHTML()语法：element.insertAdjacentHTML(position, text) 指定位置共有四个。 beforebegin：在当前元素节点的前面。 afterbegin：在当前元素节点的里面，插在它的第一个子元素之前。 beforeend：在当前元素节点的里面，插在它的最后一个子元素之后。 afterend：在当前元素节点的后面。 12345// 原来的HTML代码：&lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;var d1 = document.getElementById(&apos;one&apos;);d1.insertAdjacentHTML(&apos;afterend&apos;, &apos;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;&apos;);// 现在的HTML代码：// &lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt; 该方法不是彻底置换现有的DOM结构，这使得它的执行速度比innerHTML操作快得多。 1d1.innerHTML = &apos;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;&apos; Element.remove()Element.remove方法用于将当前元素节点从DOM树删除。 12var el = document.getElementById(&apos;div-01&apos;);el.remove(); ####Text节点 通常我们使用Node节点的firstChild、nextSibling等属性获取Text节点，或者使用Document节点的createTextNode方法创造一个Text节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中字符串的方法小结]]></title>
      <url>%2F2017%2F07%2F29%2Fstring%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[concat() [类似于数组的concat()方法] 连接两个字符串，返回一个新字符串，不改变原来字符串 语法：str.concat(string2, string3[, …, stringN]) 返回值：新的字符串，（原字符串不变） 12&apos;&apos;.concat(1,2,&apos;3&apos;) //&apos;123&apos; 会先转换为字符串再连接1+2+&apos;3&apos; //&apos;33&apos; 数字+字符串 == 字符串 slice() [类似于数组的slice()方法] 提取一个字符串的一部分，并返回一个新的字符串 语法：str.slice(start[, end]) 参数start从index=0开始 , 到end前一个数为止 返回值：新的字符串 （原字符串不变） 12&apos;tom tom&apos;.slice(2,6)//&apos;m t&apos; substring() substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。 语法：str.substring(indexStart[, indexEnd]) 参数：一个 0 到字符串长度之间的整数 ，这两个参数会自动调整到 第一个参数比第二个参数小 ​ (原字符串不变) 12&apos;JavaScript&apos;.substring(9,4) === &apos;JavaScript&apos;.substring(4,9) /ture//&apos;Scrip&apos; 注：slice()可以接受负数，substring()不行。substring()会自动调整，而slice()会变成空字符串。 substr() substr()方法返回一个字符串中从指定位置开始到指定字符数的字符。 语法：str.substr(start[, length]) 第二个参数是长度，区分substring()的第二个参数是index ​ (原字符串不变) 12&apos;JavaScript&apos;.substr(4,5)//&apos;Scrip&apos; ####确定字符是否包含在字符串中 indexOf() &amp; lastIndexOf() [类似于数组的indexIOf()方法] 这两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回-1，就表示不匹配。 12&apos;Tom is a gay&apos;.indexOf(&apos;a&apos;)//7 string.includes(string,startIndex)：返回布尔值，表示是否找到了参数字符串。 12345&apos;tom is a gay&apos;.includes(&apos;d&apos;)//flase-----------第二个参数表示开始搜索的位置&apos;tom is a gay&apos;.includes(&apos;o&apos;,1) //ture&apos;tom is a gay&apos;.includes(&apos;o&apos;,2) //flase str.startsWidth(str,startIndex):返回布尔值，表示参数字符串是否在源字符串的头部。 1&apos;tom is a gay&apos;.startsWith(&apos;gay&apos;,9) //ture str.endsWidth(str,lastIndex):返回布尔值，表示参数字符串是否在源字符串的尾部。 1&apos;tom is a gay&apos;.endsWith(&apos;is&apos;,6) //true repeat()语法：str.repeat(num) repeat()方法返回一个新字符串，表示将原字符串重复n次。 12345如果是小数，会被取整&apos;tom&apos;.repeat(2.9) //&apos;tomtom&apos;如果是-1到0之间，视为0 ；NaN也视为0&apos;tom&apos;.repeat(-0.7) //&apos;&apos;&apos;tom&apos;.repeat(NaN) //&apos;&apos; 补全字符串，类似数组push()添加语法：str.padStart(targetLength [, padString]) / padEnd() 返回值：一个新的字符串（不改变原字符串） 1234&apos;x&apos;.padStart(3) //&apos; x&apos; 没有第二个参数默认用空格代替&apos;xx&apos;.padEnd(2,&apos;sdfsd&apos;) //&apos;xx&apos; 长度如果是原来字符串本身，那么返回原字符串&apos;xx&apos;.padStart(4,&apos;kkkkkkk&apos;) //&apos;kkxx&apos; 多余的会舍去&apos;xx&apos;.padEnd(5,&apos;sk&apos;) //&apos;xxsks&apos; 不够长度的话会重复、 trim(),trimRight(),trimLeft() trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (包括换行符\n、回车符\r、制表符\t、\v) 返回值：新字符串 （不改变原字符串） 参数：不接受参数 语法：str.trim() 12&apos; hello world \n&apos;.trim() // &apos;hello world&apos; chatAt()方法从一个字符串中返回指定的字符。 语法：str.charAt(index) ；超出index范围，就返回空字符串 12&apos;tom is a gay&apos;.chatAt(2) //&apos;m&apos;&apos;tom is a gay&apos;.chatAt(99) //&apos;&apos; toLowerCase() &amp; toUpperCase() toLowerCase()方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。 语法：str.toLowerCase() 返回值：新的字符串 （不改变原字符串） 12&apos;JavaScript&apos;.toUpperCase()&quot;JAVASCRIPT&quot; match() match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 语法：str.match(regexp); 返回值：满足匹配条件的数组 参数： 未使用参数，返回空字符串的数组[‘’] 1&apos;hello world&apos;.match() //[&quot;&quot;] 正则表达式不带有g标志，会返回 RegExp.exec() 相同的结果，返回的数组有index（匹配在原字符串中的索引）和input（原字符串）属性。而且返回的是第一个匹配到的元素的数组 参数带有g的正则表达式，返回全部匹配到的数组，而且没有index和input属性 12&apos;tom is a toy&apos;.match(/to./g)//[&apos;tom&apos;,&apos;toy&apos;] 遍历字符串：for…of123456for(let key of &apos;tom&apos;)&#123; console.log(key)&#125;//t//o//m]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[属性描述对象]]></title>
      <url>%2F2017%2F07%2F20%2F%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[概述属性描述对象，是用来描述一个对象的属性的行为，控制它的行为。 123456789描述对象实例&#123; value: 123, //存放属性值，默认undefined writable: false, //存放布尔值，默认true，表示属性值是否可变 enumerable: true, //存放布尔值，表示属性是否可枚举，默认为true，如果为false，for...in和Object.keys()会跳过改属性 configurable: false, //存放布尔值，表示可配置性，默认为true。控制描述对象的可写性（value属性可改变） get: undefined, //存放一个函数，表示该属性的取值函数（getter），默认undefined set: undefined //存放一个函数，表示该属性的存值函数（setter），默认undefined&#125; 12345678configurable属性为false，将无法删除该属性var o =Object.defineProperty(&#123;&#125;,&apos;p&apos;,&#123; value:123&#125;)delete o.p //false 无法删除，delete方法返回布尔值Object.defineProperty(o,&apos;p&apos;,&#123; value:243&#125;) //报错，不能重新定义p属性 Object.getOwnPropertyDescriptior读出对象自身属性的属性描述对象 1234读取o对象的name属性的属性描述对象var o =&#123;name:&apos;tom&apos;&#125;Object.getOwnPropertyDescriptor(o,&apos;name&apos;) //这里name是字符串//&#123;value: &quot;tom&quot;, writable: true, enumerable: true, configurable: true&#125; #####Object.defineProperty(),Object.defineProperties() 该方法允许通过定义属性描述对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下。这两个方法有性能损耗，不能大量使用。 1234567891011Object.defineProperty(object,propertyName,attributesObject)----------var o =Object.defineProperty(&#123;&#125;,&apos;p&apos;,&#123; value:123, writable:false, enumerable:false, configurable:false,&#125;)o.p //123o.p=345o.p=123 //因为writable为false，所以无法改变属性值 12345678910111213141516##设置了get或着set，就不能设置writable属性和value属性var o =Object.defineProperties(&#123;&#125;,&#123; //写法不同 p1:&#123;value:1,enmuerable:true&#125;, p2:&#123;value:2&#125;, p3:&#123;writable:true&#125;, p4:&#123; get:function()&#123;return this.p1+this.p2&#125;, configurable:true &#125;&#125;)o.p1 //1o.p2 //2o.p3 //3Object.getOwnPropertyDescriptor(o,&apos;p3&apos;)//&#123;value: undefined, writable: true, enumerable: false, configurable: false&#125;Object.defineProperty()方法它的writable、configurable、enumerable这三个属性的默认值都为false 可枚举性只有可枚举属性，才会被for…in循环遍历，同时还规定原生继承的属性都是不可枚举的。 可枚举性（enumerable）用来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。 123for...in 循环Object.keys() 方法JSON.stringify() 方法 12345678910111213141516#可以用enumerable:flase 来设置秘密属性var o =&#123;a:1,b:2&#125;Object.defineProperty(o,&apos;c&apos;,&#123; value:3, enumerable:false //默认就是false&#125;)o.c //3-------for(let x in o)&#123; console.log(o[x])&#125;//1 2-------Object.keys(o) //[&apos;a&apos;,&apos;b&apos;]------JSON.stringify(o) //&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot; 可配置性configurable当configurable为false时，value，writable，enumerable，configurable都不能修改了 writable从true改为false时是允许的，反过来就报错 12345var o = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; writable: true, configurable: false&#125;);Object.defineProperty(o,&apos;p&apos;, &#123;writable: false&#125;) 至于value，只要writable和configurable有一个为true，就允许改动。 1234567var o2 = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 1, writable: false, configurable: true&#125;);Object.defineProperty(o2,&apos;p&apos;, &#123;value: 2&#125;)o2.p //2 用var声明变量时，configurable默认为flase，说明用var声明的变量不能用delete删除，而var声明对象就默认为true，可以用delete删除（delete只能删除对象的属性） 1234567var a =2Object.getOwnPropertyDescriptor(this,&apos;a&apos;)//&#123;value: 2, writable: true, enumerable: true, configurable: false&#125;--------var o=&#123;a:1&#125;Object.getOwnPropertyDescriptor(o,&apos;a&apos;)//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125; Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回直接定义在某个对象上面的全部属性的名称，而不管该属性是否可枚举。 123456789101112var o =Object.defineProperties(&#123;&#125;,&#123; p1:&#123;value:1,enumerable:true&#125;, p2:&#123;value:2,enumerable:false&#125;&#125;)Object.getOwnPropertyNames(o)//[&quot;p1&quot;, &quot;p2&quot;]-------Object.keys(o)//[&apos;p1&apos;]------------Object.keys([]) // []Object.getOwnPropertyNames([]) // [ &apos;length&apos; ] //系统原生属性都是不可枚举的（即非用户自定义） Object.prototype.propertyIsEnumerable()来判断一个属性是否可枚举 123456var o=&#123;p:123&#125;o.propertyIsEnumerable(&apos;p&apos;)//ture-------o.propertyIsEnumerable(&apos;toString&apos;)//false 存取器存取器提供的是虚拟属性，即该属性的值不是实际存在的，而是每次读取时计算生成的。 注：取值函数getter不接受参数（对象也不能有与取值函数同名的属性），存值函数只接受一个参数（即属性的值）。 1234567891011#对p属性取值时，取值函数会自动调用；对p属性赋值时，存值函数会自动调用。var o =&#123; get p()&#123; return &apos;getter&apos; //取值函数一般都是return &#125;, set p(value)&#123; console.log(&apos;setter:&apos;+ value) &#125;&#125;o.p //getter 取值时调用o.p = 123 //setter:123 赋值时调用 12345678910#数据对象和DOM对象的双向绑定Object.defineProperty(user,&apos;name&apos;,&#123; get:function()&#123; return document.getElementById(&apos;foo&apos;).value &#125;, set:function(newValue)&#123; document.getElementById(&apos;foo&apos;).value=newValue &#125;, configurable:ture&#125;) 上面就是mvvm框架的ViewModel业务逻辑。MVVM是Model-View-ViewModel的简写，视图（用户界面）和模型（数据）的双向映射。（缺点，用户频繁改动，cpu消耗很大） Object.preventExtensions() &amp; Object.isExtensible()extension扩展，阻止扩展。使一个对象无法再添加新的属性(不能增加可删除) extensible 可扩展的。检查是否可以为一个对象添加属性 1234567891011121314151617var o =&#123;&#125;Object.preventExtensions(o)Object.defineProperty(o,&apos;p&apos;,&#123; value:2&#125;)//TypeError: Cannot define property p, object is not extensible-----Object.isExtensible(o) //false------o.p =1o.p //undefined-----------#可以用delete删除一个现有属性var o =&#123;p:1&#125;Object.preventExtensions(o)delete o.p //trueo.p //undefined Object.seal() &amp; Object.isSealedseal:密封 ，既不能添加也不能删除旧属性，（本质就是把configurable改为false，所以writable可以从true改为false，但是反过来不行） 属性对象的value是由writable决定的 123456var o =&#123;p:1&#125;Object.seal(o)o.p =2o.p //2------Object.isSealed(o) //true Object.freeze() &amp; Object.isFrozen()不能添加，不能删除，不能更改。相当于固定住一个对象，变成常量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON数据格式]]></title>
      <url>%2F2017%2F07%2F15%2FJson%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[#####基本格式要求 每个JSON对象，就是一个值，每个JSON文档职能包含一个值 复合类型的值只能是数组或着对象。不能是函数，正则对象或者日期对象 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined） 字符串必须使用双引号，不能使用单引号 对象的键名也必须带有双引号 数组或着对象的最后一个成员，不能加逗号。 #####JSON.stringify() JSON.stringify方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。 123456789JSON.stringify([1, &quot;false&quot;, false])// &apos;[1,&quot;false&quot;,false]&apos;--------JSON.stringify(&#123; name: &quot;张三&quot; &#125;)// &apos;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&apos;--------原始类型的字符串，转换结果会带有双引号，这是因为将来还原的时候，双引号可以让 JavaScript 引擎知道，foo是一个字符串，而不是一个变量名。JSON.stringify(&apos;foo&apos;) //&quot;&quot;foo&quot;&quot;JSON.stringify(&apos;foo&apos;)===&quot;\&quot;foo\&quot;&quot; JSON.stringify()还可以接受第二个参数（第二个参数是一个数组[]，否则无效）指定需要转成字符串的属性。（只对对象有效，对数组无效） 12345678910var obj = &#123; &apos;prop1&apos;: &apos;value1&apos;, &apos;prop2&apos;: &apos;value2&apos;, &apos;prop3&apos;: &apos;value3&apos;&#125;;var selectedProperties = [&apos;prop1&apos;, &apos;prop2&apos;];JSON.stringify(obj, selectedProperties) // &quot;&#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;&quot; 转换规则： 如果对象中含有不合规定的值，如undefined 或着函数对象等，会忽略 123456789101112var obj = &#123; a:1, b:2&#125;JSON.stringify(obj)&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot; //会自动在键名上添加括号---------var obj = &#123; a: undefined, b: function () &#123;&#125;&#125;JSON.stringify(obj) // &quot;&#123;&#125;&quot; 如果是数组中包含有不合规定的值，那么会转为null 12var arr = [undefined, function () &#123;&#125;]JSON.stringify(arr) // &quot;[null,null]&quot; JSON.stringify()会忽略对象的不可遍历属性 123456789101112131415var obj=&#123;&#125;Object.defineProperties(obj,&#123; &apos;foo&apos;:&#123; value:1, enumerable:true enumerable是可枚举属性的开关 &#125;, &apos;bar&apos;:&#123; value:2, enumerable:false &#125;&#125;)JSON.stringify(obj) //&#123;&quot;foo&quot;:1&#125;obj.propertyIsEnumerable(&apos;foo&apos;) //trueobj.propertyIsEnumerable(&apos;bar&apos;) //false###关于obj.propertyIsEnumerable(prop)返回一个布尔值，来检测这个属性是否可枚举 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每次都会忘记的正则！]]></title>
      <url>%2F2017%2F07%2F01%2F%E6%AD%A3%E5%88%99%2F</url>
      <content type="text"><![CDATA[正则表达式 Regular expressions：用来匹配字符串中字符组合的模式. 两种表达方式 字面量(在编译时新建正则表达式，即在代码在如是生成) 1var regex = /xyz/ 构造函数，可以接受第二个参数，表示修饰符 (在运行时新建正则表达式，即在代码运行时生成) 12var regex = new RegExp(&apos;xyz&apos;，&apos;i&apos;)=== var regex = /xyz/i 两种语法 正则对象的方法：regex.test(string) 返回布尔值/ regex.exec(string)返回数组 字符串对象的方法：string.match(regex) 正则对象属性和方法属性： 3个只读属性，都返回布尔值ignoreCase \ global （全局模式，和lastIndex挂钩）\ mulitline 1234567var r = /&apos;abc&apos;/igmr.ignoreCase //true 表示是否设置了该属性r.global //truer.multiline //true--------r.source //&quot;abc&quot;r.lastIndex //0 source：只读属性，返回正则表达式的字符串形式（不包括反斜杠） lastIndex: （在设置g的前提下）可读写属性，返回下一次开始搜索的位置 方法： 12345可以指定搜索位置var regex = /x/gvar str = &apos;yxyx&apos;regex.lastIndex = 4regex.test(str) //false test()：返回布尔值，用来查看正则表达式与指定的字符串是否匹配regexObj.test(str) 1234var str = &apos;hello world&apos;var regex = /^h.+o/let result = regex.test(str) console.log(result) //true exec()：返回一个结果数组或者null (与match()方法类似），regexObj.exec(&#39;string&#39;) 返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。(第一项只返回第一个匹配的字符串) 当正则表达式使用 “g“ 标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的 lastIndex属性指定的位置开始(lastIndex属性是在regex正则表达式上的）。（test() 也会更新 lastIndex 属性） match()：返回一个array（数组），包含了整个匹配结果以及任何括号捕获的匹配结果 ；如果没有匹配项，则返回null。str.match(regexObject) 有g修饰：返回一个Array ，它包含所有匹配的子字符串。捕获组不会被返回(即不返回index属性和input属性)。如果没有匹配到，则返回 null 。 无g修饰：返回的 Array拥有一个额外的 input 属性，该属性包含被解析的原始字符串。另外，还拥有一个 index 属性，该属性表示匹配结果在原字符串中的索引（以0开始）。 1234567891011121314151617var str = &apos;For more information, see Chapter 3.4.5.1&apos;;var re = /see (chapter \d+(\.\d)*)/i;var found = str.match(re);console.log(found);// logs [ &apos;see Chapter 3.4.5.1&apos;,// &apos;Chapter 3.4.5.1&apos;,// &apos;.1&apos;,// index: 22,// input: &apos;For more information, see Chapter 3.4.5.1&apos; ]// &apos;see Chapter 3.4.5.1&apos; 是整个匹配。// &apos;Chapter 3.4.5.1&apos; 被&apos;(chapter \d+(\.\d)*)&apos;捕获。// &apos;.1&apos; 是被&apos;(\.\d)&apos;捕获的最后一个值。// &apos;index&apos; 属性(22) 是整个匹配从零开始的索引。// &apos;input&apos; 属性是被解析的原始字符串。 字符串对象方法（match(),search(),replace(),split()） , String.indexOf(2) 字符串里是否包含2 string.match(regex) ，类似regex.exec(srting)，返回数组；没有匹配到返回null。 如果设置g修饰，那么返回所有匹配结果所组成的数组。对macth()设置lastIndex无效，对exec()方法设置有效 string.search(regex): 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。 该方法忽略g修饰。 12&apos;yxyx&apos;.search(/x/)//1 string.replace(regex) //一般用于敏感词过滤 字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。 语法：string.replace(regex|string , newString|function) 返回值：替换后的新的字符串（不改变原字符串） 注：不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。 123&apos;aaa&apos;.replace(&apos;a&apos;,&apos;b&apos;) //&apos;baa&apos;&apos;aaa&apos;.replace(/a/,&apos;b&apos;) //&apos;baa&apos;&apos;aaa&apos;.replace(/a/g,&apos;b&apos;) //&apos;bbb&apos; 第二个参数可以是函数，其返回值为替换的字符串，这个函数接受4个参数 匹配的字符串 p1,p2…正则表达式括号里的匹配内容（捕获） 匹配到的字符串的起始位置index 原来的字符串 string.split(regex) split()方法将一个字符串分割成 字符串数组 语法：str.split([separator[, limit]]) 参数：第一个表示分割规则，第二个是返回的成员最大数 1234&apos;a,b,c,d&apos;.split(&apos;,&apos;,2)//[&apos;a&apos;,&apos;b&apos;]&apos;a,b,c,d&apos;.split()//[&apos;a,b,c,d&apos;] 正则匹配规则#####字面量字符和元字符 字面量字符：如/a/匹配a，/b/匹配b 1/dog/.test(&apos;dog and cat&apos;) //true 元字符： . ：匹配除换行符以外的任意字符 位置字符： ^ 表示字符串的开始位置，只能放在开始第一个位置 $ 表示字符串的结束位置，只能放在最后一个位置 1/^dog$/.test(&apos;dogdog&apos;) //false 选择符：| 表示或的意思 1/11|22/.test(&apos;91122&apos;) //ture 12个转义符：\. ,\^ ,\$ , \| , + , * , \? , \( , \) ,{ , [ , \\（查找\本身） 用RegExp方法生成的正则对象要用两个\\来转义 特殊字符：\n 换行键 ， \r 回车键 ， \0 匹配null字符 字符类：[] 在方括号中的表示只要匹配其中一个就可以了 1/[abc]/.test(&apos;fuck&apos;) //true 脱字符^ ：必须写在方括号第一个位置才有用，表示出了字符类中的字符的其他字符 1/[^abc]/.test(&apos;fuck&apos;) //false 套路：[^] 表示匹配一切字符，区别于包含换行符的. 连字符- ：表示连续范围 1234[a-z] [A-Z] [0-9] [1-31]这个表示 1到3，而非表示1到31-----------不要出现[A-z],其中会出现其他字符比如\\ 注：字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，[-9]就表示匹配连字符和9，而不是匹配0到9。 预定义模式： | 简写 | 原型 | 介绍 || :–: | :———–: | :——————- || \d | [0-9] | 匹配0-9之间的任一数字 || \D | [^0-9] | || \w | [A-Za-z0-9] | 匹配任意的字母、数字和下划线 || \W | [^A-Za-z0-9] | || \s | [\t\r\n\v\f] | 匹配空格（包括制表符、空格符、断行符等） || \S | [^\t\r\n\v\f] | || \b | | 匹配词的边界。 || \B | | | 重复：{} : {n} 表示重复n次 ​ {n,} 表示重复&gt;=n次 ​ {n,m} 表示重复&gt;=n次且&lt;=m次 量词符：? 问号表示某个模式出现0次或1次，等同于{0, 1}。 ​ * 星号表示某个模式出现0次或多次，等同于{0,}。 ​ + 加号表示某个模式出现1次或多次，等同于{1,}。 非贪婪模式：一旦条件满足，就不再往下匹配。 *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。 +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。 ?? , {n,m}? , {n,}? 123/tom+/.exec(&apos;tommm&apos;) //[tommm]/tom+?/.exec(&apos;tommm&apos;) //[tom]/tom*?/.exec(&apos;tommm&apos;) //[to] ​ 修饰符：g（全局），i（忽略大小写），m（修改^和$de行为，可以识别换行符） 1234/world$/.test(&apos;hello world\n&apos;) // false/world$/m.test(&apos;hello world\nasdsf&apos;) // true/^b/m.test(&apos;a\nb&apos;) // true 匹配组：()捕获 123/tom+/.exec(&apos;tommm&apos;) //[&apos;tommm&apos;]/(tom)+/.exec(&apos;tommm&apos;) //[&apos;tom&apos;,&apos;tom&apos;]/(tom)+/.exec(&apos;tomtom&apos;) //[&apos;tomtom&apos;,&apos;tom&apos;] 这里表示tom这个词出现1次或多次 在正则表达式内部，可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。 12345/(.)b(.)\1\2/.exec(&apos;abcac&apos;)//[&apos;abcac&apos;,&apos;a&apos;,&apos;c&apos;]----------------/y(..)(.)\2\1/.exec(&apos;yabccab&apos;) //[&quot;yabccab&quot;, &quot;ab&quot;, &quot;c&quot;] 非捕获组：(?:x)，表示不返回改组匹配的内容，即匹配的结果中不计入这个括号。 12var m = &apos;abc&apos;.match(/(?:.)b(.)/);m // [&quot;abc&quot;, &quot;c&quot;] 先行断言（括号里的内容不返回）：x(?=y)称为先行断言，x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。先行断言中，括号里的部分是不返回的。 12var m = &apos;abc&apos;.match(/b(?=c)/);m // [&quot;b&quot;] 现行否定断言：x(?!y)``x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。 12/\d+(?!\.)/.exec(3.14)//14 补充 str.substring(start , end) 截取字符串 、 str.substr(start,length) 与str.search() 相对的是 str.charAt(index) :根据索引返回字符串中对应的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面局部刷新的里程碑：AJAX]]></title>
      <url>%2F2017%2F06%2F25%2FAJAX%2F</url>
      <content type="text"><![CDATA[AJAXAsync JavaScript And XML：异步的JS+XML 请求回顾12345678请求行：GET ／ index.html HTTP/1.1请求头：Host:1.2.3.4 Accept: html, xhtml, xml User-Agent: Chrome / Mac 回车消息体：username=xxxx&amp;password=yyyyy&amp;c=zzzzz---------常用的请求方法：POST\DELETE\PUT、PATCH\GET\HEAD\TRACK\CONNCET\OPTIONS 发请求的方法 地址栏回车 发起特定类型的请求： 图片发起请求：&lt;img src=/xxx&gt; 请求头里：Accept: image/webp,image/,/* 期待接收图片 js发请求：&lt;script src=/xxx 请求头里：Accept:test/javascript, */* css发请求：&lt;link rel=stylesheet href=/xxx&gt; 请求头里：Accept:test/css,*/* form表单发起请求：&lt;form action=&#39;/xxx&#39; method=GET (Accept:*/*) 缺点：1、3请求方法会刷新页面并替换当前页面内容，2请求方法只能请求特定类型资源 局部更新要求：发一个请求，这个请求去更新页面里的局部内容，而不刷新整个页面。 js改变地址栏（更新了整个页面，不符合要求） 123456789前端：&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div&gt;空的&lt;/div&gt;&lt;script&gt; button.onclick=function()&#123; location.href = &apos;/xxx&apos; &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233服务器端：var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;)//console.log(Object.keys(http))var port = process.env.PORT || 8888;var server = http.createServer(function(request, response)&#123; var temp = url.parse(request.url, true) var path = temp.pathname var query = temp.query var method = request.method //从这里开始看，上面不要看 if(path === &apos;/&apos;)&#123; // 如果用户请求的是 / 路径 var string = fs.readFileSync(&apos;./index.html&apos;) response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) response.end(string) &#125;else&#123; response.statusCode = 404 response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) response.end(&apos;找不到对应的路径，你需要自行修改 index.js&apos;) &#125; // 代码结束，下面不要看 console.log(method + &apos; &apos; + request.url)&#125;)server.listen(port)console.log(&apos;监听 &apos; + port + &apos; 成功，请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port) ​ 发一个图片请求(可以局部发请求，但是无法获取响应的数据内容，不符合要求) 12345678910前端：&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div&gt;空的&lt;/div&gt;&lt;script&gt; button.onclick=function()&#123; var img = new Image() img.src = &apos;/xxx&apos; &#125;&lt;/script&gt; 1234567服务器端：...... if(path === &apos;/xxx&apos;)&#123; response.end(&apos;这是xxx的内容&apos;) &#125;else&#123; response.end(&apos;404&apos;) &#125; CSS发请求（同样的，无法拿到响应中的内容） 123456789101112131415161718前端：&lt;body&gt;&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div&gt;空的&lt;/div&gt;&lt;script&gt; button.onclick=function()&#123; var link = document.createElement(&apos;link&apos;) link.rel=&apos;stylesheet&apos; link.href=&apos;/xxx&apos; link.onload = ()=&gt;&#123; console.log(&apos;link.innerHTML&apos;) console.log(link.innerHTML) //无法打印出里面的响应内容 &#125; document.head.appendChild(link) &#125;&lt;/script&gt;&lt;/body&gt; JS发请求 1234567891011&lt;body&gt;&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div id=&quot;output&quot;&gt;空的&lt;/div&gt;&lt;script&gt; button.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.src = &apos;/xxx&apos; document.head.appendChild(script) &#125;&lt;/script&gt; 报错：js请求的路径是’/xxx’,那么路径对应的内容因该是合法的js字符串；而我们返回的是’here is xxx’字符串，所以报错。（但是浏览器把它当成js解析了，这是转机） 修改路径内容，使之能被js那样被解析 1234if(path === &apos;/xxx&apos;)&#123; response.setHeader(&apos;Content-Type&apos;,&apos;text/plain;charset=utf-8&apos;) response.end(&apos;output.innerText=&quot;here is xxx&quot;&apos;) //或者一个随机数response.end(`output.innerText=$&#123;Math.random()&#125;`) 1234567891011前端：&lt;script&gt; window.callback = function()&#123; console.log(arguments[0]) //打出第一个参数 &#125; button.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.src = &apos;/xxx&apos; document.head.appendChild(script) &#125;&lt;/script&gt; 12345服务器端：if(path === &apos;/xxx&apos;)&#123; response.setHeader(&apos;Content-Type&apos;,&apos;text/plain;charset=utf-8&apos;) var user = &apos;name:tom,age:18&apos; response.end(`window.callback.call(null,&quot;$&#123;user&#125;&quot;)`) 变换 1234567891011121314151617181920212223242526前端：&lt;body&gt;&lt;button id=&quot;button&quot;&gt;click&lt;/button&gt;&lt;div id=&quot;output&quot;&gt;空的&lt;/div&gt;&lt;script&gt; window.callback = function(data)&#123; var array = data.split(&apos;,&apos;) //[&quot;name: tom &quot;,&quot; age: 18&quot;&quot;] //字符串转成数组 for(var i=0;i&lt;array.length;i++)&#123; //遍历数组 var parts = array[i].split(&quot;:&quot;) //[&quot;name&quot;,&quot; tom &quot;] var dl = document.createElement(&quot;dl&quot;) var dt = document.createElement(&apos;dt&apos;) dt.textContent = parts[0] var dd = document.createElement(&apos;dd&apos;) dd.textContent = parts[1] dl.appendChild(dt) dt.appendChild(dd) output.appendChild(dl) &#125; &#125; button.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.src = &apos;/xxx&apos; document.head.appendChild(script) &#125;&lt;/script&gt; 12345服务器端：else if(path === &apos;/xxx&apos;)&#123; response.setHeader(&apos;Content-Type&apos;,&apos;text/plain;charset=utf-8&apos;) var user = &apos;name: tom , age: 18&apos; response.end(`window.callback(&quot;$&#123;user&#125;&quot;)`) 总结： 发起请求：创造一个script放入页面，script请求一个路径 服务器响应：回调一个函数，这个函数对参数（数据）进行处理分解，构造成有结构的html页面 检测请求是否正确 前端：onerror和onload 123456789//前端出错：可以用onerror来提示：status只要不是2xx就触发onerror button.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.onerror = ()=&gt;&#123; alert(&apos;不好意思，出错了&apos;) &#125; script.src = &apos;/xxxx&apos; //请求路径出错 document.head.appendChild(script) &#125; 123456789后端出错：可以用onload来提示前端请求没问题；只要status是2xx，就触发onloadbutton.onclick=function()&#123; var script = document.createElement(&apos;script&apos;) script.onload = ()=&gt;&#123; alert(&apos;请求没问题，后端出错了&apos;) &#125; script.src = &apos;/xxxx&apos; //请求路径出错 document.head.appendChild(script) &#125; 局限性：不知道具体哪里错误，不知道错误码。 XHMHttpRequest XMLHttpRequest 是一个API, 它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。 在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据 在页面已加载后从服务器接收数据 在后台向服务器发送数据 前身：微软的ActiveX对象，提供给ie的接口（帮你发请求，并且把请求的响应用字符串的形式响应 给你） 火狐跟进：XMLHttpRequest ，用这个对象发请求，并得到响应，并且不会对整个页面刷新。 实例化：var request = new XMLHttpRequest() 方法： abort()：如果请求已经被发送，则立刻终止请求 getAllResponseHeaders()：返回所有响应头信息(响应头名和值) getResponseHeader()：返回指定的响应头的值 请求： 请求行 - open(method,ulr,async)：request.open(&#39;GET&#39; , &#39;/xxx?wd=s&#39;,true)（查询字符串写在url里） 请求头 - setRequestHeader(header,value)：setRequestHeader(&#39;tom&#39;,&#39;18&#39;) 消息体 - send()：发送请求send(&#39;44444&#39;) 12345678&lt;script&gt; button.onclick = ()=&gt;&#123; var request = new XMLHttpRequest() request.open(&apos;POST&apos;,&apos;/xxx?aa=b&apos;) request.setRequestHeader(&apos;tom&apos;,&apos;18&apos;) request.send(&apos;sfsdf&apos;) &#125;&lt;/script&gt; 响应： 获取响应头：request.getAllResponseHeaders() 1234567891011121314&lt;script&gt; button.onclick = ()=&gt;&#123; var request = new XMLHttpRequest() request.open(&apos;POST&apos;,&apos;/xx x?aa=b&apos;) request.setRequestHeader(&apos;tom&apos;,&apos;18&apos;) request.send(&apos;sfsdf&apos;) request.onload = ()=&gt;&#123; console.log(request.getAllResponseHeaders()) &#125; request.onerror = ()=&gt;&#123; console.log(request.getAllResponseHeaders()) &#125; &#125;&lt;/script&gt; 获取响应消息体（第四部分）：request.responseText ／ window.eval(request.responseText) 12345678910111213&lt;script&gt; button.onclick = ()=&gt;&#123; var request = new XMLHttpRequest() request.open(&apos;POST&apos;,&apos;/xxx?aa=b&apos;) request.setRequestHeader(&apos;tom&apos;,&apos;18&apos;) request.send(&apos;sfsdf&apos;) request.onload = ()=&gt;&#123; console.log(request.responseText) //打印出来文本 window.eval(request.responseText) //eval可以执行字符串，即执行了响应的第四部分 &#125; &#125;&lt;/script&gt; 获取响应第一部分：状态行 12状态码 request.status //200状态码描述 request.statusText //OK 精确检查响应的状态：onreadystatechange ，只要readyState变化，这个函数就会被调用 123456789101112request.onreadystatechange = function()&#123; console.log(request.readyState) //01234个值 if(request.readyStatus === 4)&#123; //响应下载完毕 if(request.status &gt;=200 &amp;&amp; request.status &lt;300)&#123; console.log(&apos;成功&apos;) &#125;else&#123; console.log(&apos;失败&apos;) &#125; &#125;&#125;//request.onload //响应下载完毕，而且status是2XX//request.onerror //1.响应出错（未发出、 网络等），2.下载完毕但是status是4xx 5xxx ​ 小结ajax总共有4个过程 , 创建ajax对象：const ajax = new XMLHttpRequest() 连接到服务器： ajax.open(method,url,async) 发送请求： ajax.send() 接收返回的信息： 12345678ajax.onreadystatechange=function()&#123; ajax.readyState //0 未初始化，还没调用open方法 //1 载入，已经调用send()方法，正在发送请求 //2 载入完成，send()方法完成，已经收到全部相应内容 //3 解析，正在解析响应内容 //4(普遍是4) 完成，响应内容完成解析（可能成功，可能失败，用ajax.status来判断。成功时候可以用ajax.responseText来获取响应的内容&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css小结]]></title>
      <url>%2F2017%2F06%2F18%2Fcss%E6%80%BB%E7%BB%93%E7%AF%87%2F</url>
      <content type="text"><![CDATA[字体，文本基础 font-size，font-family，font-weight（regular或者bold加粗），line-height text-align：文本对齐方向 left，right，center text-indent：文本第一行缩进距离 text-decoration：文本下划线none，overline，line-through，underline text-transform：改变大小写none，uppercase，lowercase，capitalize（首字母大写） direction：文本方向 ltr，rtl word-spacing：单词间隔 letter-spacing：字母间隔 white-space： normal（多个空格变为一个，换行变空格） pre（正常） nowrap（在normal的基础上阻止换行） pre-wrap：保留空格，会自动换行 pre-line：合并空白符，保留换行符 文本 text-overflow： clip(修剪)，隐藏超出文本 12overflow:hiddentext-oveflow:clip ellipsis(省略)，需要其他属性配合 123overflow:hiddentext-overflow:ellipsiswhite-space:nowrap word-wrap：允许长单词换行 normal：只在允许的断字点换行，单词过长不会换行会超出文本 break-word：在长单词或 URL 地址内部进行换行。 word-break： normal：浏览器默认规则换行 break-all：允许拆单词换行 keep-all：只能在半角空格或者连字符换行 背景background background-attachment：背景图像是否跟着滚动scroll，fixed background-color background-image：url(‘URL’) background-position：x y（中间没有逗号），top/center/bottom left/center/right background-repeat：no-repeat， repeat-x， repeat-y ， repeat 简写：background: #fff url(test.jpg) no-repeat fixed 0 0 background-size：background-size: length|percentage|cover|contain background-origin：如果background-attachment为fixed则无效 ​ padding-box（相对padding边） ​ border-box（相对border边） ​ content-box（相对于内容框） background-clip：规定背景的绘制区域：padding-box ; border-box ; content-box 边框border简写：border：1px solid（dashed虚线）red； 用border画三角形 12345678p&#123; height:0; width:0; border-top:30px solid rgba(0,0,0,0); border-left:30px solid rgba(0,0,0,0); border-right:30px solid rgba(0,0,0,0); border-bottom:30px solid blue;&#125; padding和margin margin可以是负数 外边距合并，当两个垂直外边距相遇时，会重叠形成一个外边距（以较大的为准） 盒模型box-sizing box-sizing: content-box , 标准盒模型，宽高只包含content的宽高 box-sizing: border-box , ie盒模型，宽高包括了content，padding和border CSS选择器 组合选择 E,F: 多元素选择器 E F: 后代选择器 E&gt;F: 直接子元素选择器 E+F: 直接相邻选择器 E~F: 普通相邻选择器（无论直接相邻与否） 属性选择 E[attr] :匹配所有具有attr属性的元素 ，div[id] ,取到所有具有id属性的div E[attr=value] : 匹配属性值为value的元素，div[id=”haha”] E[attr=value]: 匹配包含value值的元素，` div[class =aaa]可以选到` 伪类选择器 E:first-child: 匹配元素E的第一个子元素 / E:last-child E:link：所有未被电击的链接 E:visited: 已被点击的链接 E:hover: 鼠标悬停 （必须在前两个之前） E:active: 鼠标点击未释放 （必须在hover之前) E:nth-child(n) :匹配第n个子元素，n从1开始(也可取odd，even，2n+1) / E:nth-last-child(n) E:not(selector) 伪元素选择器 E::fefore E::after ：在E元素之后插入生成的内容 定位 static: 正常文档流 relative: 相对于元素本身进行定位，移动的距离会占据文档流空间。 absolute: 绝对定位，脱离文档流 ，相对于static定位以外的第一个祖先元素进行定位。 fixed: 相对于浏览器窗口进行定位 粘性定位sticky: 必须指定top，bottom，left，right中的其中一个值，如top:30px，这个值表示当元素距离页面视口顶部距离大于 30px 时，元素以 relative 定位表现，而当元素距离页面视口小于 30px 时，元素表现为 fixed 定位，会固定在目标位。 可以用于导航栏固定 浮动清楚浮动，在父元素后添加一个伪元素 12345.parent:after&#123; content:&quot;&quot;; display:block; clear:both&#125; 负边距margin当 margin-top 、 margin-left 为负值的时候，会把元素上移、左移，同时⽂档流中的位置也发生相应变化,这点与 position:relative 的元素设置top、left后元素还占据原来位置不同。 垂直居中:利用绝对定位元素的复边距实现 12345position:absolute;top:50%;left:50%;margin-top:-？px; //根据实际元素计算出其自身高度和长度一半的负间距margin-left:-？px; 负边距对float元素：可以覆盖往负边距方向移动 多列布局：固定右边列、 display display: inline（行内元素） ， block（块元素） ， inline-block（表现和行内元素一致，但是支持宽高设定） display:none: 把元素从文档中删除，不会渲染 visibility:hidden: 隐藏，还在文档中，而且占据文档流 text-shadowtext-shadow: x轴 y轴 模糊半径 颜色 text-shdow: 2px 2px 3px #333; box-shadowbox-shadow:inset(内阴影) x-offset y-offset blur-radius(阴影模糊半径) spread-radius(阴影扩展半径) color 渐变 线性渐变：linear-gradient(direction, color-stop1, color-stop2, ...) direction：to top \ to right \ to bottom \ to left 1background:linear-gradient(to top,#ddd,red) //用逗号分隔！ 径向渐变：background: radial-gradient(shape size at position, start-color, ..., last-color); shape：ellipse（默认），椭圆径向渐变 / circle：圆形 at position：at center / at top / at bottom / at 10px 20px / at x% y% 1background:radial-gradient(circle at top,red,yellow) //注意逗号位置 过渡和动画 transition: property duration timing-function delay; property：属性，height，width等 duration：需要多少时间完成 timing-function：linear（匀速），ease-in（加速），ease-out（减速），cubic-bezier(n,n,n,n) delay：多少秒后开始 1transition: width 1s ease-out 2s animation: name duration timing-function delay iteration-count direction fill-mode play-state; iteration-count：播放次数 direction ：reverse（倒放） direction fill-mode：forwards（停在最后的状态） / backwords 123456789div:hover&#123; animation: rainbow 1s&#125;@keyframes rainbow&#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 另外一点需要注意的是，浏览器从一个状态向另一个状态过渡，是平滑过渡。steps函数可以实现分步过渡（一卡一卡的感觉） 123div:hover &#123;animation: 1s rainbow infinite steps(10);&#125; 变形transform-origin：定位变形的点 transform： translate：translateX(x) / translateY(y) 水平移动 rotate：rotateX(deg) / rotateY(deg)/ rotateZ(deg) 沿X,Y,Z轴旋转 perspective:number：透视，一般和旋转配合使用，数字越小，透视效果越明显 skew：skew(deg , deg) / skewX(deg) /skewY(deg) scale：scale(x,y) / scaleX(x) / scaleY(y) 缩放]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>%2F2017%2F06%2F13%2F%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[模块化 各种全局变量 12345678var $topbar = $(&apos;#topbar&apos;)$topbar.on(&apos;click&apos;,functuion()&#123; console.log(&apos;topbar&apos;)&#125;)var $banners = $(&apos;#banners&apos;)$banners.on(&apos;click&apos;,function()&#123; console.log(&apos;banners&apos;)&#125;) 用立即执行函数消除全局变量（或者用{}块级作用域+let） 12345678910111213141516171819!function()&#123; var $topbar = $(&apos;#topbar&apos;) $topbar.on(&apos;click&apos;,functuion()&#123; console.log(&apos;topbar&apos;) &#125;)&#125;() //让这些变量变成局部变量，放进一个函数里并且调用，但是函数前要加上一个符号（+,-,!等）!function()&#123; var $banners = $(&apos;#banners&apos;) $banners.on(&apos;click&apos;,functuion()&#123; console.log(&apos;banners&apos;) &#125;)&#125;()------------------&#123; let $topbar = $(&apos;#topbar&apos;) $topbar.on(&apos;click&apos;,functuion()&#123; console.log(&apos;topbar&apos;) &#125;)&#125; //或者用es6语法:块级作用域，局部变量 按照上述方法，作用域与作用域之间是隔开的，如果作用域B想使用作用域A的变量，怎么办？可以使用两个作用域都能访问到的全局变量window，作为桥梁，赋值给window属性并访问 123456789101112!function()&#123; var $topbar = $(&apos;#topbar&apos;) var user = &#123; name:&apos;yom&apos;, age:20 &#125; window.user = user //全局变量&#125;() !function()&#123; console.log(window.user)&#125;() 如果不能让别的作用域改user，只能读（暴露一个函数，不要暴露整个变量） 123456789101112131415!function()&#123; var $topbar = $(&apos;#topbar&apos;) var user = &#123; name:&apos;yom&apos;, age:20 &#125; window.user = &#123; nameGetter:function()&#123;return user.name&#125;, ageGetter:fucntion()&#123;return user.age&#125; &#125;&#125;() !function()&#123; console.log(window.user.nameGetter) //yom&#125;() 什么时候闭包：只要一个函数使用了它外面的变量，这个函数就是闭包，闭包是指这个函数以及它能访问到的这个变量。闭包是作用域的一种特殊的使用方式。 举例：年龄增长器 1234567891011function olderMaker()&#123; var user = &#123; name:&apos;jack&apos;, age:18 &#125; return function()&#123; user.age += 1 &#125;&#125;var older = olderMaker() //函数older.call() 每call一下，年龄增加一岁 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工厂模式&new]]></title>
      <url>%2F2017%2F06%2F05%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-new%2F</url>
      <content type="text"><![CDATA[工厂模式用函数构造一个对象，并且返回这个对象，叫做工厂模式（可以批量生产）。 工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型) 123456789function Dog(name,age)&#123; var dogs=&#123;&#125; dogs.name=name dogs.age=age dogs.leg=4 dogs.type=&apos;短腿&apos; return dogs&#125;Dog(&apos;tom&apos;,6) // Object &#123;name: &quot;tom&quot;, age: 6, leg: 4, type: &quot;短腿&quot;&#125; 构造函数模式（即new）12345678910111213141516171819202122function Dog(name,age)&#123; var dogs=&#123;&#125; ----1.new帮忙创建临时对象 dogs.name=name dogs.age=age dogs.__proto__=Rdogs -----2.new帮忙绑定原型，并同意叫做prototype return dogs -----3.帮忙return&#125;Rdogs=&#123; leg:4, type:&apos;短腿&apos;&#125;Dog(&apos;tom&apos;,18) -----------------------------使用new,把共有的特性放在原型链上，私有的属性放在构造函数上function Dog(name,age)&#123; -----构造函数一般函数名首字母大写 this.name=name ------构造函数依赖 new、this this.age=age -----构造函数什么都不返回，只有new才能帮它return对象&#125;Dog.prototype=&#123; leg:4, type:&apos;短腿&apos;&#125;new Dog(&apos;tom&apos;,18) debugger一下，可以看到this已经有共有属性了，这是因为下面定义对象的时候内存里马上就赋值了，上面的是函数，等着调用才会去执行。 new会帮你return，但是如果自己写上return的话，会怎么样？（new会帮你return this，在new之前的构造函数里加了自己的return，那么new执行不到，所以构造函数不要瞎return） 如果构造函数里自己写了return this，而调用的时候不写new，会出现什么呢？（直接调用一个函数，this就是window） 生成对象并且改变this（帮你生成一个对象，this指向这个对象） 如果我不想加 new，但是又想实现跟 new 一样的功能（加条件判断，帮忙加new） jQuery是一个构造函数，返回一个对象，返回的对象有原型，所以它有new，做了以上类似的处理，所以我们调用的时候不需要些new new会帮忙添加constructor属性 如果像上面那样写Dog.prototype={}，这样就引向了另外一块地址，把原来的constructor属性覆盖了，所以推荐把constructor属性加上去constructor:Dog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS动画基础]]></title>
      <url>%2F2017%2F05%2F28%2FCSS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[transformtransform指变换，使用过photoshop的人应该知道里面的Ctrl+T自由变换。transform就是指的这个东西，拉伸，压缩，旋转，偏移，且transform 属性 , 只对 block 级元素生效！（配合transition过渡） 平移： 123transform: translate(tx[, ty]) translateX(tx) x轴方向平移 translateY(ty) 角度旋转：transform: rotate(angle) 缩放： 123transform: scale(sx[, sy]) scaleX(sx); x轴方向缩放 scaleY(sy) 倾斜： 123transform: skew(ax[, ay]) skewX(angle) skewY(angle) 旋转中心：transform-origin:x-axis y-axis z-axis (值：left，right，center，length，%) transition transition提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。(即平滑地改变css的属性值) 语法： transition：property name | duration //过渡时间 ​ transition： property name | duration | delay //过渡时间、延长时间 ​ transition：property name | duration | timing function | delay //过渡时间、效果、延长时间 ​ transition: margin-left 4s, color 1s //两个属性用逗号隔开 ​ transition: all 0.5s ease-out //all transition-property :指定过渡的性质，比如transition-property:backgrond 就是指backgound参与这个过渡 transition-duration:指定这个过渡的持续时间 transition-timing-function:指定过渡类型，有ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier（贝塞尔曲线） transition-delay:延迟过渡时间 123456transition-timing-function: linear 匀速 ease 慢-快-慢 ease-in 先慢后快 ease-out 先快后慢 ease-in-out 先慢后快再慢 cubic-bezier(n,n,n,n); 自定义（http://cubic-bezier.com/） perspective perspective 属性指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。 默认情况下，透视消失点位于元素的中心，但是可以通过设置perspective-origin属性来改变其位置。在父容器上设置perspective（相当于远处的舞台），会让元素指向透视的消失点。 1perspective-origin: x-axis y-axis (值：left，right，center，length，%) 注：perspective在Z轴上，而perspective是设置Z轴的长度。在css3中只有设置了perspective的值元素才会有Z轴，perspective为none元素则没有Z轴(就是2D元素)。 animation &amp; keyframes 创建动画序列，需要使用animation属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 @keyframes规则实现。 语法：animation: name duration timing-function delay iteration-count direction; animation-name: 规定需要绑定到选择器的 keyframe 名称。 animation-duration: 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function: ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier（贝塞尔曲线） animation-delay:设置延时，规定在动画开始之前的延迟。 animation-iteration-count: infinite|小数定义循环（0.5将播放动画到一半）设置动画重复次数， 可以指定infinite无限次重复动画. animation-direction: normal|alternate（交替反向运动）|reverse|alternate-reverse 设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行。 animation-play-state: running|paused 暂停和恢复动画 一旦完成动画的时间设置， 接下来就需要定义动画的表现。通过使用@keyframes建立两个或两个以上关键帧来实现。每一个关键帧都描述了动画元素在给定的时间点上应该如何渲染。 要使用关键帧, 先创建一个带名称的@keyframes规则，以便后续使用 animation-name这个属性来调用指定的@keyframes 关键帧使用百分比来指定动画发生的时间点。0%表示动画的第一时刻，100%表示动画的最终时刻。因为这两个时间点十分重要，所以还有特殊的别名：from和to。 @keyframes 不存在层叠样式(cascade)的情况，如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 小结：animation定义动画的时间，keyframes定义动画的效果。 举例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中的this值]]></title>
      <url>%2F2017%2F05%2F21%2FJS%E4%B8%AD%E7%9A%84this%E5%80%BC%2F</url>
      <content type="text"><![CDATA[什么是Thisthis总是返回一个对象，即返回属性或者方法“当前”所在的对象。在JavaScript语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是这个对象（环境）。也可以近似地认为，this是所有函数运行时的一个隐藏参数，指向函数的运行环境。 如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。 123function fn()&#123; console.log(this) //window&#125; 函数的call任何函数都可以用function.prototype.call()的形式来调用，其中call的第一个参数会变为函数里的this，call的其他参数组成函数里面的arguments。 123456789101112function f()&#123; console.log(this) console.log(arguments)&#125;var a =&#123;name:&apos;tom&apos;&#125;f.call(a,1,2,3) *call第一个参数会当作this，后面的会当做arguments*每次进入函数之前，都会创造this和arguments这两件事情---------------f()等价于f.call（）object.f(1,2,3)等价于 obj.f.call(obj,1,2,3) //this为obj this 就是你 call 一个函数时，传入的第一个参数 12345678910111213141516var A = &#123; name: &apos;Tom&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var B = &#123; name: &apos;Jack&apos;&#125;;B.describe = A.describe;A.describe() //&quot;姓名：Tom&quot;B.describe() // &quot;姓名：Jack&quot;--------------A.describe() 转换为 A.describe.call(A)，this就是A，那么this.name即 Tom；同样的，B.describe() 可以转换为B.describe.call(B),this就是B，那么this.name即Jack 如何确定this的值1.看源码中对应的函数是怎么被call的 2.看文档 123btn.addEventListener(&apos;click&apos; ,function handler()&#123; console.log(this) // 请问这里的 this 是什么&#125;) EventTarget.addEventListener()处理过程中 this 的值的问题，在MDN文档中是这样说的： 通常来说this的值是触发事件的元素的引用，这种特性在多个相似的元素使用同一个通用事件监听器时非常让人满意。 当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 currentTarget 属性的值一样。 所以，上面this指的就是事件被监听的元素btn 3.打印出来console.log(this)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS调试]]></title>
      <url>%2F2017%2F04%2F25%2FJS%E8%B0%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[史上第一个bug1947年9月9日，葛丽丝·霍普（Grace Hopper）发现了第一个电脑上的bug。当在Mark II计算机上工作时，整个团队都搞不清楚为什么电脑不能正常运作了。经过大家的深度挖掘，发现原来是一只飞蛾意外飞入了一台电脑内部而引起的故障。这个团队把错误解除了，并在日记本中记录下了这一事件。也因此，人们逐渐开始用“Bug”（原意为“虫子”）来称呼计算机中的隐错。 debug 就是找出 bug 的过程。 打字会错123456iOS 写成 iosJavaScript 写成 Javascriptvertical 写成 verticelprops 写成 porps半角空格写成全角空格ls -la 写成 ls-la html的bug 用https://validator.w3.org/#validate_by_input这个网址来检查错误（validator验证器） 用WebStorm检查（语法错误以及拼写错误） CSS的bug用border以及开发者工具 没有样式，选择器没有选择到，(.tabsb li b 后面多了个逗号,) CSS错误的注释会毁掉下面一行 用border大法可以清楚地看到由于浮动而造成的符元素内容塌陷 当使用border会影响布局的时候，用outlne代替，它不会占用盒模型位置 VS. JavaScript的bug 确定你的代码运行了 上帝视角 拼写错误 拼写错误 拼写错误 其他错误（用 WebStorm 可以避免拼写错误） 用 console.log 或者 console.assert 验证 html文件映射到浏览器页面，直接在浏览器中修改调试 打开谷歌开发者工具 — setting — workspace — add folder 映射 Map to File System Resource 按下esc，出现控制台，就可以实时修改了，修改完按下保存再刷新，进行调试。 Uncaught ReferenceError:appel is not defined：用了一个未声明过的变量。（reference error 引用错误） 把它打印出来是什么类型 Uncaught TypeError: obj.fooo is not a function：不是一个函数 （type error类型错误） 打印出来，属性不报错，返回undefined （变量未声明直接用回报错，属性没声明直接用不报错） Uncaught SyntaxError: Unexpected token function ：未意料到的字符 function ，说明语法有错误（foo:function） （syntax error语法错误） Uncaught TypeError : Cannot read property ‘join’ of undefined：jion前面的出现错误]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM API获取元素的几种方法]]></title>
      <url>%2F2017%2F04%2F19%2FAPI%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%9D%2F</url>
      <content type="text"><![CDATA[DOM节点DOM的最小组成单位叫做节点（node）。文档的树形结构（DOM树），就是由各种不同类型的节点组成。节点有以下7种类型 Document：整个文档树的顶层节点（root node） DocumentType: doctype标签 Element：网页的各种HTML标签 Attribute：网页元素的属性（如calss=”aa”) Text：标签之间包含的文本内容 Comment：注释 DocumentFragment：文档片段 节点间的关系除了根节点&lt;html&gt;，它的下级节点与周围节点存在三种关系 父节点关系：parentNode 子节点关系：childNodes firstChild：第一个子节点 lastChild：最后一个子节点 同级节点关系：sibling nextSibling：紧邻在后的那个同级节点 previousSibling：紧邻在前的那个同级节点 document.querySelector()接受一个css选择器作为参数，返回匹配该选择器的第一个节点，如果没有匹配的节点返回null。 语法：element = document.querySelector(selectors) ，selectors是一个字符串，包含一个或者多个css选择器，多个以逗号分隔。 123var element1 = document.querySelector(&apos;.myclass&apos;)var element2 = document.querySelector(&apos;p&apos;) //返回第一个p元素var element3 = document.querySelector(&apos;p.myclass&apos;) //返回文档中class=&quot;myclass&quot;的第一个&lt;p&gt;元素 *document.querySelectorAll()：返回一个NodeList对象，包含所有匹配给定选择器的节点 document.getElementsByTagName()返回一个包括所有给定标签名称的元素集合，如果没有匹配的元素，返回一个空集。可以在任意一个元素上调用该方法。（从给定的父节点开始往下找，如果是div.getElementsByTagName()，则从div这个节点开始往下找） 语法：var elements = document.getElementsByTagName(name)，name是一个字符串。 12var a = document.getElementsByTagName(&apos;p&apos;)//返回当前文档的全部p元素节点 document.getElementsByClassName()返回一个包含所有指定class名称的元素集合，可以在任意元素上调用该方法。 语法：var elements = document.getElementsByClassName(names)，names是一个字符串，如果含有多个class名称，用空格分隔。 12document.getElementsByClassName(&apos;red test&apos;)//返回所有calss名为 red 和 test 的元素 document.getElementById()返回拥有指定id的第一个元素，如果不存在则返回null 语法：element = document.getElementById(id)，id为大小写敏感的字符串 12document.getElementById(&apos;myid&apos;)//返回一个id为myid的元素 Node.firstChild返回树中节点的第一个子节点，如果无子节点，则返回null。（注：空白符节点会充当一个文本节点，可以Node.firstChild.firstChild…的形式使用） 类似的还有：Node.lastChild \ Node.nextSibling \ Node.previousSibling \ Node.parentNode 12345678&lt;p id=&quot;para-01&quot;&gt; &lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var p01 = document.getElementById(&apos;para-01&apos;); alert(p01.firstChild.nodeName)&lt;/script&gt;//返回#text , 因为换行符和空格充当了一个文本节点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM事件委托]]></title>
      <url>%2F2017%2F04%2F19%2FDOM%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
      <content type="text"><![CDATA[事件的三个特点 TOM （代码）订阅/关注/监听了 XXX（用户） XXX （用户）发生了变化 TOM（代码）得到通知 捕获&amp;冒泡 操作系统最先知道用户点击了鼠标，浏览器次之 child 被点击了，意味着 parent 也被点击了 如果同时监听了child和parent，那么 捕获阶段：先通知parent，后通知child 123456child.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;child&apos;)&#125;,true)parent1.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;parent1&apos;)&#125;,ture) //添加ture参数，表示捕获阶段 冒泡阶段：先通知chlid，后通知parent 123456child.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;child&apos;)&#125;,flase)parent1.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;parent1&apos;)&#125;,flase) //默认为flase，冒泡阶段 W3C事件模型：支持两种阶段 12button.addEventListener(&apos;click&apos;,fn,true) //永远别用button.addEventListener(&apos;click&apos;,fn) 如何监听事件当同一个对象使用.onclick的写法触发多个方法的时候，后一个方法会把前一个方法覆盖掉，也就是说，在对象的onclick事件发生时，只会执行最后绑定的方法。而用事件监听则不会有覆盖的现象，每个绑定的事件都会被执行。 DOM level 0 事件： button.onclick = function(){} DOM level 2 事件： button.addEventListener(‘click’, function(){}) e／event1234child1.addEventListener(&apos;click&apos;,function(e)&#123; console.log(e)&#125;)//当出发事件的时候，e告诉你相关事件的任何信息 e.target&amp;e.currentTarget target：触发事件的元素，即点击的元素 currentEvent：被监听的元素 以下图片先点击绿色边框（parent），然后再点击红色区域（child） 阻止默认事件 e.preventDefault()如果加在父元素上，对其子元素也有阻止事件的作用，所以尽量用在要阻止事件的具体子元素上，以免让其他事件失效（图中阻止了a链接的跳转作用，点击百度不会发生跳转） 停止冒泡e.stopPropagation()propagation:传播的意思。 用户点击了子元素，不要向父元素通知。 事件委托 事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。简而言之就是委托它们的父级代为执行事件。 没有时间委托，逐个监听事件 监听是占用内存的，既然4个li做了相同的事情，那么直接监听父元素，同样点击li元素可以实现。（但是有一个问题就是父元素里面的所有内容都会触发事件，包括点击父元素的padding。） 那么添加一个if条件e.target.nodeName === &#39;LI&#39;，让触发事件的目标在元素LI 上，此时解决了上面li元素外和父容器之间也会触发事件的问题。（但是又引申出了一个新的问题，就是点击LI的后代元素无法触发事件。这和初衷不相符。） 再修改一下if条件，e.target.nodeName ===&#39;LI&#39;||e.target.parentNode.nodeName === &#39;LI&#39; , 让LI的span元素也能触发事件，此时的委托事件正好满足这个例子。（但是如果li有多个后代元素，又无法满足条件了。） 再完善一下，我要点击后代元素触发事件，要判断其父元素是不是LI ，如果不是，继续网上找，直到找到li 。（但这样会出现找不到LI的情况，一直网上找到document，再网上就返回null了。） 继续完善，网上找的过程中，如果一直到监听的哪一层元素还没找到，那就停止，返回null。 123456789101112131415161718//较为完整的事件委托代码var ul = document.querySelector(&apos;ul&apos;)function f(e)&#123; let el = e.target while(el.nodeName !== &apos;LI&apos;)&#123; if(el === ul)&#123; el = null break; &#125; el = el.parentNode &#125; if(el)&#123; console.log(&apos;ok&apos;) &#125;else &#123; console.log(&apos;no&apos;) &#125;&#125;ul.addEventListener(&apos;click&apos;,f)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js内存图]]></title>
      <url>%2F2017%2F04%2F03%2Fjs%E5%86%85%E5%AD%98%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[栈（stack） 基本类型是保存在栈内存中的简单的数据段，数据大小确定并且占有固定大小的空间，它们是按值存放的，所以可以直接访问。基本类型有Number , String , Null , Undefined , Boolean , symbol。 基本类型的拷贝是传值 123456var a = 1var b = 2b = aa = 8// 此时b的值为1*基础类型的变量发生复制行为时，直接把a对应的值copy给b，b=1。它们两个变量的值是相互独立不影响的，所以当改变a的值为8时，b的值不会跟着改变仍然为1 堆（heap） 引用类型（复杂类型），即Object（数组，对象，函数等），它们的值是不固定的，存储方式是在堆内存中存储对象，在栈内存中存储该对象的地址（该地址指向对应的对象） 复杂类型的拷贝是传址 123456var a = &#123;m:10&#125;var b = &#123;n:20&#125;b = aa.k = 30b = &#123;m:10 , k:30&#125;*复杂类型的变量发生复制时，复制的是栈内存中的地址，然后指向堆内存中的同一个对象，所以当对象内容发生变化时，两者都会相应地发生改变。 浅拷贝（把栈里面的东西拷贝一遍）如上面举的例子，b拷贝了a后，它们同时指向同一个内存，此时只要改变a或b其中任何一个变量的值，另外一个值就会跟着改变，这种就是浅拷贝。 深拷贝（把堆里面的东西拷贝一遍）b拷贝了a后，在堆内存中重新开辟一个内存来存储b的值，此时指向不同的地址，相互独立。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见的几种排序算法简介]]></title>
      <url>%2F2017%2F03%2F25%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[冒泡排序（bubble sort） 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 比较每一对相邻的两个元素，大的元素放后面，那么比较完一轮后，最后的元素应该是确定的最大的数。 针对所有的元素重复以上的步骤，除了最后一个数（上一轮确定下来的最大的数），直到没有任何一对数字需要比较，排序完成。 选择排序（selection sort） 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 插入排序（insertion sort） 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 从第一个元素开始（该元素可以认为已经被排序），然后取出下一个元素，在已经排序的元素序列中从后向前扫描 依次比较大小，如果前面一个元素比自己大，就继续向前比较，知道找到比自己小的元素，并排在这个元素后面。 重复以上步骤，直到最后一个元素比较完，排序完成。 归并排序（merge sort）通常用递归实现，先把待排序区间[s,t]以中点二分，分成左右区间，接着左右区间继续中点二分，分成更小的左右区间，一层层直到分到单个元素的左右区间，然后一个个小的左右区间比较大小排序并且一层层往上归并，最后把左区间和右区间合并成有序的区间[s,t]。 快速排序（quick sort） 把要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 从数列中挑出一个元素，称为”基准”（pivot） 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作。 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 #### 动手玩一下算法动态演示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS定位position]]></title>
      <url>%2F2017%2F03%2F22%2FCSS%E5%AE%9A%E4%BD%8Dposition%2F</url>
      <content type="text"><![CDATA[position属性指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型。 relative相对定位position:relative ：元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。通过“left”,”top”,”right”,”bottom”来规定位置。 *相对定位的元素并未脱离文档流 注：图二chlid1相对自己原来的位置向右移动了50px，但是child2作为一个行内元素并没有向前移动，去占据child1留下来的空白位置（说明child1原来的位置仍然被它占据着） absolute绝对定位position:absolute ：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置(如果没有祖先元素，则用它所在的包含块来定位）。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。通过“left”,”top”,”right”,”bottom”来规定位置。 *绝对定位的元素脱离了文档流 有非 static 定位的祖先元素 当最近的祖先元素添加position:relative 后，child1根据它来定位。 child1设置了absolute绝对定位后，它的宽度变成了30px，变成了块状元素，即使后面再次声明display:inline; ，它还是以块状元素来显示。 没有非 static 定位的祖先元素 可以看到child1并非根据body以及html来定位。经查css spec（如下图），在没有非static定位的祖先元素的时候，absolute定位是根据根元素的包含块（containing block）来定位的，根元素的包含块也叫初始包含块（initial containing block）, 而初始包含块取自视口的尺寸，并且被固定在画布开始的位置。 fixed绝对定位position:fixed ：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。通过“left”,”top”,”right”,”bottom”来规定位置。 *绝对定位的元素脱离了文档流，比浮动元素更高一层。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css浮动]]></title>
      <url>%2F2017%2F03%2F20%2Fcss%E6%B5%AE%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[浮动float CSS的 float 属性可以使一个元素脱离正常的文档流，然后被安放到它所在容器的的左端或者右端，并且其他的文本和行内元素环绕它。 元素只能左右浮动，不能上下移动 一个浮动会尽量向左/右 移动，直到它的外边缘碰到包含框或者另一个浮动框的边框为止 浮动元素之后的元素会围绕它，之前的元素不受影响 语法 说明 float: left 表明元素必须浮动在其所在的块容器左侧 float: right 表明元素必须浮动在其所在的块容器右侧 清除浮动clear clear属性规定了元素的哪一侧不允许浮动元素 语法 说明 clear : left 在左侧不允许浮动元素 clear : right 在右侧不允许浮动元素 clear : both 在左右两侧均不允许浮动元素 清除浮动的几种方法 从上面两张图可以看到，当内层元素加了浮动之后，div的高度塌缩了，因为内层元素此时已经脱离了文档流，父元素不再包含它。为了避免这种情况，可以清除浮动来使父元素撑开。 使用一个空标签：空标签位置不同效果也不同。 通过 ::after 伪元素 设置clear属性:.parent::after这中间没有空格！！ 123456/* new clearfix */.clearfix::after &#123; #css3为了更好地区分伪类和伪元素，用两个冒号:表示 content: &quot;&quot;; #通过content属性来添加样式（显示生效）使用一个空标签 display: block; #::after表示在当前元素的内容后插入一个子元素（行内元素） clear: both;&#125; 给父元素设置display: inline-block属性: 由块状元素转为行内元素，而行内元素可以根据里面的内容自适应高宽（为了显示出相同的效果，这里加了width：100%）。 给父元素设置overflow:auto或hidden属性：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局（display:flex）]]></title>
      <url>%2F2017%2F03%2F19%2Fflex%E5%B8%83%E5%B1%80%EF%BC%88display-flex%EF%BC%89%2F</url>
      <content type="text"><![CDATA[基本概念flex布局适用于简单的线性布局，可以实现空间自动分配和自动对齐。（flexible：弹性，灵活的） flex container的属性 属性 描述 1、flex-direction 方向 2、flex-wrap 换行 3、flex-flow 上面两个的简写 4、justify-content 主轴方向对齐方式 5、align-items 侧轴对齐方式 6、align-content 多行/列内容对齐方式（用的较少） flex-direction：row（从左往右排列，默认）、row-reverse（右往左）、column（上往下）、column-reverse 注：这个属性的排序默认不换行，flex item再多也会自适应调节比例排成一行/列（且此时会无视flex item自身设置的宽/高）。 flex-wrap：wrap flex-flow：row nowarp justify-content： space-between：空间均衡地放在flex item中间，两边的flex item会顶到两侧 space-around：空间均衡地放在flex item周围，最两侧的flex item也有空间包围 flex-start：flex item都往起点靠 flex-end：flex item都往终点靠 center：flex item都放在中间 align-items： stretch：与flex item最长的那一个对齐，是个默认值 flex-start：所有的flex item都往上靠 flex-end：所有的flex item都往下靠 center：居中 baseline：文字基线对齐 align-content：space-around、space-between、flex-start、flex-end flex item的属性 属性 描述 1、flex-grow 增长比例（空间过多时） 2、flex-shrink 收缩比例（空间不够时） 3、flex-basis 默认大小（一般不用） 4、flex 上面三个的缩写 5、order 顺序（代替双飞翼） 6、align-self 自身的对齐方式 flex-grow：数值（1、2、3等），flex item按这个数值的比例分配多余的空间（1表示全部占有） flex-shrink：数值（1、2、3等），flex item按收缩比例分配 flex-basis：200px ， 一开始默认占200px大小的固定空间 order：数值（1、2、3等），改变flex item的空间顺序 align-self： flex-end，flex-start ， center ， 每个独立flex-item对齐。 使用flex布局实例 手机页面布局（topbar+main+tabs) 产品列表（ul&gt;li*9 pc页面布局 完美居中 一个熟练flex属性的网页小游戏http://flexboxfroggy.com/#zh-cn *最后一关： 1234567#pond &#123; display: flex; flex-flow:column-reverse wrap-reverse; align-items:flex-end; justify-content:center; align-content:space-between&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[post和get请求]]></title>
      <url>%2F2017%2F03%2F12%2Fpost%E5%92%8Cget%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[get和post的区别GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同（唯一的区别是语义区别：get是获取数据，post是提交数据） 表象的区别： get post 一般没有请求消息体 有请求消息体 请求的参数包含在请求行的URL中 参数放在请求的消息体里 url中传送的参数长度有限制（浏览器一般设置2k个字节） post消息体的数据可以非常大（一般几兆） 安全性相对较低（get提交数据后账号和密码明文出现在url上） 相对较高 注 #HTTP协议中，HTTP的请求头和消息体都没有长度的要求。对url长度上的限制，是由于浏览器和服务器两方面造成的（出于安全考虑 [避免被过大的url不停攻击] 和 稳定的考虑，会给url长度加一个限制。 这个限制是针对所有http请求的。 ​ #post和get的安全性只是相对这两者比较而言的，事实上两种方式都不安全。 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[请求和响应]]></title>
      <url>%2F2017%2F03%2F12%2Fhttp%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
      <content type="text"><![CDATA[HTTPhttp（HyperText Transfer Protocol），超文本传输协议，它是一种网络协议，所有的www文件都必须遵守这个标准。可以说，web是建立在http协议上通信的。 DNSdns（DomainName System），域名系统（域名解析系统），主要让用户在互联网上通过域名找到对应的ip地址，而不用去记住能够被机器直接读取的IP数串。 输入：域名 ， 输出：IP 一个域名对应的ip可以有很多（eg：ping baidu.com) 一个域名对应的ip是由域名所有者指定的 改 hosts 可以手动指定域名对应的 IP DNS 可能有缓存，浏览器或者运营商 端口 TCP 或 UDP 协议的规则，一个端口对应一个服务 0 到 1023 号端口是保留端口（只有管理员才能用） 常用端口 21 端口 - FTP 80 端口 - HTTP 53 端口 - DNS 443 端口 - HTTPS 1080 端口 - SOCKS 代理 请求和响应我们在浏览器中输入Google网址到Google网页跳转出来，就经历了一次完整的请求和响应。请求由客户端（即浏览器）发出，响应由服务器端发出。 请求分析123456请求行:（请求方法 路径 协议／版本号） #eg: GET /index.html HTTP/1.1请求头: 请求首部字段 通用首部字段 实体首部字段空格消息体:（aaa=bbbb&amp;ccc=ddd） 注：一般的请求方法有：POST \DELETE \PUT \PATCH \GET \HEAD \OPTIONS \CONNECT \TRACK 响应分析123456状态行 （协议／版本号 状态码 状态描述）#eg:TTP/1.1 200 OK响应头：响应首部字段 通用首部字段 实体首部字段空格消息体 状态码状态码的类别： 类别 原因 1XX Informational（信息状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常，200 3XX Redirection（重定向状态码） 301、302(move temporarily ) 4XX Client Error（客户端错误状态码） 403、404、414 5XX Sever Error（服务器端错误状态码） 500（internal sever error) 一些常见的状态码 状态码 状态描述 200：OK 请求成功 301:moved permanently 请求的资源重定向了，永久移动到新位置（并且浏览器缓存这个结果） 302：move temporarily 请求的资源临时从不同的 URI响应请求。 （浏览器不缓存这个结果） 403:forbidden 服务器拒绝访问。 404:not found 请求失败，请求的资源未在服务器上发现。 405:method not allowed 请求行中指定的请求方法不能被用于请求相应的资源。 414:request-url too long 请求的uri长度超过了服务器能够理解的长度，因此拒绝提供服务。 500:internet server error 服务器遇到了一个未曾预料的状况，导致它无法完成对请求的处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH验证]]></title>
      <url>%2F2017%2F03%2F11%2FSSH%E9%AA%8C%E8%AF%81%2F</url>
      <content type="text"><![CDATA[SSH（ Secure Shell ）是一种网络安全协议，用于计算机之间的加密登入。 两种验证方式： 基于口令的安全验证：输入账号和密码来登入到远程主机，虽然传输的数据都会被加密，但是如果有 ‘中间人’ 冒充我们要访问的服务器，那我们的账号密码就会被 ‘中间人’ 盗取 基于密钥（yuè）的安全验证：用户有两把密钥，一把公钥（对外公开），一把私钥（自己保管）。用ssh公钥登入远程主机，可以免去每次输入密码。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的用户公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。 1命令行操作：ssh-copy-id + url ，把自己的公钥传送存储在远程主机上。 公钥和私钥间的关系： 公钥和私钥是成对的，他们相互解密 公钥加密，只有私钥才能解密，保证数据安全传输 私钥加密签章（数字签名），公钥解密验章用来验证确认对方的身份，用hash函数解密摘要对比来确定信息是否被篡改 数字证书：由CA机构（certificate authority，证书中心）颁发，为公钥做认证，在网上用来识别他人身份的真实性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[input 标签详解]]></title>
      <url>%2F2017%2F03%2F11%2Finput%20%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[input标签用于搜集用户信息，一般放在标签下，根据不同的type属性值，输入字段拥有很多种形式，可以是文本、复选框、按钮等。 一般跟随method属性和action属性，表示如何发送表单数据到action属性所规定的页面 type属性规定input元素的类型，type属性不是必需的，但是应该始终使用它1eg: &lt;input type=&quot;value&quot;&gt; ####type属性及其他常见属性 type=”text” ：默认，定义单行输入字段，用户可在其中输入文本。超出输入字符会继续往后输入，不会换行，也不会调整文本框大小。 type=”password” ：定义密码字段，字段中的字符会被遮蔽。（但是提交上去后密码是可见的，需要其他手段进行加密 其他属性：value \ placeholder \ maxlength \ size \ readonly 123456&lt;form&gt; &lt;input type=&quot;text&quot; value=&quot;hhh&quot;&gt; #value表示显示在文本框中的值，用户输入的时候需要删除 &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; maxlength=&quot;4&quot;&gt; #placeholder作用为提示，文本框中呈灰色字体，输入的时候自动消失，maxlength表示最大能输入的字符（即只能输入4个字符的密码） &lt;input type=&quot;text&quot; size=&quot;30&quot;&gt; # size会生成一个可见30个字符大小的文本框 &lt;input type=&quot;text&quot; value=&quot;hhh&quot; readonly&gt; # readonly是没有值的属性，表示只读，无法修改输入。&lt;/form&gt; type=”button”：定义可点击的按钮（大多与 JavaScript 使用来启动脚本） type=”submit”：定义提交按钮，向服务器发送数据 1234&lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; type=”range” ：定义带有 slider 控件的数字字段。 type=”number” ：定义带有 spinner 控件的数字字段 type=”checkbox” ：定义复选框。 type=”radio”：定义单选按钮。 其他属性：min \ max \ step 12345678910&lt;form&gt; &lt;input type=&quot;range&quot; min=&quot;-10&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;8&quot;&gt; # min和max规定输入的最小和最大值，创建合法值的范围，step表示间隔，value表示初始值 &lt;input type=&quot;number&quot; min=&quot;-100&quot; max=&quot;200&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;小狗 &lt;input type=&quot;checkbox&quot; checked&gt;小猫 #checked表示预先选择该input元素，长与radio和checkbox配合使用） &lt;input type=&quot;radio&quot; name=&quot;a&quot; checked&gt;西瓜 #相同的name值表示3个选项只能选择其一 &lt;input type=&quot;radio&quot; name=&quot;a&quot;&gt;黄瓜 &lt;input type=&quot;radio&quot; name=&quot;a&quot;&gt;苦瓜&lt;/form&gt; type=”color” ; type=”time” ; type=”week” ; type=”month” ; type=”date” ; type=”datetime-local” 123456789&lt;form&gt; &lt;input type=&quot;email&quot;&gt; #定义用于 e-mail 地址的文本字段 &lt;input type=&quot;color&quot;&gt;&lt;br&gt; #定义拾色器 &lt;input type=&quot;time&quot;&gt;&lt;br&gt; #定义时、分、秒（带有 time 控件） &lt;input type=&quot;week&quot;&gt;&lt;br&gt; #定义周（带有 calendar 控件） &lt;input type=&quot;month&quot;&gt;&lt;br&gt; #定义月（带有 calendar 控件） &lt;input type=&quot;date&quot;&gt;&lt;br&gt; #定义日期（带有 calendar 控件） &lt;input type=&quot;datetime-local&quot;&gt; #定义日期及时间（带有 calendar 和 time 控件） &lt;/form&gt; ​ type=”hidden” : 隐藏输入字段，但是提交表单会一起被提交上去 type=”image” : 定义图像作为提交按钮 ; width \ height \ ale 属性 123&lt;form&gt; &lt;input type=&quot;image&quot; src=&quot;image url&quot; width=&quot;30px&quot; alt=&quot;红色按钮&quot;&gt; #width属性调节图片大小(height类似），alt属性表示图片的替代文本 &lt;/form&gt; type=“file” ：提供供文件上传 ；required \ multiple 属性 1234&lt;form&gt; &lt;input type=&quot;file&quot; required&gt; #required 指示输入的字段值是必需的，一次只能上传一个文件，默认也是上传一个 &lt;input type=&quot;file&quot; mulitple&gt; #multiple 允许一个以上的值，可以一下子上传多个文件&lt;/form&gt; 其他属性：list：引用包含输入字段的预定义选项 datalist ，datalist下面接option属性用来提供选择项目，datalist需要type=”text” , 并指定一个id 12345678&lt;form&gt; &lt;input type=&quot;text&quot; list=&quot;datalist1&quot;&gt; #可以预选项里选择，也可以自定义输入其他 &lt;datalist id=&quot;datalist1&quot;&gt; &lt;option&gt;西瓜&lt;/option&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option&gt;香蕉&lt;/option&gt; &lt;/datalist&gt;&lt;/form&gt; select元素（包含在标签里），下面也是接option属性来提供选择项目 1234567&lt;form&gt; &lt;select&gt; &lt;option&gt;西瓜&lt;/option&gt; #只能预选项里选择 &lt;option&gt;苹果&lt;/option&gt; &lt;option&gt;香蕉&lt;/option&gt; &lt;/select&gt; &lt;/form&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符集和字符编码]]></title>
      <url>%2F2017%2F03%2F11%2F%E5%AD%97%E7%AC%A6%E9%9B%86%26%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[字符集和字符编码计算机中存储的信息都是用二进制数表示的（即0和1，逢二进一，这和计算机逻辑电路中的接通和断开两个物理状态对应），而我们在屏幕上看到的英文汉字是二进制数转换的结果。 字符集（Charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 字符编码（Character Encoding）：规定把字符集中的字符编码成计算机可以接受的存储对象，以便文本在计算机中存储和传递。 常用的字符集：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等 字符集 字符编码 ASCII(american standard code for information interchange)美国信息交换标准代码 主要显示现代英语 7位（bits）表示一个字符，共2^7，128个字符 EASCII 追加扩展了一些欧洲常用字符 8位（bits）表示一个字符，共2^8，256个字符 GB2312 国标，用于汉字 小于127的字符意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。 在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GB18030 对gb2312追加扩展，支持国内少数名族文字 采用多字节编码，与utf-8相同 GBK 微软利用GB 2312未使用的编码空间，收录GB 13000.1-93全部字符制定了GBK编码 字符有一字节和双字节编码 BIG5 繁体字 Unicode 万国码 uft-32（每个字符都使用4个字节，造成存储浪费） / utf-16 / utf-8]]></content>
    </entry>

    
  
  
</search>
